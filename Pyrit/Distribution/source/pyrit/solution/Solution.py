# coding=utf-8
"""Abstract colution class

.. sectionauthor:: Bundschuh
"""

from abc import ABC, abstractmethod
from typing import Union, List, TYPE_CHECKING, Dict, Tuple, Iterable, Any, Type
import pickle
from pathlib import Path

import numpy as np

from pyrit import get_logger

if TYPE_CHECKING:

    from pyrit.mesh import Mesh
    from pyrit.excitation import Excitations
    from pyrit.material import Materials
    from pyrit.region import Regions
    from pyrit.shapefunction import ShapeFunction
    from pyrit.problem import StaticProblem, HarmonicProblem, TransientProblem

logger = get_logger(__name__)


def find_nearest(array: np.ndarray, value: float):
    """Find the index of an entry in array that is nearest to value.

    Parameters
    ----------
    array : np.ndarray
        The array.
    value : float
        Some value.

    Returns
    -------
    index: int
        The index of the nearest entry.
    """
    if value < array.min() or value > array.max():
        logger.warning("The selected time %f is out of bounds of the time steps", value)

    idx = (np.abs(array - value)).argmin()
    return idx


class Solution(ABC):
    """Abstract solution class.

    Solution classes take the solution of a problem and are responsible for the postprocessing.
    """

    #: Identifier for the __repr__ method.
    solution_identifier: str = 'General solution'

    _property_attributes = []  #: List of attributes that are generated by the initialize_attributes method

    ignore_for_saving = []  #: List of attributes that are not saved

    def __init__(self, description: str, solution: np.ndarray, mesh: 'Mesh', shape_function: 'ShapeFunction',
                 regions: 'Regions', materials: 'Materials', excitations: 'Excitations'):
        """A general solution.

        Parameters
        ----------
        description : str
            A description of the solution.
        solution : np.ndarray
            The solution.
        mesh : Mesh
            A mesh object. See :py:mod:`pyrit.mesh`.
        shape_function : ShapeFunction
            A shape function object. See :py:mod:`pyrit.shapefunction`.
        regions : Regions
            A regions object. See :py:mod:`pyrit.regions`.
        materials : Materials
            A materials object. See :py:mod:`pyrit.materials`.
        excitations : Excitations
            An excitations object. See :py:mod:`pyrit.excitation`.
        """
        self.description = description
        self._solution = solution
        self.mesh = mesh
        self.shape_function = shape_function
        self.regions = regions
        self.materials = materials
        self.excitations = excitations

        self.initialize_attributes()

    def __repr__(self):
        return f"{self.solution_identifier}: {self.description}"

    @abstractmethod
    def consistency_check(self):
        """Check if the solution is consistent."""

    def initialize_attributes(self):
        """Initialize the protected attributes needed for the properties."""
        for attr in self._property_attributes:
            if not hasattr(self, attr):
                self.__setattr__(attr, None)

    def save(self, path: Union[str, Path], ignore_attributes: List[str] = None) -> Path:
        """Saves the solution instance.

        Parameters
        ----------
        path : Union[str, Path]
            The path. If a string is given, it is converted to a Path object. The file ending can but must not be given.
            In any case it will be a *.pkl* file. See `pickle doc <https://docs.python.org/3/library/pickle.html>`_ for
            more information.
            If the path contains a non-existing folder, this folder will be created.
        ignore_attributes: List[str], optional
            A list of attributes that are not included in the saved file. The default value is
            :py:attr:`ignore_for_saving` of the object.

        Returns
        -------
        path : Path
            The path that was used for opening the file.
        """
        path = Path(path).with_suffix('.pkl')

        if not path.parent.exists():
            logger.info("Creating path: %s", str(path.parent))
            path.parent.mkdir()

        if ignore_attributes is None:
            ignore_for_saving = self.ignore_for_saving
        else:
            ignore_for_saving = ignore_attributes

        tmp_dict = {}
        for attribute in ignore_for_saving:
            try:
                tmp_dict[attribute] = self.__getattribute__(attribute)
                delattr(self, attribute)
            except AttributeError:
                logger.warning("The object does not contain the attribute '%s'. It is ignored.", attribute)

        logger.info("Saving solution to %s.", str(path))
        with open(path, 'wb') as file:
            pickle.dump(self, file, pickle.HIGHEST_PROTOCOL)
        logger.info("Done saving solution.")

        for attribute in ignore_for_saving:
            try:
                self.__setattr__(attribute, tmp_dict[attribute])
            except KeyError:
                logger.info("The key '%s' does not exist and the object attribute cannot be set.", attribute)

        return path

    @staticmethod
    def load(path: Union[str, Path]) -> 'Solution':
        """Load a solution.

        Parameters
        ----------
        path : Union[str, Path]
            The path. If a string is given, it is converted to a Path object. The file ending can but must not be given.
            In any case it will be a *.pkl* file. See `pickle doc <https://docs.python.org/3/library/pickle.html>`_ for
            more information.

        Returns
        -------
        solution : Solution
            A solution instance.
        """
        path = Path(path).with_suffix('.pkl')

        logger.info("Start reading solution from %s", str(path))
        with open(path, 'rb') as file:
            solution = pickle.load(file)
        logger.info("Done reading solution.")

        solution.initialize_attributes()

        return solution

    @property
    def solution(self) -> np.ndarray:
        """The solution"""
        return self._solution

    @solution.setter
    def solution(self, solution: np.ndarray):
        self._solution = solution


class MiscSolution(Solution):
    """Solution class for managing any kind of solution.

    This solution class is explicitly not associated with any kind of problem class. Its purpose is to manage the
    data structures that define a solution of any problem.
    """

    solution_identifier: str = 'Miscellaneous solution'

    def consistency_check(self):
        pass

    @property
    def solution(self) -> np.ndarray:
        """The solution"""
        return self._solution

    @solution.setter
    def solution(self, solution: np.ndarray):
        self._solution = solution


class StaticSolution(Solution, ABC):
    """A general, static solution."""

    solution_identifier: str = 'General static solution'

    def __init__(self, description: str, solution: np.ndarray, mesh: 'Mesh', shape_function: 'ShapeFunction',
                 regions: 'Regions', materials: 'Materials', excitations: 'Excitations'):
        """A general, static solution.

        Parameters
        ----------
        description : str
            A description of the solution.
        solution : np.ndarray
            The solution.
        mesh : Mesh
            A mesh object. See :py:mod:`pyrit.mesh`.
        shape_function : ShapeFunction
            A shape function object. See :py:mod:`pyrit.shapefunction`.
        regions : Regions
            A regions object. See :py:mod:`pyrit.regions`.
        materials : Materials
            A materials object. See :py:mod:`pyrit.materials`.
        excitations : Excitations
            An excitations object. See :py:mod:`pyrit.excitation`.
        """
        super().__init__(description, solution, mesh, shape_function, regions, materials, excitations)

    @abstractmethod
    def consistency_check(self):
        """Check if the solution is consistent."""

    @classmethod
    def solution_from_problem(cls, description: str, problem: 'StaticProblem',
                              solution: np.ndarray) -> 'StaticSolution':
        """Create a static solution from a static problem.

        Parameters
        ----------
        description : str
            Description of the static solution.
        problem : StaticProblem
            A static problem.
        solution : np.ndarray
            The solution of the static problem.

        Returns
        -------
        static_solution : StaticSolution
        """
        return cls.__call__(description, solution, problem.mesh, problem.shape_function, problem.regions,
                            problem.materials, problem.excitations)

    @staticmethod
    def absolute_field(field: np.ndarray):
        """Computes the absolute field.

        Parameters
        ----------
        field : np.ndarray
            The field. A (N,2) or a (2,N) array.

        Returns
        -------
        absolute_field : np.ndarray
            The absolute value of the field. A (N,) array.

        Raises
        ------
        ValueError : When the input array is not of one of ht expected shapes.
        """
        if field.shape[0] == 2:  # two lines
            return np.linalg.norm(field, axis=0)
        if field.shape[1] == 2:  # two columns
            return np.linalg.norm(field, axis=1)
        raise ValueError("Dimension of field not supported")


class HarmonicSolution(Solution, ABC):
    """A general, harmonic solution."""

    solution_identifier: str = 'General harmonic solution'

    def __init__(self, description: str, solution: np.ndarray, mesh: 'Mesh', shape_function: 'ShapeFunction',
                 regions: 'Regions', materials: 'Materials', excitations: 'Excitations', frequency: float):
        """A general, harmonic solution.

        Parameters
        ----------
        description : str
            A description of the solution.
        solution : np.ndarray
            The solution.
        mesh : Mesh
            A mesh object. See :py:mod:`pyrit.mesh`.
        shape_function : ShapeFunction
            A shape function object. See :py:mod:`pyrit.shapefunction`.
        regions : Regions
            A regions object. See :py:mod:`pyrit.regions`.
        materials : Materials
            A materials object. See :py:mod:`pyrit.materials`.
        excitations : Excitations
            An excitations object. See :py:mod:`pyrit.excitation`.
        frequency : float
            The frequency of the solution.
        """
        super().__init__(description, solution, mesh, shape_function, regions, materials, excitations)
        self._frequency = None
        self.frequency = frequency

    @abstractmethod
    def consistency_check(self):
        """Check if the solution is consistent."""

    @classmethod
    def solution_from_problem(cls, description: str, problem: 'HarmonicProblem',
                              solution: np.ndarray) -> 'HarmonicSolution':
        """Create a harmonic solution from a harmonic problem.

        Parameters
        ----------
        description : str
            Description of the harmonic solution.
        problem : HarmonicProblem
            A static problem.
        solution : np.ndarray
            The solution of the harmonic problem.

        Returns
        -------
        harmonic_solution : HarmonicSolution
        """
        return cls.__call__(description, solution, problem.mesh, problem.shape_function, problem.regions,
                            problem.materials, problem.excitations, problem.frequency)

    @property
    def frequency(self) -> float:
        """The frequency."""
        return self._frequency

    @frequency.setter
    def frequency(self, frequency):
        """The frequency.

        Parameters
        ----------
        frequency : float
            The non-negative frequency.
        """
        if frequency < 0:
            raise ValueError("The frequency must be greater or equal to 0")
        self._frequency = frequency

    @property
    def angular_frequency(self) -> float:
        """The angular frequency."""
        return 2 * np.pi * self.frequency

    omega = angular_frequency

    @staticmethod
    def get_field_at_phase(frequency: float, field: np.ndarray, phase: float = 0, time: float = None):
        r"""Evaluate the complex valued field at a certain phase.

        Each entry in field is a complex number, representing a phasor. Return the field at a certain phase, or for a
        certain time point. Let :math:`\varphi` be the phase and :math:`\underline{g}` be a complex value. Then the
        formula is

        .. math::

            g = \Re\left\{\underline{g} e^{\jmath\varphi}\right\}\,.

        If the time :math:`t` is given, the phase is determined by :math:`\varphi = 2\pi f t`, where :math:`f` is the
        frequency.

        Parameters
        ----------
        frequency : float
            The frequency of the field.
        field : np.ndarray
            The field.
        phase : float, optional
            The phase. Default is 0
        time : float, optional
            The time. Default is None

        Returns
        -------
        field_at_phase : np.ndarray
            Field at the specified phase or time.
        """
        if time is not None:
            logger.info("Using the variable 'time' instead of 'phase'.")
            phase = np.mod(2 * np.pi * frequency * time, 2 * np.pi)
        field_at_phase = np.real(field * np.exp(1j * phase))
        return field_at_phase, phase

    def absolute_field(self, field: np.ndarray, **kwargs):
        """Computes the absolute field.

        Parameters
        ----------
        field : np.ndarray
            The field. A (N,2) or a (2,N) array.

        Returns
        -------
        absolute_field : np.ndarray
            The absolute value of the field. A (N,) array.

        Raises
        ------
        ValueError : When the input array is not of one of ht expected shapes.
        """
        field_at_phase = self.get_field_at_phase(self.frequency, field, **kwargs)[0]
        if field_at_phase.shape[0] == 2:  # two lines
            return np.linalg.norm(field_at_phase, axis=0)
        if field_at_phase.shape[1] == 2:  # two columns
            return np.linalg.norm(field_at_phase, axis=1)
        raise ValueError("Dimension of field not supported")


# region Some docstring and decorators for transient solutions.

get_field_doc = """The {name}.

Parameters
----------
time : float, optional
    Time instance.
index : int, optional
    The index of a time instance.

Returns
-------
result : Union[{result_type}}, Dict[int, {result_type}]]
    If either time or index given, the {name} at the corresponding time instance. Otherwise, a
    dictionary with all already computed values of the {name} at time instances.
"""


def get_field(field: str, doc_name: str, result_type: str):
    """Decorator for some methods in transient solution classes.

    If a time instance is given, returns the field at this time instance. This field is saved in a dictionary (where the
    time index is the key). If the field at this same time instance is requested later, the saved value is returned.
    If no time instance is given, the whole dictionary is returned.

    Parameters
    ----------
    field : str
        The name of the field
    doc_name : str
        A descriptive name of the field. This string is set in the docstring.
    result_type : str
        The basic type of the field. For example 'ndarray' or 'float'.
    """

    def get_inner(func):
        def wrapper(*args, time=None, index=None):
            self = args[0]
            if time is None and index is None:
                return self.__getattribute__(field)
            index = self.get_index(time, index)

            if index not in self.__getattribute__(field).keys():
                self.__getattribute__(field)[index] = func(self, index=index)

            return self.__getattribute__(field)[index]

        wrapper.__doc__ = get_field_doc.replace('{name}', doc_name).replace('{result_type}', result_type)
        return wrapper

    return get_inner


set_field_doc = """Set the {name}.

Parameters
----------
{field} : Union[{field_type}}, Dict[int, {field_type}]]
time : float, optional
    A time instance.
index : int, optional
    The index of a time instance.
"""


def set_field(field: str, doc_name: str, field_type: str):
    """Decorator for some methods transient solution classes.

    Sets a value to a field. If a time instance is given, the value is set for this time instance. Otherwise, the
    internal dictionary is set to this value.

    Furthermore, sets the docstring of the decorated function.

    Parameters
    ----------
    field : str
        The name of the field.
    doc_name : str
        A descriptive name of the field. This string is set in the docstring.
    field_type : str
        The basic type of field. For example 'ndarray' or 'float'.
    """

    def set_inner(func):
        def wrapper(*args, time=None, index=None):
            self = args[0]
            value = args[1]
            if time is None and index is None:
                self.__setattr__(field, value)
            else:
                index = self.get_index(time, index)
                self.__getattribute__(field)[index] = value

        field_name = field
        if field_name.startswith('_'):
            field_name = field_name[1:]
        if field_name.startswith('_'):
            field_name = field_name[1:]
        wrapper.__doc__ = set_field_doc.replace('{name}', doc_name).replace('{field}', field_name).replace(
            '{field_type}', field_type)
        return wrapper

    return set_inner


get_matrix_doc = """The {name}.

Parameters
----------
time : float, optional
    Time instance.
index : int, optional
    The index of a time instance.

Returns
-------
result : Union[sparse.coo_matrix, Dict[int, sparse.coo_matrix]]
    If either time or index given, the {name} at the corresponding time instance. Otherwise, a
    dictionary with all already computed values of the {name} at time instances.
"""


def get_matrix(field: str, doc_name: str):
    """Decorator for some methods in transient solution classes.

    If a time instance is given, returns the matrix at this time instance. This matrix is saved in a dictionary (where
    the time index is the key). If the matrix at this same time instance is requested later, the saved value is
    returned. If no time instance is given, the whole dictionary is returned.

    Parameters
    ----------
    field : str
        The name of the field
    doc_name : str
        A descriptive name of the field. This string is set in the docstring.
    """

    def get_inner(func):
        def wrapper(*args, time=None, index=None):
            self = args[0]
            if time is None and index is None:
                return self.__getattribute__(field)
            index = self.get_index(time, index)

            if index not in self.__getattribute__(field).keys():
                constant, fun = func(self, index=index)
                if constant:
                    index = 0
                    if index not in self.__getattribute__(field).keys():
                        _, fun = func(self, index=index)
                        self.__getattribute__(field)[index] = fun()
                else:  # Nonlinear material

                    self.__getattribute__(field)[index] = fun()

            return self.__getattribute__(field)[index]

        wrapper.__doc__ = get_matrix_doc.replace('{name}', doc_name)
        return wrapper

    return get_inner


def set_matrix(field: str, doc_name: str):
    """Decorator for some methods transient solution classes.

    Sets a value to a field. If a time instance is given, the value is set for this time instance. Otherwise, the
    internal dictionary is set to this value.

    Furthermore, sets the docstring of the decorated function.

    Parameters
    ----------
    field : str
        The name of the field.
    doc_name : str
        A descriptive name of the field. This string is set in the docstring.
    """
    return set_field(field, doc_name, 'sparse.coo_matrix')


# endregion


class TransientSolution(Solution, ABC):
    """A general, transient solution."""

    solution_identifier: str = 'General transient solution'

    _derived_attributes = []  #: List of attributes of derived values

    _matrix_attributes = []  #: List of attributes of matrix values

    def __init__(self, description: str, solution: np.ndarray, mesh: 'Mesh', shape_function: 'ShapeFunction',
                 regions: 'Regions', materials: 'Materials', excitations: 'Excitations', time_steps: np.ndarray,
                 monitor_solutions: Dict[str, Tuple[np.ndarray, np.ndarray]] = None):
        """A general, transient solution.

        Parameters
        ----------
        description : str
            Description of the solution.
        solution : np.ndarray
            A (T,K) array of the solution where T is the number of time steps and K is the size of one solution vector.
        mesh : Mesh
            The mesh object.
        shape_function : ShapeFunction
            The shape function object.
        regions : Regions
            The regions object.
        materials : Materials
            The materials object.
        excitations : Excitations
            The excitations object.
        time_steps : np.ndarray
            A 1-D array with the time steps of the solution values.
        monitor_solutions : Dict[str, Tuple[np.ndarray, np.ndarray]], optional
            A dictionary with monitor solutions. Each entry consists of a name (key) and a tuple of two arrays. The
            first array contains the time steps, at which this monitor has been evaluated. The second entry contains
            the results of the monitor. The size of the first dimension should coincide with the length of the first
            entry.
        """
        super().__init__(description, solution, mesh, shape_function, regions, materials, excitations)
        self.time_steps = time_steps
        if monitor_solutions is None:
            self.monitor_solutions = {}
        else:
            self.monitor_solutions = monitor_solutions

    @abstractmethod
    def consistency_check(self):
        """Check if the solution is consistent."""

    @property
    @abstractmethod
    def related_static_solution(self):
        """The corresponding static solution class."""

    def initialize_attributes(self):
        super().initialize_attributes()

        for attr in self._derived_attributes:
            if not hasattr(self, attr):
                self.__setattr__(attr, {})
        for attr in self._matrix_attributes:
            if not hasattr(self, attr):
                self.__setattr__(attr, {})

    @classmethod
    def solution_from_problem(cls, description: str, problem: 'TransientProblem', solution: np.ndarray,
                              monitor_solutions: Dict[
                                  str, Tuple[np.ndarray, np.ndarray]] = None) -> 'TransientSolution':
        """Create a transient solution from a transient problem.

        Parameters
        ----------
        description : str
            Description of the transient solution.
        problem : TransientProblem
            A transient problem.
        solution : np.ndarray
            The solution of the transient problem.
        monitor_solutions : Dict[str, Tuple[np.ndarray, np.ndarray]], optional
            The monitor solutions.

        Returns
        -------
        transient_solution : TransientSolution
        """
        return cls.__call__(description, solution, problem.mesh, problem.shape_function, problem.regions,
                            problem.materials, problem.excitations, problem.time_steps, monitor_solutions)

    @property
    def start_time(self):
        """The start time of the problem."""
        return self.time_steps[0]

    @property
    def end_time(self):
        """The end time of the problem."""
        return self.time_steps[-1]

    @property
    def time_span(self):
        """The time span of the problem."""
        return self.end_time - self.start_time

    @staticmethod
    def absolute_field(field: Union[np.ndarray, Dict[Any, np.ndarray]]):
        """Computes the absolute field.

        Parameters
        ----------
        field : Union[np.ndarray, Dict[Any, np.ndarray]]
            Either a field or a dictionary with the values being fields.

        Returns
        -------
        absolute_field : Union[np.ndarray, Dict[Any, np.ndarray]]
            The absolute value of the fields.

        Raises
        ------
        ValueError : When the input array is not of one of ht expected shapes.
        """
        if isinstance(field, np.ndarray):
            if field.shape[0] == 2:  # two lines
                return np.linalg.norm(field, axis=0)
            if field.shape[1] == 2:  # two columns
                return np.linalg.norm(field, axis=1)
            raise ValueError("Dimension of field not supported")

        result = {}
        for k, v in field.items():
            if v.shape[0] == 2:  # two lines
                result[k] = np.linalg.norm(v, axis=0)
            elif v.shape[1] == 2:  # two columns
                result[k] = np.linalg.norm(v, axis=1)
            raise ValueError("Dimension of field not supported")
        return result

    def _check_set_types(self, field: Any, basic_type: Type[type]):
        """Check the types of the argument of  set_... methods.

        Parameters
        ----------
        field : Any
            The field passed to a set_... method.
        basic_type : Type[type]
            The basic type of the field. Expected is `basic_type` or a dict of `basic_type` with integer keys.
        """
        fields = []
        if isinstance(field, basic_type):
            fields.append(field)
        elif isinstance(field, dict):
            for key in field.keys():
                if not isinstance(key, int):
                    logger.warning("The key is not an integer. This may lead to errors.")
            fields = fields + list(field.values())
        else:
            logger.error('The given arguments type is not supported.')

        for f in fields:
            if not isinstance(f, basic_type):
                logger.warning('The field is not an array. This may lead to errors.')
            else:
                if not len(f) == self.mesh.num_node:
                    logger.warning('The field has the wrong size. This may lead to errors.')

    def get_index(self, time: float, index: int) -> int:
        """Returns the appropriate index of time_steps.

        If time and index are None, returns None. If only one of both is not None, returns the appropriate index. If
        both are not None, raises a ValueError.

        Parameters
        ----------
        time : float
            A time instance.
        index : int
            An index.

        Returns
        -------
        index : int
            The appropriate index.

        Raises
        ------
        ValueError
            When time and index are both not None.
        """
        if time is None and index is None:
            return None
        if time is not None and index is not None:
            raise ValueError("At least one of time or index must be None.")
        if index is not None:
            if index >= self.time_steps.size:
                logger.warning("The index exceeded the maximal index. Returning the maximal index.")
                return self.time_steps.size - 1
            if index < 0:
                logger.warning("The index is smaller than the minimum index. Returning the minimum index.")
                return 0
            return index
        return find_nearest(self.time_steps, time)

    def get_static_solution(self, *, time: float = None, index: int = None) -> 'StaticSolution':
        """Return an instance of static solution at the specified time instance.

        If not time instance is given, take the last time step.

        Parameters
        ----------
        time : float
            A time instance.
        index : int
            An index.

        Returns
        -------
        static_solution : StaticSolution
            Related static solution at the specified time instance.
        """
        index = self.get_index(time, index)
        if index is None:
            index = -1
        return self.related_static_solution.__call__("Generated solution by 'get_static_solution'",
                                                     self._solution[index], self.mesh, self.shape_function,
                                                     self.regions,
                                                     self.materials, self.excitations)

    def get_indices(self, times: Iterable[float], indices: Iterable[int]) -> List[int]:
        """Return a list of corresponding indices according to times and indices.

        If times and indices are None, returns None. If only one of both is not None, returns the appropriate list. If
        both are not None, raises a ValueError.

        Parameters
        ----------
        times : Iterable[float]
            An iterable with time instances.
        indices : Iterable[int]
            An iterable with indices.

        Returns
        -------
        indices : List[int]
            A list of appropriate indices.

        Raises
        ------
        ValueError
            When times and indices are both not None.
        """
        if times is None and indices is None:
            return None
        if times is not None and indices is not None:
            raise ValueError("At least one of times or indices must be None.")
        if times is not None:
            return [self.get_index(time, None) for time in times]
        if indices is not None:
            return [self.get_index(None, index) for index in indices]
        return None

    def get_animation_indices(self, times: Iterable[float], indices: Union[Iterable[int], int]) -> np.ndarray:
        """Return indices used for the animation.

        If indices is an integer n, return an array with every n-th index, ensuring that the last index is contained.
        If times and indices is None, return an array on all indices.
        If only one of both is not None, return an array of the appropriate indices.
        If both are not None, an Exception is raised.

        Parameters
        ----------
        times : Iterable[float]
            An iterable with time instances.
        indices : Union[Iterable[int], int]
            An iterable with indices.

        Returns
        -------
        indices : np.ndarray
            An array of the indices.
        """
        if isinstance(indices, int):
            indices = np.arange(start=0, stop=len(self.time_steps), step=indices)
            if indices[-1] != len(self.time_steps) - 1:
                indices = np.concatenate((indices, np.array([len(self.time_steps) - 1])))
        else:
            indices = self.get_indices(times, indices)
        if indices is None:
            indices = range(len(self.time_steps))

        return indices

    def get_solution(self, *, time=None, index=None) -> np.ndarray:
        """Return the solution.

        If a time instance is given, return the solution of this time instance. If not, return the whole solution.

        Parameters
        ----------
        time : float
            A time instance.
        index : int
            An index.

        Returns
        -------
        solution : np.ndarray
        """
        if time is None and index is None:
            return self._solution
        return self._solution[self.get_index(time, index)]

    def set_solution(self, solution: np.ndarray, *, time=None, index=None):
        """Set the solution.

        If a time instance is given, set the solution of this time instance. If not, set the whole solution.

        Parameters
        ----------
        solution : np.ndarray
            The solution to set.
        time : float
            A time instance.
        index : int
            An index.
        """
        index = self.get_index(time, index)
        if index is None:
            self._solution = solution
        else:
            self._solution[index] = solution

    def get_interpolation(self, time: float) -> Tuple[List[int], List[float]]:
        """Get indices and weights for a linear interpolation.

        Parameters
        ----------
        time : float
            A time instance.

        Returns
        -------
        indices : List[int]
            The indices of the time steps that has to be taken for the interpolation.
        weights : Lsit[float]
            The weights for the indices that has to be taken for the interpolation.
        """
        index = self.get_index(time, None)
        if np.isclose(time, self.time_steps[index], rtol=1e-5):
            return [index, ], [1, ]
        if time > self.time_steps[index]:
            indices = [index, index + 1]
        else:
            indices = [index - 1, index]
        tmp = (self.time_steps[indices[1]] - time) / (self.time_steps[indices[1]] - self.time_steps[indices[0]])
        weights = [tmp, 1 - tmp]

        return indices, weights

    def _interpolate_solution(self, time: float) -> np.ndarray:
        """Return a interpolated solution at the given time instance.

        Parameters
        ----------
        time : float
            A time instance.

        Returns
        -------
        interpolated_solution : np.ndarray
            The interpolated solution.
        """
        indices, weights = self.get_interpolation(time)

        if len(indices) == 1:
            return self._solution[indices[0]]

        for k, idx in enumerate(indices):
            if k == 0:
                out = weights[k] * self._solution[idx]
            else:
                out += weights[k] * self._solution[idx]
        # out = np.reshape(out, (self.mesh.num_node,))
        return out

    @abstractmethod
    def plot_monitor_solution(self, key: str, **kwargs):
        """Plot a monitor solution over time.

        Parameters
        ----------
        key : str
            Name of the monitor solution. This is the key of the monitor solutions dictionary.
        kwargs :
            Keyword arguments passed to the plot method

        Returns
        -------
        fig: Figure
            An object of matplotlib.figure.Figure.
        ax: Axes
            An object of matplotlib.axes.Axes
        """
