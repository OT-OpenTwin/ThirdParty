; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27041.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BD@PJCBIDD@invalid?5block?5type@		; `string'
PUBLIC	??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths@ ; `string'
PUBLIC	??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5sym@ ; `string'
PUBLIC	??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set@	; `string'
PUBLIC	??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat@ ; `string'
PUBLIC	??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9@ ; `string'
PUBLIC	??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set@ ; `string'
PUBLIC	??_C@_0BG@GMDFCBGP@invalid?5distances?5set@	; `string'
PUBLIC	??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code@ ; `string'
PUBLIC	??_C@_0BG@LBKINIKP@invalid?5distance?5code@	; `string'
PUBLIC	??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back@ ; `string'
;	COMDAT ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back@
CONST	SEGMENT
??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back@ DB 'invalid distanc'
	DB	'e too far back', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LBKINIKP@invalid?5distance?5code@
CONST	SEGMENT
??_C@_0BG@LBKINIKP@invalid?5distance?5code@ DB 'invalid distance code', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code@
CONST	SEGMENT
??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code@ DB 'invalid literal/le'
	DB	'ngth code', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GMDFCBGP@invalid?5distances?5set@
CONST	SEGMENT
??_C@_0BG@GMDFCBGP@invalid?5distances?5set@ DB 'invalid distances set', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set@
CONST	SEGMENT
??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set@ DB 'invalid literal/le'
	DB	'ngths set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9@
CONST	SEGMENT
??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9@ DB 'invalid c'
	DB	'ode -- missing end-of-block', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat@
CONST	SEGMENT
??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat@ DB 'invalid bit length r'
	DB	'epeat', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set@
CONST	SEGMENT
??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set@ DB 'invalid code lengths '
	DB	'set', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5sym@
CONST	SEGMENT
??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5sym@ DB 'too many len'
	DB	'gth or distance symbols', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths@
CONST	SEGMENT
??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths@ DB 'invalid stored bl'
	DB	'ock lengths', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PJCBIDD@invalid?5block?5type@
CONST	SEGMENT
??_C@_0BD@PJCBIDD@invalid?5block?5type@ DB 'invalid block type', 00H ; `string'
?lenfix@?1??fixedtables@@9@9 DB 060H			; `fixedtables'::`2'::lenfix
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c0H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a0H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e0H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	090H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d0H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b0H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f0H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c8H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a8H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e8H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	098H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d8H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b8H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f8H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c4H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a4H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e4H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	094H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d4H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b4H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f4H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0ccH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0acH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0ecH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09cH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0dcH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bcH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fcH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c2H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a2H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e2H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	092H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d2H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b2H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f2H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0caH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0aaH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0eaH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09aH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0daH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0baH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0faH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c6H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a6H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e6H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	096H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d6H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b6H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f6H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0ceH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0aeH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0eeH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09eH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0deH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0beH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0feH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c1H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a1H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e1H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	091H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d1H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b1H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f1H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c9H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a9H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e9H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	099H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d9H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b9H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f9H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c5H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a5H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e5H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	095H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d5H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b5H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f5H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0cdH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0adH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0edH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09dH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0ddH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bdH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fdH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c3H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a3H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e3H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	093H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d3H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b3H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f3H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0cbH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0abH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0ebH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09bH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0dbH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0bbH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0fbH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c7H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a7H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e7H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	097H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d7H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b7H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f7H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0cfH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0afH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0efH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09fH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0dfH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0bfH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0ffH
?distfix@?1??fixedtables@@9@9 DB 010H			; `fixedtables'::`2'::distfix
	DB	05H
	DW	01H
	DB	017H
	DB	05H
	DW	0101H
	DB	013H
	DB	05H
	DW	011H
	DB	01bH
	DB	05H
	DW	01001H
	DB	011H
	DB	05H
	DW	05H
	DB	019H
	DB	05H
	DW	0401H
	DB	015H
	DB	05H
	DW	041H
	DB	01dH
	DB	05H
	DW	04001H
	DB	010H
	DB	05H
	DW	03H
	DB	018H
	DB	05H
	DW	0201H
	DB	014H
	DB	05H
	DW	021H
	DB	01cH
	DB	05H
	DW	02001H
	DB	012H
	DB	05H
	DW	09H
	DB	01aH
	DB	05H
	DW	0801H
	DB	016H
	DB	05H
	DW	081H
	DB	040H
	DB	05H
	DW	00H
	DB	010H
	DB	05H
	DW	02H
	DB	017H
	DB	05H
	DW	0181H
	DB	013H
	DB	05H
	DW	019H
	DB	01bH
	DB	05H
	DW	01801H
	DB	011H
	DB	05H
	DW	07H
	DB	019H
	DB	05H
	DW	0601H
	DB	015H
	DB	05H
	DW	061H
	DB	01dH
	DB	05H
	DW	06001H
	DB	010H
	DB	05H
	DW	04H
	DB	018H
	DB	05H
	DW	0301H
	DB	014H
	DB	05H
	DW	031H
	DB	01cH
	DB	05H
	DW	03001H
	DB	012H
	DB	05H
	DW	0dH
	DB	01aH
	DB	05H
	DW	0c01H
	DB	016H
	DB	05H
	DW	0c1H
	DB	040H
	DB	05H
	DW	00H
?order@?1??inflateBack@@9@9 DW 010H			; `inflateBack'::`2'::order
	DW	011H
	DW	012H
	DW	00H
	DW	08H
	DW	07H
	DW	09H
	DW	06H
	DW	0aH
	DW	05H
	DW	0bH
	DW	04H
	DW	0cH
	DW	03H
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0fH
PUBLIC	inflateBackEnd
PUBLIC	inflateBack
PUBLIC	inflateBackInit_
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateBackEnd DD imagerel $LN6
	DD	imagerel $LN6+65
	DD	imagerel $unwind$inflateBackEnd
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateBack DD imagerel $LN503
	DD	imagerel $LN503+64
	DD	imagerel $unwind$inflateBack
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$inflateBack DD imagerel $LN503+64
	DD	imagerel $LN503+3758
	DD	imagerel $chain$3$inflateBack
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$inflateBack DD imagerel $LN503+3758
	DD	imagerel $LN503+3852
	DD	imagerel $chain$4$inflateBack
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateBackInit_ DD imagerel $LN14
	DD	imagerel $LN14+87
	DD	imagerel $unwind$inflateBackInit_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$inflateBackInit_ DD imagerel $LN14+87
	DD	imagerel $LN14+199
	DD	imagerel $chain$1$inflateBackInit_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$inflateBackInit_ DD imagerel $LN14+199
	DD	imagerel $LN14+232
	DD	imagerel $chain$3$inflateBackInit_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$inflateBackInit_ DD imagerel $LN14+232
	DD	imagerel $LN14+274
	DD	imagerel $chain$4$inflateBackInit_
;	COMDAT xdata
xdata	SEGMENT
$chain$4$inflateBackInit_ DD 021H
	DD	imagerel $LN14
	DD	imagerel $LN14+87
	DD	imagerel $unwind$inflateBackInit_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$inflateBackInit_ DD 040021H
	DD	07e400H
	DD	067400H
	DD	imagerel $LN14
	DD	imagerel $LN14+87
	DD	imagerel $unwind$inflateBackInit_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$inflateBackInit_ DD 040a21H
	DD	07e40aH
	DD	067405H
	DD	imagerel $LN14
	DD	imagerel $LN14+87
	DD	imagerel $unwind$inflateBackInit_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateBackInit_ DD 060f01H
	DD	09540fH
	DD	08340fH
	DD	0600b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$inflateBack DD 021H
	DD	imagerel $LN503
	DD	imagerel $LN503+64
	DD	imagerel $unwind$inflateBack
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$inflateBack DD 082221H
	DD	0be422H
	DD	0c740eH
	DD	0d640aH
	DD	0e3404H
	DD	imagerel $LN503
	DD	imagerel $LN503+64
	DD	imagerel $unwind$inflateBack
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateBack DD 052101H
	DD	0f01ae221H
	DD	0c016d018H
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateBackEnd DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
; File c:\daten\projekte\simulationplatform\third_party_libraries\zlib\zlib-1.2.11\infback.c
;	COMDAT inflateBackInit_
_TEXT	SEGMENT
strm$ = 48
windowBits$ = 56
window$ = 64
version$ = 72
stream_size$ = 80
inflateBackInit_ PROC					; COMDAT

; 34   : {

$LN14:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  0000a	56		 push	 rsi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	49 8b e8	 mov	 rbp, r8
  00012	8b f2		 mov	 esi, edx
  00014	48 8b d9	 mov	 rbx, rcx

; 35   :     struct inflate_state FAR *state;
; 36   : 
; 37   :     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||

  00017	4d 85 c9	 test	 r9, r9
  0001a	0f 84 dd 00 00
	00		 je	 $LN3@inflateBac
  00020	41 80 39 31	 cmp	 BYTE PTR [r9], 49	; 00000031H
  00024	0f 85 d3 00 00
	00		 jne	 $LN3@inflateBac
  0002a	83 7c 24 50 58	 cmp	 DWORD PTR stream_size$[rsp], 88 ; 00000058H
  0002f	0f 85 c8 00 00
	00		 jne	 $LN3@inflateBac

; 38   :         stream_size != (int)(sizeof(z_stream)))
; 39   :         return Z_VERSION_ERROR;
; 40   :     if (strm == Z_NULL || window == Z_NULL ||
; 41   :         windowBits < 8 || windowBits > 15)

  00035	48 85 c9	 test	 rcx, rcx
  00038	0f 84 aa 00 00
	00		 je	 $LN5@inflateBac
  0003e	4d 85 c0	 test	 r8, r8
  00041	0f 84 a1 00 00
	00		 je	 $LN5@inflateBac
  00047	8d 42 f8	 lea	 eax, DWORD PTR [rdx-8]
  0004a	83 f8 07	 cmp	 eax, 7
  0004d	0f 87 95 00 00
	00		 ja	 $LN5@inflateBac

; 43   :     strm->msg = Z_NULL;                 /* in case we return an error */
; 44   :     if (strm->zalloc == (alloc_func)0) {

  00053	48 8b 41 30	 mov	 rax, QWORD PTR [rcx+48]
  00057	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  0005c	4c 89 74 24 38	 mov	 QWORD PTR [rsp+56], r14
  00061	45 33 f6	 xor	 r14d, r14d
  00064	4c 89 71 20	 mov	 QWORD PTR [rcx+32], r14
  00068	48 85 c0	 test	 rax, rax
  0006b	75 14		 jne	 SHORT $LN10@inflateBac

; 45   : #ifdef Z_SOLO
; 46   :         return Z_STREAM_ERROR;
; 47   : #else
; 48   :         strm->zalloc = zcalloc;

  0006d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:zcalloc

; 49   :         strm->opaque = (voidpf)0;

  00074	4c 89 71 40	 mov	 QWORD PTR [rcx+64], r14
  00078	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax
  0007c	41 8b ce	 mov	 ecx, r14d
  0007f	eb 04		 jmp	 SHORT $LN6@inflateBac
$LN10@inflateBac:
  00081	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
$LN6@inflateBac:

; 50   : #endif
; 51   :     }
; 52   :     if (strm->zfree == (free_func)0)

  00085	4c 39 73 38	 cmp	 QWORD PTR [rbx+56], r14
  00089	75 0b		 jne	 SHORT $LN7@inflateBac

; 53   : #ifdef Z_SOLO
; 54   :         return Z_STREAM_ERROR;
; 55   : #else
; 56   :     strm->zfree = zcfree;

  0008b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:zcfree
  00092	48 89 53 38	 mov	 QWORD PTR [rbx+56], rdx
$LN7@inflateBac:

; 57   : #endif
; 58   :     state = (struct inflate_state FAR *)ZALLOC(strm, 1,

  00096	bf 01 00 00 00	 mov	 edi, 1
  0009b	41 b8 f0 1b 00
	00		 mov	 r8d, 7152		; 00001bf0H
  000a1	8b d7		 mov	 edx, edi
  000a3	ff d0		 call	 rax

; 59   :                                                sizeof(struct inflate_state));
; 60   :     if (state == Z_NULL) return Z_MEM_ERROR;

  000a5	48 85 c0	 test	 rax, rax
  000a8	75 1d		 jne	 SHORT $LN8@inflateBac
  000aa	8d 47 fb	 lea	 eax, QWORD PTR [rdi-5]
$LN12@inflateBac:
  000ad	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
  000b2	4c 8b 74 24 38	 mov	 r14, QWORD PTR [rsp+56]

; 70   : }

  000b7	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000bc	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000c1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c5	5e		 pop	 rsi
  000c6	c3		 ret	 0
$LN8@inflateBac:

; 61   :     Tracev((stderr, "inflate: allocated\n"));
; 62   :     strm->state = (struct internal_state FAR *)state;

  000c7	48 89 43 28	 mov	 QWORD PTR [rbx+40], rax

; 63   :     state->dmax = 32768U;
; 64   :     state->wbits = (uInt)windowBits;
; 65   :     state->wsize = 1U << windowBits;

  000cb	8b ce		 mov	 ecx, esi
  000cd	d3 e7		 shl	 edi, cl
  000cf	89 78 34	 mov	 DWORD PTR [rax+52], edi
  000d2	c7 40 1c 00 80
	00 00		 mov	 DWORD PTR [rax+28], 32768 ; 00008000H
  000d9	89 70 30	 mov	 DWORD PTR [rax+48], esi

; 66   :     state->window = window;

  000dc	48 89 68 40	 mov	 QWORD PTR [rax+64], rbp

; 67   :     state->wnext = 0;
; 68   :     state->whave = 0;

  000e0	4c 89 70 38	 mov	 QWORD PTR [rax+56], r14

; 69   :     return Z_OK;

  000e4	33 c0		 xor	 eax, eax
  000e6	eb c5		 jmp	 SHORT $LN12@inflateBac
$LN5@inflateBac:

; 42   :         return Z_STREAM_ERROR;

  000e8	b8 fe ff ff ff	 mov	 eax, -2

; 70   : }

  000ed	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000f2	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000f7	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000fb	5e		 pop	 rsi
  000fc	c3		 ret	 0
$LN3@inflateBac:
  000fd	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00102	b8 fa ff ff ff	 mov	 eax, -6
  00107	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  0010c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00110	5e		 pop	 rsi
  00111	c3		 ret	 0
inflateBackInit_ ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\daten\projekte\simulationplatform\third_party_libraries\zlib\zlib-1.2.11\infback.c
;	COMDAT fixedtables
_TEXT	SEGMENT
state$ = 8
fixedtables PROC					; COMDAT

; 85   : #ifdef BUILDFIXED
; 86   :     static int virgin = 1;
; 87   :     static code *lenfix, *distfix;
; 88   :     static code fixed[544];
; 89   : 
; 90   :     /* build fixed huffman tables if first call (may not be thread safe) */
; 91   :     if (virgin) {
; 92   :         unsigned sym, bits;
; 93   :         static code *next;
; 94   : 
; 95   :         /* literal/length table */
; 96   :         sym = 0;
; 97   :         while (sym < 144) state->lens[sym++] = 8;
; 98   :         while (sym < 256) state->lens[sym++] = 9;
; 99   :         while (sym < 280) state->lens[sym++] = 7;
; 100  :         while (sym < 288) state->lens[sym++] = 8;
; 101  :         next = fixed;
; 102  :         lenfix = next;
; 103  :         bits = 9;
; 104  :         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
; 105  : 
; 106  :         /* distance table */
; 107  :         sym = 0;
; 108  :         while (sym < 32) state->lens[sym++] = 5;
; 109  :         distfix = next;
; 110  :         bits = 5;
; 111  :         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
; 112  : 
; 113  :         /* do this just once */
; 114  :         virgin = 0;
; 115  :     }
; 116  : #else /* !BUILDFIXED */
; 117  : #   include "inffixed.h"
; 118  : #endif /* BUILDFIXED */
; 119  :     state->lencode = lenfix;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?lenfix@?1??fixedtables@@9@9

; 120  :     state->lenbits = 9;

  00007	c7 41 70 09 00
	00 00		 mov	 DWORD PTR [rcx+112], 9
  0000e	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 121  :     state->distcode = distfix;

  00012	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?distfix@?1??fixedtables@@9@9
  00019	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 122  :     state->distbits = 5;

  0001d	c7 41 74 05 00
	00 00		 mov	 DWORD PTR [rcx+116], 5

; 123  : }

  00024	c3		 ret	 0
fixedtables ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\daten\projekte\simulationplatform\third_party_libraries\zlib\zlib-1.2.11\infback.c
;	COMDAT inflateBack
_TEXT	SEGMENT
left$1$ = 48
last$ = 52
here$ = 52
next$ = 56
put$1$ = 64
strm$ = 160
in$ = 168
in_desc$ = 176
out$ = 184
out_desc$ = 192
inflateBack PROC					; COMDAT

; 256  : {

$LN503:
  00000	48 8b c4	 mov	 rax, rsp
  00003	4c 89 48 20	 mov	 QWORD PTR [rax+32], r9
  00007	4c 89 40 18	 mov	 QWORD PTR [rax+24], r8
  0000b	48 89 50 10	 mov	 QWORD PTR [rax+16], rdx
  0000f	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  00013	55		 push	 rbp
  00014	41 54		 push	 r12
  00016	41 55		 push	 r13
  00018	41 57		 push	 r15
  0001a	48 8b ec	 mov	 rbp, rsp
  0001d	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  00021	4d 8b e8	 mov	 r13, r8
  00024	4c 8b e2	 mov	 r12, rdx
  00027	4c 8b d1	 mov	 r10, rcx

; 257  :     struct inflate_state FAR *state;
; 258  :     z_const unsigned char FAR *next;    /* next input */
; 259  :     unsigned char FAR *put;     /* next output */
; 260  :     unsigned have, left;        /* available input and output */
; 261  :     unsigned long hold;         /* bit buffer */
; 262  :     unsigned bits;              /* bits in bit buffer */
; 263  :     unsigned copy;              /* number of stored or match bytes to copy */
; 264  :     unsigned char FAR *from;    /* where to copy match bytes from */
; 265  :     code here;                  /* current decoding table entry */
; 266  :     code last;                  /* parent table entry */
; 267  :     unsigned len;               /* length to copy for repeats, bits to drop */
; 268  :     int ret;                    /* return code */
; 269  :     static const unsigned short order[19] = /* permutation of code lengths */
; 270  :         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
; 271  : 
; 272  :     /* Check that the strm exists and that the state was initialized */
; 273  :     if (strm == Z_NULL || strm->state == Z_NULL)

  0002a	48 85 c9	 test	 rcx, rcx
  0002d	0f 84 7b 0e 00
	00		 je	 $LN254@inflateBac
  00033	4c 8b 79 28	 mov	 r15, QWORD PTR [rcx+40]
  00037	4d 85 ff	 test	 r15, r15
  0003a	0f 84 6e 0e 00
	00		 je	 $LN254@inflateBac

; 275  :     state = (struct inflate_state FAR *)strm->state;
; 276  : 
; 277  :     /* Reset the state */
; 278  :     strm->msg = Z_NULL;

  00040	48 89 58 d8	 mov	 QWORD PTR [rax-40], rbx
  00044	33 d2		 xor	 edx, edx
  00046	48 89 70 d0	 mov	 QWORD PTR [rax-48], rsi
  0004a	48 89 78 c8	 mov	 QWORD PTR [rax-56], rdi
  0004e	48 89 51 20	 mov	 QWORD PTR [rcx+32], rdx

; 279  :     state->mode = TYPE;

  00052	49 c7 47 08 3f
	3f 00 00	 mov	 QWORD PTR [r15+8], 16191 ; 00003f3fH

; 280  :     state->last = 0;
; 281  :     state->whave = 0;

  0005a	41 89 57 38	 mov	 DWORD PTR [r15+56], edx
  0005e	4c 89 70 c0	 mov	 QWORD PTR [rax-64], r14

; 282  :     next = strm->next_in;

  00062	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00065	48 89 45 c0	 mov	 QWORD PTR next$[rbp-120], rax
  00069	48 85 c0	 test	 rax, rax

; 283  :     have = next != Z_NULL ? strm->avail_in : 0;

  0006c	74 05		 je	 SHORT $LN343@inflateBac
  0006e	8b 79 08	 mov	 edi, DWORD PTR [rcx+8]
  00071	eb 02		 jmp	 SHORT $LN344@inflateBac
$LN343@inflateBac:
  00073	8b fa		 mov	 edi, edx
$LN344@inflateBac:

; 284  :     hold = 0;
; 285  :     bits = 0;
; 286  :     put = state->window;
; 287  :     left = state->wsize;
; 288  : 
; 289  :     /* Inflate until end of block marked as last */
; 290  :     for (;;)
; 291  :         switch (state->mode) {

  00075	41 8b 47 08	 mov	 eax, DWORD PTR [r15+8]
  00079	44 8b f2	 mov	 r14d, edx
  0007c	49 8b 5f 40	 mov	 rbx, QWORD PTR [r15+64]
  00080	2d 3f 3f 00 00	 sub	 eax, 16191		; 00003f3fH
  00085	45 8b 4f 34	 mov	 r9d, DWORD PTR [r15+52]
  00089	8b f2		 mov	 esi, edx
  0008b	48 89 5d c8	 mov	 QWORD PTR put$1$[rbp-120], rbx
  0008f	44 89 4d b8	 mov	 DWORD PTR left$1$[rbp-120], r9d
  00093	83 f8 12	 cmp	 eax, 18
  00096	0f 87 db 0d 00
	00		 ja	 $LN341@inflateBac
$LN498@inflateBac:
  0009c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:__ImageBase
  000a3	48 98		 cdqe
  000a5	41 bb 01 00 00
	00		 mov	 r11d, 1
  000ab	41 8b 8c 80 00
	00 00 00	 mov	 ecx, DWORD PTR $LN478@inflateBac[r8+rax*4]
  000b3	49 03 c8	 add	 rcx, r8
  000b6	ff e1		 jmp	 rcx
$LN255@inflateBac:

; 292  :         case TYPE:
; 293  :             /* determine and dispatch block type */
; 294  :             if (state->last) {

  000b8	41 83 7f 0c 00	 cmp	 DWORD PTR [r15+12], 0
  000bd	74 17		 je	 SHORT $LN12@inflateBac

; 295  :                 BYTEBITS();

  000bf	8b ce		 mov	 ecx, esi

; 296  :                 state->mode = DONE;

  000c1	41 c7 47 08 50
	3f 00 00	 mov	 DWORD PTR [r15+8], 16208 ; 00003f50H
  000c9	83 e1 07	 and	 ecx, 7
  000cc	41 d3 ee	 shr	 r14d, cl
  000cf	2b f1		 sub	 esi, ecx

; 297  :                 break;

  000d1	e9 4d 0d 00 00	 jmp	 $LN485@inflateBac
$LN12@inflateBac:

; 298  :             }
; 299  :             NEEDBITS(3);

  000d6	83 fe 03	 cmp	 esi, 3
  000d9	73 41		 jae	 SHORT $LN10@inflateBac
  000db	0f 1f 44 00 00	 npad	 5
$LL13@inflateBac:
  000e0	85 ff		 test	 edi, edi
  000e2	75 14		 jne	 SHORT $LN18@inflateBac
  000e4	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  000e8	49 8b cd	 mov	 rcx, r13
  000eb	41 ff d4	 call	 r12
  000ee	8b f8		 mov	 edi, eax
  000f0	85 c0		 test	 eax, eax
  000f2	0f 84 48 0d 00
	00		 je	 $LN369@inflateBac
$LN18@inflateBac:
  000f8	48 8b 45 c0	 mov	 rax, QWORD PTR next$[rbp-120]
  000fc	8b ce		 mov	 ecx, esi
  000fe	ff cf		 dec	 edi
  00100	83 c6 08	 add	 esi, 8
  00103	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00106	48 ff 45 c0	 inc	 QWORD PTR next$[rbp-120]
  0010a	d3 e0		 shl	 eax, cl
  0010c	44 03 f0	 add	 r14d, eax
  0010f	83 fe 03	 cmp	 esi, 3
  00112	72 cc		 jb	 SHORT $LL13@inflateBac
  00114	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  00118	4c 8b 55 28	 mov	 r10, QWORD PTR strm$[rbp-120]
$LN10@inflateBac:

; 300  :             state->last = BITS(1);

  0011c	41 8b c6	 mov	 eax, r14d

; 301  :             DROPBITS(1);

  0011f	41 d1 ee	 shr	 r14d, 1
  00122	83 e0 01	 and	 eax, 1
  00125	41 89 47 0c	 mov	 DWORD PTR [r15+12], eax

; 302  :             switch (BITS(2)) {

  00129	41 8b c6	 mov	 eax, r14d
  0012c	83 e0 03	 and	 eax, 3
  0012f	74 5e		 je	 SHORT $LN259@inflateBac
  00131	83 e8 01	 sub	 eax, 1
  00134	74 3d		 je	 SHORT $LN260@inflateBac
  00136	83 e8 01	 sub	 eax, 1
  00139	74 24		 je	 SHORT $LN261@inflateBac
  0013b	83 f8 01	 cmp	 eax, 1
  0013e	75 57		 jne	 SHORT $LN28@inflateBac

; 310  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 311  :                         state->last ? " (last)" : ""));
; 312  :                 state->mode = LEN;              /* decode codes */
; 313  :                 break;
; 314  :             case 2:                             /* dynamic block */
; 315  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 316  :                         state->last ? " (last)" : ""));
; 317  :                 state->mode = TABLE;
; 318  :                 break;
; 319  :             case 3:
; 320  :                 strm->msg = (char *)"invalid block type";

  00140	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BD@PJCBIDD@invalid?5block?5type@

; 321  :                 state->mode = BAD;
; 322  :             }
; 323  :             DROPBITS(2);

  00147	41 c1 ee 02	 shr	 r14d, 2
  0014b	49 89 42 20	 mov	 QWORD PTR [r10+32], rax
  0014f	83 c6 fd	 add	 esi, -3			; fffffffdH
  00152	41 c7 47 08 51
	3f 00 00	 mov	 DWORD PTR [r15+8], 16209 ; 00003f51H

; 324  :             break;

  0015a	e9 c4 0c 00 00	 jmp	 $LN485@inflateBac
$LN261@inflateBac:

; 321  :                 state->mode = BAD;
; 322  :             }
; 323  :             DROPBITS(2);

  0015f	41 c1 ee 02	 shr	 r14d, 2
  00163	83 c6 fd	 add	 esi, -3			; fffffffdH
  00166	41 c7 47 08 44
	3f 00 00	 mov	 DWORD PTR [r15+8], 16196 ; 00003f44H

; 324  :             break;

  0016e	e9 b0 0c 00 00	 jmp	 $LN485@inflateBac
$LN260@inflateBac:

; 307  :                 break;
; 308  :             case 1:                             /* fixed block */
; 309  :                 fixedtables(state);

  00173	49 8b cf	 mov	 rcx, r15
  00176	e8 00 00 00 00	 call	 fixedtables

; 321  :                 state->mode = BAD;
; 322  :             }
; 323  :             DROPBITS(2);

  0017b	41 c1 ee 02	 shr	 r14d, 2
  0017f	83 c6 fd	 add	 esi, -3			; fffffffdH
  00182	41 c7 47 08 48
	3f 00 00	 mov	 DWORD PTR [r15+8], 16200 ; 00003f48H

; 324  :             break;

  0018a	e9 94 0c 00 00	 jmp	 $LN485@inflateBac
$LN259@inflateBac:

; 303  :             case 0:                             /* stored block */
; 304  :                 Tracev((stderr, "inflate:     stored block%s\n",
; 305  :                         state->last ? " (last)" : ""));
; 306  :                 state->mode = STORED;

  0018f	41 c7 47 08 41
	3f 00 00	 mov	 DWORD PTR [r15+8], 16193 ; 00003f41H
$LN28@inflateBac:

; 321  :                 state->mode = BAD;
; 322  :             }
; 323  :             DROPBITS(2);

  00197	41 c1 ee 02	 shr	 r14d, 2
  0019b	83 c6 fd	 add	 esi, -3			; fffffffdH

; 324  :             break;

  0019e	e9 80 0c 00 00	 jmp	 $LN485@inflateBac
$LN31@inflateBac:

; 325  : 
; 326  :         case STORED:
; 327  :             /* get and verify stored block length */
; 328  :             BYTEBITS();                         /* go to byte boundary */

  001a3	8b ce		 mov	 ecx, esi
  001a5	83 e1 07	 and	 ecx, 7
  001a8	41 d3 ee	 shr	 r14d, cl
  001ab	2b f1		 sub	 esi, ecx

; 329  :             NEEDBITS(32);

  001ad	83 fe 20	 cmp	 esi, 32			; 00000020H
  001b0	73 3e		 jae	 SHORT $LN32@inflateBac
$LL35@inflateBac:
  001b2	85 ff		 test	 edi, edi
  001b4	75 14		 jne	 SHORT $LN40@inflateBac
  001b6	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  001ba	49 8b cd	 mov	 rcx, r13
  001bd	41 ff d4	 call	 r12
  001c0	8b f8		 mov	 edi, eax
  001c2	85 c0		 test	 eax, eax
  001c4	0f 84 76 0c 00
	00		 je	 $LN369@inflateBac
$LN40@inflateBac:
  001ca	48 8b 45 c0	 mov	 rax, QWORD PTR next$[rbp-120]
  001ce	8b ce		 mov	 ecx, esi
  001d0	ff cf		 dec	 edi
  001d2	83 c6 08	 add	 esi, 8
  001d5	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001d8	48 ff 45 c0	 inc	 QWORD PTR next$[rbp-120]
  001dc	d3 e0		 shl	 eax, cl
  001de	44 03 f0	 add	 r14d, eax
  001e1	83 fe 20	 cmp	 esi, 32			; 00000020H
  001e4	72 cc		 jb	 SHORT $LL35@inflateBac
  001e6	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  001ea	33 d2		 xor	 edx, edx
  001ec	4c 8b 55 28	 mov	 r10, QWORD PTR strm$[rbp-120]
$LN32@inflateBac:

; 330  :             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {

  001f0	41 8b c6	 mov	 eax, r14d
  001f3	45 0f b7 e6	 movzx	 r12d, r14w
  001f7	f7 d0		 not	 eax
  001f9	c1 e8 10	 shr	 eax, 16
  001fc	44 3b e0	 cmp	 r12d, eax
  001ff	74 18		 je	 SHORT $LN266@inflateBac

; 331  :                 strm->msg = (char *)"invalid stored block lengths";

  00201	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths@
  00208	49 89 42 20	 mov	 QWORD PTR [r10+32], rax

; 332  :                 state->mode = BAD;

  0020c	41 c7 47 08 51
	3f 00 00	 mov	 DWORD PTR [r15+8], 16209 ; 00003f51H

; 333  :                 break;

  00214	e9 0a 0c 00 00	 jmp	 $LN485@inflateBac
$LN266@inflateBac:

; 334  :             }
; 335  :             state->length = (unsigned)hold & 0xffff;

  00219	45 89 67 50	 mov	 DWORD PTR [r15+80], r12d

; 336  :             Tracev((stderr, "inflate:       stored length %u\n",
; 337  :                     state->length));
; 338  :             INITBITS();

  0021d	44 8b f2	 mov	 r14d, edx
  00220	8b f2		 mov	 esi, edx

; 339  : 
; 340  :             /* copy stored block from input to output */
; 341  :             while (state->length != 0) {

  00222	45 85 e4	 test	 r12d, r12d
  00225	0f 84 9e 00 00
	00		 je	 $LN47@inflateBac
  0022b	0f 1f 44 00 00	 npad	 5
$LL46@inflateBac:

; 342  :                 copy = state->length;
; 343  :                 PULL();

  00230	85 ff		 test	 edi, edi
  00232	75 14		 jne	 SHORT $LN48@inflateBac
  00234	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00238	49 8b cd	 mov	 rcx, r13
  0023b	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  0023e	8b f8		 mov	 edi, eax
  00240	85 c0		 test	 eax, eax
  00242	0f 84 f8 0b 00
	00		 je	 $LN369@inflateBac
$LN48@inflateBac:

; 344  :                 ROOM();

  00248	8b 5d b8	 mov	 ebx, DWORD PTR left$1$[rbp-120]
  0024b	85 db		 test	 ebx, ebx
  0024d	75 28		 jne	 SHORT $LN51@inflateBac
  0024f	41 8b 5f 34	 mov	 ebx, DWORD PTR [r15+52]
  00253	44 8b c3	 mov	 r8d, ebx
  00256	49 8b 47 40	 mov	 rax, QWORD PTR [r15+64]
  0025a	48 8b 4d 48	 mov	 rcx, QWORD PTR out_desc$[rbp-120]
  0025e	48 8b d0	 mov	 rdx, rax
  00261	48 89 45 c8	 mov	 QWORD PTR put$1$[rbp-120], rax
  00265	89 5d b8	 mov	 DWORD PTR left$1$[rbp-120], ebx
  00268	41 89 5f 38	 mov	 DWORD PTR [r15+56], ebx
  0026c	ff 55 40	 call	 QWORD PTR out$[rbp-120]
  0026f	85 c0		 test	 eax, eax
  00271	0f 85 cf 0b 00
	00		 jne	 $LN372@inflateBac
$LN51@inflateBac:

; 345  :                 if (copy > have) copy = have;
; 346  :                 if (copy > left) copy = left;
; 347  :                 zmemcpy(put, next, copy);

  00277	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
  0027b	44 3b e7	 cmp	 r12d, edi
  0027e	8b c3		 mov	 eax, ebx
  00280	8b cf		 mov	 ecx, edi
  00282	41 0f 46 cc	 cmovbe	 ecx, r12d
  00286	4c 8b 65 c8	 mov	 r12, QWORD PTR put$1$[rbp-120]
  0028a	3b cb		 cmp	 ecx, ebx
  0028c	0f 46 c1	 cmovbe	 eax, ecx
  0028f	49 8b cc	 mov	 rcx, r12
  00292	44 8b c0	 mov	 r8d, eax
  00295	8b d8		 mov	 ebx, eax
  00297	e8 00 00 00 00	 call	 memcpy

; 348  :                 have -= copy;
; 349  :                 next += copy;

  0029c	48 01 5d c0	 add	 QWORD PTR next$[rbp-120], rbx

; 350  :                 left -= copy;
; 351  :                 put += copy;

  002a0	4c 03 e3	 add	 r12, rbx
  002a3	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  002a7	2b fb		 sub	 edi, ebx
  002a9	4c 89 65 c8	 mov	 QWORD PTR put$1$[rbp-120], r12
  002ad	44 2b cb	 sub	 r9d, ebx

; 352  :                 state->length -= copy;

  002b0	45 8b 67 50	 mov	 r12d, DWORD PTR [r15+80]
  002b4	44 2b e3	 sub	 r12d, ebx
  002b7	44 89 4d b8	 mov	 DWORD PTR left$1$[rbp-120], r9d
  002bb	45 89 67 50	 mov	 DWORD PTR [r15+80], r12d
  002bf	0f 85 6b ff ff
	ff		 jne	 $LL46@inflateBac
  002c5	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
$LN47@inflateBac:

; 353  :             }
; 354  :             Tracev((stderr, "inflate:       stored end\n"));
; 355  :             state->mode = TYPE;

  002c9	41 c7 47 08 3f
	3f 00 00	 mov	 DWORD PTR [r15+8], 16191 ; 00003f3fH

; 356  :             break;

  002d1	e9 49 0b 00 00	 jmp	 $LN495@inflateBac
$LN56@inflateBac:

; 357  : 
; 358  :         case TABLE:
; 359  :             /* get dynamic table entries descriptor */
; 360  :             NEEDBITS(14);

  002d6	83 fe 0e	 cmp	 esi, 14
  002d9	73 41		 jae	 SHORT $LN54@inflateBac
  002db	0f 1f 44 00 00	 npad	 5
$LL57@inflateBac:
  002e0	85 ff		 test	 edi, edi
  002e2	75 14		 jne	 SHORT $LN62@inflateBac
  002e4	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  002e8	49 8b cd	 mov	 rcx, r13
  002eb	41 ff d4	 call	 r12
  002ee	8b f8		 mov	 edi, eax
  002f0	85 c0		 test	 eax, eax
  002f2	0f 84 48 0b 00
	00		 je	 $LN369@inflateBac
$LN62@inflateBac:
  002f8	48 8b 45 c0	 mov	 rax, QWORD PTR next$[rbp-120]
  002fc	8b ce		 mov	 ecx, esi
  002fe	ff cf		 dec	 edi
  00300	83 c6 08	 add	 esi, 8
  00303	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00306	48 ff 45 c0	 inc	 QWORD PTR next$[rbp-120]
  0030a	d3 e0		 shl	 eax, cl
  0030c	44 03 f0	 add	 r14d, eax
  0030f	83 fe 0e	 cmp	 esi, 14
  00312	72 cc		 jb	 SHORT $LL57@inflateBac
  00314	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  00318	4c 8b 55 28	 mov	 r10, QWORD PTR strm$[rbp-120]
$LN54@inflateBac:

; 361  :             state->nlen = BITS(5) + 257;

  0031c	41 8b ce	 mov	 ecx, r14d

; 362  :             DROPBITS(5);
; 363  :             state->ndist = BITS(5) + 1;
; 364  :             DROPBITS(5);
; 365  :             state->ncode = BITS(4) + 4;
; 366  :             DROPBITS(4);

  0031f	83 c6 f2	 add	 esi, -14		; fffffff2H
  00322	41 c1 ee 05	 shr	 r14d, 5
  00326	83 e1 1f	 and	 ecx, 31
  00329	41 8b d6	 mov	 edx, r14d
  0032c	81 c1 01 01 00
	00		 add	 ecx, 257		; 00000101H
  00332	41 c1 ee 05	 shr	 r14d, 5
  00336	83 e2 1f	 and	 edx, 31
  00339	45 8b c6	 mov	 r8d, r14d
  0033c	41 89 4f 7c	 mov	 DWORD PTR [r15+124], ecx
  00340	41 83 e0 0f	 and	 r8d, 15
  00344	41 c1 ee 04	 shr	 r14d, 4
  00348	41 83 c0 04	 add	 r8d, 4
  0034c	ff c2		 inc	 edx
  0034e	41 89 97 80 00
	00 00		 mov	 DWORD PTR [r15+128], edx
  00355	45 89 47 78	 mov	 DWORD PTR [r15+120], r8d

; 367  : #ifndef PKZIP_BUG_WORKAROUND
; 368  :             if (state->nlen > 286 || state->ndist > 30) {

  00359	81 f9 1e 01 00
	00		 cmp	 ecx, 286		; 0000011eH
  0035f	0f 87 94 05 00
	00		 ja	 $LN277@inflateBac
  00365	83 fa 1e	 cmp	 edx, 30
  00368	0f 87 8b 05 00
	00		 ja	 $LN277@inflateBac

; 372  :             }
; 373  : #endif
; 374  :             Tracev((stderr, "inflate:       table sizes ok\n"));
; 375  : 
; 376  :             /* get code length code lengths (not a typo) */
; 377  :             state->have = 0;

  0036e	33 c9		 xor	 ecx, ecx

; 378  :             while (state->have < state->ncode) {

  00370	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
  00377	41 89 8f 84 00
	00 00		 mov	 DWORD PTR [r15+132], ecx
  0037e	8b c1		 mov	 eax, ecx
  00380	45 85 c0	 test	 r8d, r8d
  00383	0f 84 96 00 00
	00		 je	 $LN352@inflateBac
  00389	0f 1f 80 00 00
	00 00		 npad	 7
$LL74@inflateBac:

; 379  :                 NEEDBITS(3);

  00390	83 fe 03	 cmp	 esi, 3
  00393	73 49		 jae	 SHORT $LN76@inflateBac
  00395	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
  00399	0f 1f 80 00 00
	00 00		 npad	 7
$LL79@inflateBac:
  003a0	85 ff		 test	 edi, edi
  003a2	75 18		 jne	 SHORT $LN84@inflateBac
  003a4	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  003a8	49 8b cd	 mov	 rcx, r13
  003ab	41 ff d4	 call	 r12
  003ae	8b f8		 mov	 edi, eax
  003b0	85 c0		 test	 eax, eax
  003b2	0f 84 88 0a 00
	00		 je	 $LN369@inflateBac
  003b8	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
$LN84@inflateBac:
  003bc	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  003bf	8b ce		 mov	 ecx, esi
  003c1	d3 e0		 shl	 eax, cl
  003c3	48 ff c2	 inc	 rdx
  003c6	44 03 f0	 add	 r14d, eax
  003c9	48 89 55 c0	 mov	 QWORD PTR next$[rbp-120], rdx
  003cd	ff cf		 dec	 edi
  003cf	83 c6 08	 add	 esi, 8
  003d2	83 fe 03	 cmp	 esi, 3
  003d5	72 c9		 jb	 SHORT $LL79@inflateBac
  003d7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
$LN76@inflateBac:

; 380  :                 state->lens[order[state->have++]] = (unsigned short)BITS(3);

  003de	41 8b 87 84 00
	00 00		 mov	 eax, DWORD PTR [r15+132]
  003e5	41 0f b7 ce	 movzx	 ecx, r14w
  003e9	66 83 e1 07	 and	 cx, 7

; 381  :                 DROPBITS(3);

  003ed	41 c1 ee 03	 shr	 r14d, 3
  003f1	83 c6 fd	 add	 esi, -3			; fffffffdH
  003f4	0f b7 84 42 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflateBack@@9@9[rdx+rax*2]
  003fc	66 41 89 8c 47
	90 00 00 00	 mov	 WORD PTR [r15+rax*2+144], cx
  00405	41 ff 87 84 00
	00 00		 inc	 DWORD PTR [r15+132]
  0040c	41 8b 87 84 00
	00 00		 mov	 eax, DWORD PTR [r15+132]
  00413	41 3b 47 78	 cmp	 eax, DWORD PTR [r15+120]
  00417	0f 82 73 ff ff
	ff		 jb	 $LL74@inflateBac
  0041d	33 c9		 xor	 ecx, ecx
$LN352@inflateBac:

; 382  :             }
; 383  :             while (state->have < 19)

  0041f	83 f8 13	 cmp	 eax, 19
  00422	73 35		 jae	 SHORT $LN91@inflateBac
  00424	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL90@inflateBac:

; 384  :                 state->lens[order[state->have++]] = 0;

  00430	41 8b 87 84 00
	00 00		 mov	 eax, DWORD PTR [r15+132]
  00437	0f b7 84 42 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflateBack@@9@9[rdx+rax*2]
  0043f	66 41 89 8c 47
	90 00 00 00	 mov	 WORD PTR [r15+rax*2+144], cx
  00448	41 ff 87 84 00
	00 00		 inc	 DWORD PTR [r15+132]
  0044f	41 83 bf 84 00
	00 00 13	 cmp	 DWORD PTR [r15+132], 19
  00457	72 d7		 jb	 SHORT $LL90@inflateBac
$LN91@inflateBac:

; 385  :             state->next = state->codes;

  00459	49 8d 87 50 05
	00 00		 lea	 rax, QWORD PTR [r15+1360]

; 386  :             state->lencode = (code const FAR *)(state->next);
; 387  :             state->lenbits = 7;

  00460	41 c7 47 70 07
	00 00 00	 mov	 DWORD PTR [r15+112], 7

; 388  :             ret = inflate_table(CODES, state->lens, 19, &(state->next),

  00468	49 8d 97 10 03
	00 00		 lea	 rdx, QWORD PTR [r15+784]
  0046f	49 89 87 88 00
	00 00		 mov	 QWORD PTR [r15+136], rax
  00476	48 89 54 24 28	 mov	 QWORD PTR [rsp+40], rdx
  0047b	4d 8d 8f 88 00
	00 00		 lea	 r9, QWORD PTR [r15+136]
  00482	49 89 47 60	 mov	 QWORD PTR [r15+96], rax
  00486	49 8d 97 90 00
	00 00		 lea	 rdx, QWORD PTR [r15+144]
  0048d	49 8d 47 70	 lea	 rax, QWORD PTR [r15+112]
  00491	41 b8 13 00 00
	00		 mov	 r8d, 19
  00497	33 c9		 xor	 ecx, ecx
  00499	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0049e	e8 00 00 00 00	 call	 inflate_table

; 389  :                                 &(state->lenbits), state->work);
; 390  :             if (ret) {

  004a3	85 c0		 test	 eax, eax
  004a5	74 20		 je	 SHORT $LN280@inflateBac

; 391  :                 strm->msg = (char *)"invalid code lengths set";

  004a7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set@
$LN501@inflateBac:

; 284  :     hold = 0;
; 285  :     bits = 0;
; 286  :     put = state->window;
; 287  :     left = state->wsize;
; 288  : 
; 289  :     /* Inflate until end of block marked as last */
; 290  :     for (;;)
; 291  :         switch (state->mode) {

  004ae	4c 8b 55 28	 mov	 r10, QWORD PTR strm$[rbp-120]
  004b2	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  004b6	49 89 42 20	 mov	 QWORD PTR [r10+32], rax
  004ba	41 c7 47 08 51
	3f 00 00	 mov	 DWORD PTR [r15+8], 16209 ; 00003f51H
  004c2	e9 5c 09 00 00	 jmp	 $LN485@inflateBac
$LN280@inflateBac:

; 392  :                 state->mode = BAD;
; 393  :                 break;
; 394  :             }
; 395  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 396  : 
; 397  :             /* get length and distance code code lengths */
; 398  :             state->have = 0;
; 399  :             while (state->have < state->nlen + state->ndist) {

  004c7	41 8b 87 80 00
	00 00		 mov	 eax, DWORD PTR [r15+128]
  004ce	41 c7 87 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR [r15+132], 0
  004d9	41 03 47 7c	 add	 eax, DWORD PTR [r15+124]
  004dd	0f 84 9a 02 00
	00		 je	 $LN93@inflateBac
  004e3	0f 1f 40 00 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL92@inflateBac:

; 400  :                 for (;;) {
; 401  :                     here = state->lencode[BITS(state->lenbits)];

  004f0	41 8b 4f 70	 mov	 ecx, DWORD PTR [r15+112]
  004f4	b8 01 00 00 00	 mov	 eax, 1

; 402  :                     if ((unsigned)(here.bits) <= bits) break;

  004f9	4c 8b 45 c0	 mov	 r8, QWORD PTR next$[rbp-120]
  004fd	d3 e0		 shl	 eax, cl
  004ff	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  00502	41 8b c6	 mov	 eax, r14d
  00505	48 23 c8	 and	 rcx, rax
  00508	49 8b 47 60	 mov	 rax, QWORD PTR [r15+96]
  0050c	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  0050f	8b d0		 mov	 edx, eax
  00511	c1 ea 08	 shr	 edx, 8
  00514	44 8b c8	 mov	 r9d, eax
  00517	0f b6 ca	 movzx	 ecx, dl
  0051a	41 c1 e9 10	 shr	 r9d, 16
  0051e	89 45 bc	 mov	 DWORD PTR here$[rbp-120], eax
  00521	3b ce		 cmp	 ecx, esi
  00523	76 64		 jbe	 SHORT $LN445@inflateBac
$LL94@inflateBac:

; 403  :                     PULLBYTE();

  00525	85 ff		 test	 edi, edi
  00527	75 18		 jne	 SHORT $LN100@inflateBac
  00529	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  0052d	49 8b cd	 mov	 rcx, r13
  00530	41 ff d4	 call	 r12
  00533	8b f8		 mov	 edi, eax
  00535	85 c0		 test	 eax, eax
  00537	0f 84 03 09 00
	00		 je	 $LN369@inflateBac
  0053d	4c 8b 45 c0	 mov	 r8, QWORD PTR next$[rbp-120]
$LN100@inflateBac:
  00541	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  00545	8b ce		 mov	 ecx, esi
  00547	d3 e0		 shl	 eax, cl
  00549	49 ff c0	 inc	 r8
  0054c	44 03 f0	 add	 r14d, eax
  0054f	4c 89 45 c0	 mov	 QWORD PTR next$[rbp-120], r8
  00553	41 8b 4f 70	 mov	 ecx, DWORD PTR [r15+112]
  00557	b8 01 00 00 00	 mov	 eax, 1
  0055c	d3 e0		 shl	 eax, cl
  0055e	ff cf		 dec	 edi
  00560	41 8b d6	 mov	 edx, r14d
  00563	83 c6 08	 add	 esi, 8
  00566	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  00569	49 8b 47 60	 mov	 rax, QWORD PTR [r15+96]
  0056d	48 23 ca	 and	 rcx, rdx
  00570	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  00573	8b d0		 mov	 edx, eax
  00575	c1 ea 08	 shr	 edx, 8
  00578	44 8b c8	 mov	 r9d, eax
  0057b	0f b6 ca	 movzx	 ecx, dl
  0057e	41 c1 e9 10	 shr	 r9d, 16
  00582	89 45 bc	 mov	 DWORD PTR here$[rbp-120], eax
  00585	3b ce		 cmp	 ecx, esi
  00587	77 9c		 ja	 SHORT $LL94@inflateBac
$LN445@inflateBac:

; 404  :                 }
; 405  :                 if (here.val < 16) {

  00589	8b da		 mov	 ebx, edx
  0058b	44 8b da	 mov	 r11d, edx
  0058e	41 8b c9	 mov	 ecx, r9d
  00591	44 8b d2	 mov	 r10d, edx
  00594	66 41 83 f9 10	 cmp	 r9w, 16
  00599	73 32		 jae	 SHORT $LN284@inflateBac

; 406  :                     DROPBITS(here.bits);

  0059b	0f b6 ca	 movzx	 ecx, dl

; 407  :                     state->lens[state->have++] = here.val;

  0059e	c1 e8 10	 shr	 eax, 16
  005a1	41 d3 ee	 shr	 r14d, cl
  005a4	41 0f b6 ca	 movzx	 ecx, r10b
  005a8	2b f1		 sub	 esi, ecx
  005aa	41 8b 8f 84 00
	00 00		 mov	 ecx, DWORD PTR [r15+132]
  005b1	66 41 89 84 4f
	90 00 00 00	 mov	 WORD PTR [r15+rcx*2+144], ax
  005ba	41 ff 87 84 00
	00 00		 inc	 DWORD PTR [r15+132]
  005c1	41 8b 8f 84 00
	00 00		 mov	 ecx, DWORD PTR [r15+132]

; 408  :                 }

  005c8	e9 99 01 00 00	 jmp	 $LN406@inflateBac
$LN284@inflateBac:

; 409  :                 else {
; 410  :                     if (here.val == 16) {

  005cd	66 83 f9 10	 cmp	 cx, 16
  005d1	75 7c		 jne	 SHORT $LN286@inflateBac

; 411  :                         NEEDBITS(here.bits + 2);

  005d3	41 0f b6 db	 movzx	 ebx, r11b
  005d7	83 c3 02	 add	 ebx, 2
  005da	3b f3		 cmp	 esi, ebx
  005dc	73 39		 jae	 SHORT $LN106@inflateBac
  005de	66 90		 npad	 2
$LL109@inflateBac:
  005e0	85 ff		 test	 edi, edi
  005e2	75 18		 jne	 SHORT $LN114@inflateBac
  005e4	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  005e8	49 8b cd	 mov	 rcx, r13
  005eb	41 ff d4	 call	 r12
  005ee	8b f8		 mov	 edi, eax
  005f0	85 c0		 test	 eax, eax
  005f2	0f 84 48 08 00
	00		 je	 $LN369@inflateBac
  005f8	4c 8b 45 c0	 mov	 r8, QWORD PTR next$[rbp-120]
$LN114@inflateBac:
  005fc	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  00600	8b ce		 mov	 ecx, esi
  00602	d3 e0		 shl	 eax, cl
  00604	49 ff c0	 inc	 r8
  00607	44 03 f0	 add	 r14d, eax
  0060a	4c 89 45 c0	 mov	 QWORD PTR next$[rbp-120], r8
  0060e	ff cf		 dec	 edi
  00610	83 c6 08	 add	 esi, 8
  00613	3b f3		 cmp	 esi, ebx
  00615	72 c9		 jb	 SHORT $LL109@inflateBac
$LN106@inflateBac:

; 412  :                         DROPBITS(here.bits);

  00617	0f b6 4d bd	 movzx	 ecx, BYTE PTR here$[rbp-119]

; 413  :                         if (state->have == 0) {

  0061b	41 8b 87 84 00
	00 00		 mov	 eax, DWORD PTR [r15+132]
  00622	2b f1		 sub	 esi, ecx
  00624	41 d3 ee	 shr	 r14d, cl
  00627	85 c0		 test	 eax, eax
  00629	0f 84 73 01 00
	00		 je	 $LN380@inflateBac

; 414  :                             strm->msg = (char *)"invalid bit length repeat";
; 415  :                             state->mode = BAD;
; 416  :                             break;
; 417  :                         }
; 418  :                         len = (unsigned)(state->lens[state->have - 1]);
; 419  :                         copy = 3 + BITS(2);

  0062f	41 8b d6	 mov	 edx, r14d

; 420  :                         DROPBITS(2);

  00632	83 c6 fe	 add	 esi, -2			; fffffffeH
  00635	83 e2 03	 and	 edx, 3
  00638	41 c1 ee 02	 shr	 r14d, 2
  0063c	83 c2 03	 add	 edx, 3
  0063f	ff c8		 dec	 eax
  00641	45 0f b7 84 47
	90 00 00 00	 movzx	 r8d, WORD PTR [r15+rax*2+144]

; 421  :                     }

  0064a	e9 cd 00 00 00	 jmp	 $LN155@inflateBac
$LN286@inflateBac:

; 422  :                     else if (here.val == 17) {

  0064f	0f b6 c3	 movzx	 eax, bl
  00652	66 41 83 f9 11	 cmp	 r9w, 17
  00657	75 62		 jne	 SHORT $LN142@inflateBac

; 423  :                         NEEDBITS(here.bits + 3);

  00659	8d 58 03	 lea	 ebx, DWORD PTR [rax+3]
  0065c	3b f3		 cmp	 esi, ebx
  0065e	73 37		 jae	 SHORT $LN123@inflateBac
$LL126@inflateBac:
  00660	85 ff		 test	 edi, edi
  00662	75 18		 jne	 SHORT $LN131@inflateBac
  00664	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00668	49 8b cd	 mov	 rcx, r13
  0066b	41 ff d4	 call	 r12
  0066e	8b f8		 mov	 edi, eax
  00670	85 c0		 test	 eax, eax
  00672	0f 84 c8 07 00
	00		 je	 $LN369@inflateBac
  00678	4c 8b 45 c0	 mov	 r8, QWORD PTR next$[rbp-120]
$LN131@inflateBac:
  0067c	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  00680	8b ce		 mov	 ecx, esi
  00682	d3 e0		 shl	 eax, cl
  00684	49 ff c0	 inc	 r8
  00687	44 03 f0	 add	 r14d, eax
  0068a	4c 89 45 c0	 mov	 QWORD PTR next$[rbp-120], r8
  0068e	ff cf		 dec	 edi
  00690	83 c6 08	 add	 esi, 8
  00693	3b f3		 cmp	 esi, ebx
  00695	72 c9		 jb	 SHORT $LL126@inflateBac
$LN123@inflateBac:

; 424  :                         DROPBITS(here.bits);

  00697	0f b6 4d bd	 movzx	 ecx, BYTE PTR here$[rbp-119]

; 425  :                         len = 0;
; 426  :                         copy = 3 + BITS(3);
; 427  :                         DROPBITS(3);

  0069b	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  006a0	41 d3 ee	 shr	 r14d, cl
  006a3	2b c1		 sub	 eax, ecx
  006a5	41 8b d6	 mov	 edx, r14d
  006a8	03 f0		 add	 esi, eax
  006aa	83 e2 07	 and	 edx, 7
  006ad	41 c1 ee 03	 shr	 r14d, 3
  006b1	83 c2 03	 add	 edx, 3
  006b4	33 c0		 xor	 eax, eax
  006b6	44 8b c0	 mov	 r8d, eax

; 428  :                     }

  006b9	eb 61		 jmp	 SHORT $LN155@inflateBac
$LN142@inflateBac:

; 429  :                     else {
; 430  :                         NEEDBITS(here.bits + 7);

  006bb	8d 58 07	 lea	 ebx, DWORD PTR [rax+7]
  006be	3b f3		 cmp	 esi, ebx
  006c0	73 37		 jae	 SHORT $LN140@inflateBac
$LL143@inflateBac:
  006c2	85 ff		 test	 edi, edi
  006c4	75 18		 jne	 SHORT $LN148@inflateBac
  006c6	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  006ca	49 8b cd	 mov	 rcx, r13
  006cd	41 ff d4	 call	 r12
  006d0	8b f8		 mov	 edi, eax
  006d2	85 c0		 test	 eax, eax
  006d4	0f 84 66 07 00
	00		 je	 $LN369@inflateBac
  006da	4c 8b 45 c0	 mov	 r8, QWORD PTR next$[rbp-120]
$LN148@inflateBac:
  006de	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  006e2	8b ce		 mov	 ecx, esi
  006e4	d3 e0		 shl	 eax, cl
  006e6	49 ff c0	 inc	 r8
  006e9	44 03 f0	 add	 r14d, eax
  006ec	4c 89 45 c0	 mov	 QWORD PTR next$[rbp-120], r8
  006f0	ff cf		 dec	 edi
  006f2	83 c6 08	 add	 esi, 8
  006f5	3b f3		 cmp	 esi, ebx
  006f7	72 c9		 jb	 SHORT $LL143@inflateBac
$LN140@inflateBac:

; 431  :                         DROPBITS(here.bits);

  006f9	0f b6 4d bd	 movzx	 ecx, BYTE PTR here$[rbp-119]

; 432  :                         len = 0;
; 433  :                         copy = 11 + BITS(7);
; 434  :                         DROPBITS(7);

  006fd	b8 f9 ff ff ff	 mov	 eax, -7			; fffffff9H
  00702	41 d3 ee	 shr	 r14d, cl
  00705	2b c1		 sub	 eax, ecx
  00707	41 8b d6	 mov	 edx, r14d
  0070a	03 f0		 add	 esi, eax
  0070c	83 e2 7f	 and	 edx, 127		; 0000007fH
  0070f	41 c1 ee 07	 shr	 r14d, 7
  00713	83 c2 0b	 add	 edx, 11
  00716	33 c0		 xor	 eax, eax
  00718	44 0f b7 c0	 movzx	 r8d, ax
$LN155@inflateBac:

; 435  :                     }
; 436  :                     if (state->have + copy > state->nlen + state->ndist) {

  0071c	41 8b 8f 84 00
	00 00		 mov	 ecx, DWORD PTR [r15+132]
  00723	41 8b 87 80 00
	00 00		 mov	 eax, DWORD PTR [r15+128]
  0072a	03 ca		 add	 ecx, edx
  0072c	41 03 47 7c	 add	 eax, DWORD PTR [r15+124]
  00730	3b c8		 cmp	 ecx, eax
  00732	77 6e		 ja	 SHORT $LN380@inflateBac
  00734	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL157@inflateBac:

; 437  :                         strm->msg = (char *)"invalid bit length repeat";
; 438  :                         state->mode = BAD;
; 439  :                         break;
; 440  :                     }
; 441  :                     while (copy--)
; 442  :                         state->lens[state->have++] = (unsigned short)len;

  00740	41 8b 87 84 00
	00 00		 mov	 eax, DWORD PTR [r15+132]
  00747	66 45 89 84 47
	90 00 00 00	 mov	 WORD PTR [r15+rax*2+144], r8w
  00750	41 8b 8f 84 00
	00 00		 mov	 ecx, DWORD PTR [r15+132]
  00757	8d 49 01	 lea	 ecx, DWORD PTR [rcx+1]
  0075a	41 89 8f 84 00
	00 00		 mov	 DWORD PTR [r15+132], ecx
  00761	83 c2 ff	 add	 edx, -1			; ffffffffH
  00764	75 da		 jne	 SHORT $LL157@inflateBac
$LN406@inflateBac:

; 392  :                 state->mode = BAD;
; 393  :                 break;
; 394  :             }
; 395  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 396  : 
; 397  :             /* get length and distance code code lengths */
; 398  :             state->have = 0;
; 399  :             while (state->have < state->nlen + state->ndist) {

  00766	41 8b 87 80 00
	00 00		 mov	 eax, DWORD PTR [r15+128]
  0076d	41 03 47 7c	 add	 eax, DWORD PTR [r15+124]
  00771	3b c8		 cmp	 ecx, eax
  00773	0f 82 77 fd ff
	ff		 jb	 $LL92@inflateBac

; 513  :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 514  :                         "inflate:         literal '%c'\n" :
; 515  :                         "inflate:         literal 0x%02x\n", here.val));
; 516  :                 ROOM();

  00779	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
$LN93@inflateBac:

; 443  :                 }
; 444  :             }
; 445  : 
; 446  :             /* handle error breaks in while */
; 447  :             if (state->mode == BAD) break;

  0077d	41 81 7f 08 51
	3f 00 00	 cmp	 DWORD PTR [r15+8], 16209 ; 00003f51H
  00785	0f 84 5d 03 00
	00		 je	 $LN492@inflateBac

; 448  : 
; 449  :             /* check for end-of-block code (better have one) */
; 450  :             if (state->lens[256] == 0) {

  0078b	66 41 83 bf 90
	02 00 00 00	 cmp	 WORD PTR [r15+656], 0
  00794	75 1c		 jne	 SHORT $LN299@inflateBac

; 451  :                 strm->msg = (char *)"invalid code -- missing end-of-block";

  00796	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9@

; 452  :                 state->mode = BAD;
; 453  :                 break;

  0079d	e9 0c fd ff ff	 jmp	 $LN501@inflateBac
$LN380@inflateBac:

; 284  :     hold = 0;
; 285  :     bits = 0;
; 286  :     put = state->window;
; 287  :     left = state->wsize;
; 288  : 
; 289  :     /* Inflate until end of block marked as last */
; 290  :     for (;;)
; 291  :         switch (state->mode) {

  007a2	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
  007a6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat@
  007ad	e9 fc fc ff ff	 jmp	 $LN501@inflateBac
$LN299@inflateBac:

; 454  :             }
; 455  : 
; 456  :             /* build code tables -- note: do not change the lenbits or distbits
; 457  :                values here (9 and 6) without reading the comments in inftrees.h
; 458  :                concerning the ENOUGH constants, which depend on those values */
; 459  :             state->next = state->codes;

  007b2	49 8d 87 50 05
	00 00		 lea	 rax, QWORD PTR [r15+1360]

; 460  :             state->lencode = (code const FAR *)(state->next);
; 461  :             state->lenbits = 9;

  007b9	41 c7 47 70 09
	00 00 00	 mov	 DWORD PTR [r15+112], 9

; 462  :             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),

  007c1	4d 8d 87 10 03
	00 00		 lea	 r8, QWORD PTR [r15+784]
  007c8	49 89 87 88 00
	00 00		 mov	 QWORD PTR [r15+136], rax
  007cf	4c 89 44 24 28	 mov	 QWORD PTR [rsp+40], r8
  007d4	4d 8d 8f 88 00
	00 00		 lea	 r9, QWORD PTR [r15+136]
  007db	45 8b 47 7c	 mov	 r8d, DWORD PTR [r15+124]
  007df	49 8d 97 90 00
	00 00		 lea	 rdx, QWORD PTR [r15+144]
  007e6	49 89 47 60	 mov	 QWORD PTR [r15+96], rax
  007ea	b9 01 00 00 00	 mov	 ecx, 1
  007ef	49 8d 47 70	 lea	 rax, QWORD PTR [r15+112]
  007f3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  007f8	e8 00 00 00 00	 call	 inflate_table

; 463  :                                 &(state->lenbits), state->work);
; 464  :             if (ret) {

  007fd	85 c0		 test	 eax, eax
  007ff	74 0c		 je	 SHORT $LN300@inflateBac

; 465  :                 strm->msg = (char *)"invalid literal/lengths set";

  00801	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set@

; 466  :                 state->mode = BAD;
; 467  :                 break;

  00808	e9 a1 fc ff ff	 jmp	 $LN501@inflateBac
$LN300@inflateBac:

; 468  :             }
; 469  :             state->distcode = (code const FAR *)(state->next);
; 470  :             state->distbits = 6;
; 471  :             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,

  0080d	45 8b 87 80 00
	00 00		 mov	 r8d, DWORD PTR [r15+128]
  00814	49 8d 4f 74	 lea	 rcx, QWORD PTR [r15+116]
  00818	4d 8d 8f 88 00
	00 00		 lea	 r9, QWORD PTR [r15+136]
  0081f	c7 01 06 00 00
	00		 mov	 DWORD PTR [rcx], 6
  00825	49 8b 01	 mov	 rax, QWORD PTR [r9]
  00828	49 89 47 68	 mov	 QWORD PTR [r15+104], rax
  0082c	41 8b 47 7c	 mov	 eax, DWORD PTR [r15+124]
  00830	48 83 c0 48	 add	 rax, 72			; 00000048H
  00834	49 8d 14 47	 lea	 rdx, QWORD PTR [r15+rax*2]
  00838	49 8d 87 10 03
	00 00		 lea	 rax, QWORD PTR [r15+784]
  0083f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00844	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00849	b9 02 00 00 00	 mov	 ecx, 2
  0084e	e8 00 00 00 00	 call	 inflate_table

; 472  :                             &(state->next), &(state->distbits), state->work);
; 473  :             if (ret) {

  00853	4c 8b 55 28	 mov	 r10, QWORD PTR strm$[rbp-120]
  00857	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  0085b	85 c0		 test	 eax, eax
  0085d	74 18		 je	 SHORT $LN301@inflateBac

; 474  :                 strm->msg = (char *)"invalid distances set";

  0085f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@GMDFCBGP@invalid?5distances?5set@
  00866	49 89 42 20	 mov	 QWORD PTR [r10+32], rax

; 475  :                 state->mode = BAD;

  0086a	41 c7 47 08 51
	3f 00 00	 mov	 DWORD PTR [r15+8], 16209 ; 00003f51H

; 476  :                 break;

  00872	e9 ac 05 00 00	 jmp	 $LN485@inflateBac
$LN301@inflateBac:

; 477  :             }
; 478  :             Tracev((stderr, "inflate:       codes ok\n"));
; 479  :             state->mode = LEN;

  00877	41 c7 47 08 48
	3f 00 00	 mov	 DWORD PTR [r15+8], 16200 ; 00003f48H
  0087f	41 bb 01 00 00
	00		 mov	 r11d, 1
$LN302@inflateBac:

; 480  : 
; 481  :         case LEN:
; 482  :             /* use inflate_fast() if we have enough input and output */
; 483  :             if (have >= 6 && left >= 258) {

  00885	83 ff 06	 cmp	 edi, 6
  00888	0f 82 83 00 00
	00		 jb	 $LN303@inflateBac
  0088e	41 81 f9 02 01
	00 00		 cmp	 r9d, 258		; 00000102H
  00895	72 7a		 jb	 SHORT $LN303@inflateBac

; 484  :                 RESTORE();

  00897	48 8b 45 c0	 mov	 rax, QWORD PTR next$[rbp-120]
  0089b	49 89 02	 mov	 QWORD PTR [r10], rax
  0089e	49 89 5a 10	 mov	 QWORD PTR [r10+16], rbx
  008a2	45 89 4a 18	 mov	 DWORD PTR [r10+24], r9d
  008a6	41 89 7a 08	 mov	 DWORD PTR [r10+8], edi

; 485  :                 if (state->whave < state->wsize)

  008aa	41 8b 57 34	 mov	 edx, DWORD PTR [r15+52]
  008ae	45 89 77 48	 mov	 DWORD PTR [r15+72], r14d
  008b2	41 89 77 4c	 mov	 DWORD PTR [r15+76], esi
  008b6	41 39 57 38	 cmp	 DWORD PTR [r15+56], edx
  008ba	73 09		 jae	 SHORT $LN304@inflateBac

; 486  :                     state->whave = state->wsize - left;

  008bc	8b c2		 mov	 eax, edx
  008be	41 2b c1	 sub	 eax, r9d
  008c1	41 89 47 38	 mov	 DWORD PTR [r15+56], eax
$LN304@inflateBac:

; 487  :                 inflate_fast(strm, state->wsize);

  008c5	49 8b ca	 mov	 rcx, r10
  008c8	e8 00 00 00 00	 call	 inflate_fast

; 488  :                 LOAD();

  008cd	4c 8b 55 28	 mov	 r10, QWORD PTR strm$[rbp-120]
  008d1	49 8b 02	 mov	 rax, QWORD PTR [r10]
  008d4	49 8b 5a 10	 mov	 rbx, QWORD PTR [r10+16]
  008d8	45 8b 4a 18	 mov	 r9d, DWORD PTR [r10+24]
  008dc	41 8b 7a 08	 mov	 edi, DWORD PTR [r10+8]
  008e0	48 89 45 c0	 mov	 QWORD PTR next$[rbp-120], rax
  008e4	45 8b 77 48	 mov	 r14d, DWORD PTR [r15+72]
  008e8	41 8b 77 4c	 mov	 esi, DWORD PTR [r15+76]
  008ec	48 89 5d c8	 mov	 QWORD PTR put$1$[rbp-120], rbx
  008f0	44 89 4d b8	 mov	 DWORD PTR left$1$[rbp-120], r9d

; 489  :                 break;

  008f4	e9 2a 05 00 00	 jmp	 $LN485@inflateBac
$LN277@inflateBac:

; 369  :                 strm->msg = (char *)"too many length or distance symbols";

  008f9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5sym@
  00900	49 89 42 20	 mov	 QWORD PTR [r10+32], rax

; 370  :                 state->mode = BAD;

  00904	41 c7 47 08 51
	3f 00 00	 mov	 DWORD PTR [r15+8], 16209 ; 00003f51H

; 371  :                 break;

  0090c	e9 12 05 00 00	 jmp	 $LN485@inflateBac
$LN303@inflateBac:

; 490  :             }
; 491  : 
; 492  :             /* get a literal, length, or end-of-block code */
; 493  :             for (;;) {
; 494  :                 here = state->lencode[BITS(state->lenbits)];

  00911	41 8b 4f 70	 mov	 ecx, DWORD PTR [r15+112]
  00915	41 8b c3	 mov	 eax, r11d
  00918	4d 8b 57 60	 mov	 r10, QWORD PTR [r15+96]
  0091c	d3 e0		 shl	 eax, cl
  0091e	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  00921	41 8b c6	 mov	 eax, r14d
  00924	48 23 c8	 and	 rcx, rax
  00927	41 8b 04 8a	 mov	 eax, DWORD PTR [r10+rcx*4]
  0092b	8b c8		 mov	 ecx, eax
  0092d	c1 e9 08	 shr	 ecx, 8
  00930	0f b6 c9	 movzx	 ecx, cl

; 495  :                 if ((unsigned)(here.bits) <= bits) break;

  00933	3b ce		 cmp	 ecx, esi
  00935	76 5a		 jbe	 SHORT $LN382@inflateBac
$LL165@inflateBac:

; 496  :                 PULLBYTE();

  00937	85 ff		 test	 edi, edi
  00939	75 1a		 jne	 SHORT $LN171@inflateBac
  0093b	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  0093f	49 8b cd	 mov	 rcx, r13
  00942	41 ff d4	 call	 r12
  00945	8b f8		 mov	 edi, eax
  00947	85 c0		 test	 eax, eax
  00949	0f 84 f1 04 00
	00		 je	 $LN369@inflateBac
  0094f	41 bb 01 00 00
	00		 mov	 r11d, 1
$LN171@inflateBac:
  00955	48 8b 45 c0	 mov	 rax, QWORD PTR next$[rbp-120]
  00959	8b ce		 mov	 ecx, esi
  0095b	ff cf		 dec	 edi
  0095d	83 c6 08	 add	 esi, 8
  00960	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00963	48 ff 45 c0	 inc	 QWORD PTR next$[rbp-120]
  00967	4d 8b 57 60	 mov	 r10, QWORD PTR [r15+96]
  0096b	d3 e0		 shl	 eax, cl
  0096d	41 8b 4f 70	 mov	 ecx, DWORD PTR [r15+112]
  00971	44 03 f0	 add	 r14d, eax
  00974	41 8b c3	 mov	 eax, r11d
  00977	41 8b d6	 mov	 edx, r14d
  0097a	d3 e0		 shl	 eax, cl
  0097c	ff c8		 dec	 eax
  0097e	48 23 c2	 and	 rax, rdx
  00981	41 8b 04 82	 mov	 eax, DWORD PTR [r10+rax*4]
  00985	8b c8		 mov	 ecx, eax
  00987	c1 e9 08	 shr	 ecx, 8
  0098a	0f b6 c9	 movzx	 ecx, cl
  0098d	3b ce		 cmp	 ecx, esi
  0098f	77 a6		 ja	 SHORT $LL165@inflateBac
$LN382@inflateBac:

; 497  :             }
; 498  :             if (here.op && (here.op & 0xf0) == 0) {

  00991	84 c0		 test	 al, al
  00993	0f 84 d3 00 00
	00		 je	 $LN184@inflateBac
  00999	a8 f0		 test	 al, 240			; 000000f0H
  0099b	0f 85 cb 00 00
	00		 jne	 $LN184@inflateBac

; 499  :                 last = here;

  009a1	44 8b c8	 mov	 r9d, eax
  009a4	0f b6 c8	 movzx	 ecx, al
  009a7	41 c1 e9 08	 shr	 r9d, 8

; 500  :                 for (;;) {
; 501  :                     here = state->lencode[last.val +

  009ab	45 8b c3	 mov	 r8d, r11d
  009ae	41 0f b6 d1	 movzx	 edx, r9b
  009b2	8b d8		 mov	 ebx, eax
  009b4	03 ca		 add	 ecx, edx
  009b6	89 45 bc	 mov	 DWORD PTR last$[rbp-120], eax

; 502  :                             (BITS(last.bits + last.op) >> last.bits)];
; 503  :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  009b9	44 0f b6 65 bd	 movzx	 r12d, BYTE PTR last$[rbp-119]
  009be	41 d3 e0	 shl	 r8d, cl
  009c1	8b ca		 mov	 ecx, edx
  009c3	41 ff c8	 dec	 r8d
  009c6	c1 e8 10	 shr	 eax, 16
  009c9	45 23 c6	 and	 r8d, r14d
  009cc	41 d3 e8	 shr	 r8d, cl
  009cf	44 03 c0	 add	 r8d, eax
  009d2	43 8b 04 82	 mov	 eax, DWORD PTR [r10+r8*4]
  009d6	8b c8		 mov	 ecx, eax
  009d8	c1 e9 08	 shr	 ecx, 8
  009db	0f b6 d1	 movzx	 edx, cl
  009de	41 0f b6 c9	 movzx	 ecx, r9b
  009e2	03 d1		 add	 edx, ecx
  009e4	3b d6		 cmp	 edx, esi
  009e6	76 77		 jbe	 SHORT $LN185@inflateBac
  009e8	44 0f b7 6d be	 movzx	 r13d, WORD PTR last$[rbp-118]
  009ed	0f 1f 00	 npad	 3
$LL174@inflateBac:

; 504  :                     PULLBYTE();

  009f0	85 ff		 test	 edi, edi
  009f2	75 1b		 jne	 SHORT $LN180@inflateBac
  009f4	48 8b 4d 38	 mov	 rcx, QWORD PTR in_desc$[rbp-120]
  009f8	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  009fc	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  009ff	8b f8		 mov	 edi, eax
  00a01	85 c0		 test	 eax, eax
  00a03	0f 84 37 04 00
	00		 je	 $LN369@inflateBac
  00a09	41 bb 01 00 00
	00		 mov	 r11d, 1
$LN180@inflateBac:
  00a0f	48 8b 45 c0	 mov	 rax, QWORD PTR next$[rbp-120]
  00a13	8b ce		 mov	 ecx, esi
  00a15	45 0f b6 c4	 movzx	 r8d, r12b
  00a19	41 8b d3	 mov	 edx, r11d
  00a1c	ff cf		 dec	 edi
  00a1e	83 c6 08	 add	 esi, 8
  00a21	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00a24	48 ff 45 c0	 inc	 QWORD PTR next$[rbp-120]
  00a28	d3 e0		 shl	 eax, cl
  00a2a	44 03 f0	 add	 r14d, eax
  00a2d	0f b6 cb	 movzx	 ecx, bl
  00a30	41 03 c8	 add	 ecx, r8d
  00a33	41 0f b7 c5	 movzx	 eax, r13w
  00a37	d3 e2		 shl	 edx, cl
  00a39	41 8b c8	 mov	 ecx, r8d
  00a3c	ff ca		 dec	 edx
  00a3e	41 23 d6	 and	 edx, r14d
  00a41	d3 ea		 shr	 edx, cl
  00a43	03 d0		 add	 edx, eax
  00a45	49 8b 47 60	 mov	 rax, QWORD PTR [r15+96]
  00a49	8b 04 90	 mov	 eax, DWORD PTR [rax+rdx*4]
  00a4c	8b c8		 mov	 ecx, eax
  00a4e	c1 e9 08	 shr	 ecx, 8
  00a51	0f b6 d1	 movzx	 edx, cl
  00a54	41 03 d0	 add	 edx, r8d
  00a57	3b d6		 cmp	 edx, esi
  00a59	77 95		 ja	 SHORT $LL174@inflateBac
  00a5b	4c 8b 6d 38	 mov	 r13, QWORD PTR in_desc$[rbp-120]
$LN185@inflateBac:

; 505  :                 }
; 506  :                 DROPBITS(last.bits);

  00a5f	41 0f b6 cc	 movzx	 ecx, r12b
  00a63	4c 8b 65 30	 mov	 r12, QWORD PTR in$[rbp-120]
  00a67	41 d3 ee	 shr	 r14d, cl
  00a6a	2b f1		 sub	 esi, ecx
$LN184@inflateBac:

; 507  :             }
; 508  :             DROPBITS(here.bits);

  00a6c	8b c8		 mov	 ecx, eax
  00a6e	c1 e9 08	 shr	 ecx, 8
  00a71	0f b6 c9	 movzx	 ecx, cl
  00a74	41 d3 ee	 shr	 r14d, cl
  00a77	2b f1		 sub	 esi, ecx

; 509  :             state->length = (unsigned)here.val;

  00a79	8b c8		 mov	 ecx, eax
  00a7b	c1 e9 10	 shr	 ecx, 16
  00a7e	41 89 4f 50	 mov	 DWORD PTR [r15+80], ecx

; 510  : 
; 511  :             /* process literal */
; 512  :             if (here.op == 0) {

  00a82	84 c0		 test	 al, al
  00a84	75 52		 jne	 SHORT $LN312@inflateBac

; 513  :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 514  :                         "inflate:         literal '%c'\n" :
; 515  :                         "inflate:         literal 0x%02x\n", here.val));
; 516  :                 ROOM();

  00a86	44 8b 65 b8	 mov	 r12d, DWORD PTR left$1$[rbp-120]
  00a8a	45 85 e4	 test	 r12d, r12d
  00a8d	75 23		 jne	 SHORT $LN491@inflateBac
  00a8f	45 8b 67 34	 mov	 r12d, DWORD PTR [r15+52]
  00a93	45 8b c4	 mov	 r8d, r12d
  00a96	49 8b 5f 40	 mov	 rbx, QWORD PTR [r15+64]
  00a9a	48 8b 4d 48	 mov	 rcx, QWORD PTR out_desc$[rbp-120]
  00a9e	48 8b d3	 mov	 rdx, rbx
  00aa1	45 89 67 38	 mov	 DWORD PTR [r15+56], r12d
  00aa5	ff 55 40	 call	 QWORD PTR out$[rbp-120]
  00aa8	85 c0		 test	 eax, eax
  00aaa	0f 85 96 03 00
	00		 jne	 $LN372@inflateBac
  00ab0	eb 04		 jmp	 SHORT $LN189@inflateBac
$LN491@inflateBac:
  00ab2	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
$LN189@inflateBac:

; 517  :                 *put++ = (unsigned char)(state->length);

  00ab6	41 0f b6 47 50	 movzx	 eax, BYTE PTR [r15+80]
  00abb	88 03		 mov	 BYTE PTR [rbx], al
  00abd	48 ff c3	 inc	 rbx

; 518  :                 left--;

  00ac0	41 ff cc	 dec	 r12d
  00ac3	48 89 5d c8	 mov	 QWORD PTR put$1$[rbp-120], rbx
  00ac7	44 89 65 b8	 mov	 DWORD PTR left$1$[rbp-120], r12d

; 519  :                 state->mode = LEN;

  00acb	41 c7 47 08 48
	3f 00 00	 mov	 DWORD PTR [r15+8], 16200 ; 00003f48H

; 520  :                 break;

  00ad3	e9 44 03 00 00	 jmp	 $LN493@inflateBac
$LN312@inflateBac:

; 521  :             }
; 522  : 
; 523  :             /* process end of block */
; 524  :             if (here.op & 32) {

  00ad8	a8 20		 test	 al, 32			; 00000020H
  00ada	74 15		 je	 SHORT $LN315@inflateBac

; 525  :                 Tracevv((stderr, "inflate:         end of block\n"));
; 526  :                 state->mode = TYPE;
; 527  :                 break;

  00adc	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
  00ae0	41 c7 47 08 3f
	3f 00 00	 mov	 DWORD PTR [r15+8], 16191 ; 00003f3fH
$LN492@inflateBac:

; 284  :     hold = 0;
; 285  :     bits = 0;
; 286  :     put = state->window;
; 287  :     left = state->wsize;
; 288  : 
; 289  :     /* Inflate until end of block marked as last */
; 290  :     for (;;)
; 291  :         switch (state->mode) {

  00ae8	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  00aec	e9 2e 03 00 00	 jmp	 $LN495@inflateBac
$LN315@inflateBac:

; 528  :             }
; 529  : 
; 530  :             /* invalid code */
; 531  :             if (here.op & 64) {

  00af1	a8 40		 test	 al, 64			; 00000040H
  00af3	74 10		 je	 SHORT $LN316@inflateBac

; 532  :                 strm->msg = (char *)"invalid literal/length code";

  00af5	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
  00af9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code@
  00b00	e9 a9 f9 ff ff	 jmp	 $LN501@inflateBac
$LN316@inflateBac:

; 533  :                 state->mode = BAD;
; 534  :                 break;
; 535  :             }
; 536  : 
; 537  :             /* length code -- get extra bits, if any */
; 538  :             state->extra = (unsigned)(here.op) & 15;

  00b05	0f b6 c8	 movzx	 ecx, al
  00b08	83 e1 0f	 and	 ecx, 15
  00b0b	41 89 4f 58	 mov	 DWORD PTR [r15+88], ecx

; 539  :             if (state->extra != 0) {

  00b0f	74 62		 je	 SHORT $LN204@inflateBac

; 540  :                 NEEDBITS(state->extra);

  00b11	3b f1		 cmp	 esi, ecx
  00b13	73 4b		 jae	 SHORT $LN192@inflateBac
  00b15	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
  00b19	0f 1f 80 00 00
	00 00		 npad	 7
$LL195@inflateBac:
  00b20	85 ff		 test	 edi, edi
  00b22	75 18		 jne	 SHORT $LN200@inflateBac
  00b24	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00b28	49 8b cd	 mov	 rcx, r13
  00b2b	41 ff d4	 call	 r12
  00b2e	8b f8		 mov	 edi, eax
  00b30	85 c0		 test	 eax, eax
  00b32	0f 84 08 03 00
	00		 je	 $LN369@inflateBac
  00b38	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
$LN200@inflateBac:
  00b3c	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  00b3f	8b ce		 mov	 ecx, esi
  00b41	d3 e0		 shl	 eax, cl
  00b43	48 ff c2	 inc	 rdx
  00b46	44 03 f0	 add	 r14d, eax
  00b49	48 89 55 c0	 mov	 QWORD PTR next$[rbp-120], rdx
  00b4d	41 8b 4f 58	 mov	 ecx, DWORD PTR [r15+88]
  00b51	ff cf		 dec	 edi
  00b53	83 c6 08	 add	 esi, 8
  00b56	3b f1		 cmp	 esi, ecx
  00b58	72 c6		 jb	 SHORT $LL195@inflateBac
  00b5a	41 bb 01 00 00
	00		 mov	 r11d, 1
$LN192@inflateBac:

; 541  :                 state->length += BITS(state->extra);

  00b60	41 8b c3	 mov	 eax, r11d
  00b63	d3 e0		 shl	 eax, cl
  00b65	ff c8		 dec	 eax
  00b67	41 23 c6	 and	 eax, r14d

; 542  :                 DROPBITS(state->extra);

  00b6a	41 d3 ee	 shr	 r14d, cl
  00b6d	41 01 47 50	 add	 DWORD PTR [r15+80], eax
  00b71	2b f1		 sub	 esi, ecx
$LN204@inflateBac:

; 543  :             }
; 544  :             Tracevv((stderr, "inflate:         length %u\n", state->length));
; 545  : 
; 546  :             /* get distance code */
; 547  :             for (;;) {
; 548  :                 here = state->distcode[BITS(state->distbits)];

  00b73	41 8b 4f 74	 mov	 ecx, DWORD PTR [r15+116]
  00b77	bb 01 00 00 00	 mov	 ebx, 1
  00b7c	4d 8b 5f 68	 mov	 r11, QWORD PTR [r15+104]
  00b80	8b c3		 mov	 eax, ebx

; 549  :                 if ((unsigned)(here.bits) <= bits) break;

  00b82	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  00b86	d3 e0		 shl	 eax, cl
  00b88	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  00b8b	41 8b c6	 mov	 eax, r14d
  00b8e	48 23 c8	 and	 rcx, rax
  00b91	41 8b 04 8b	 mov	 eax, DWORD PTR [r11+rcx*4]
  00b95	8b c8		 mov	 ecx, eax
  00b97	c1 e9 08	 shr	 ecx, 8
  00b9a	0f b6 c9	 movzx	 ecx, cl
  00b9d	3b ce		 cmp	 ecx, esi
  00b9f	76 57		 jbe	 SHORT $LN387@inflateBac
$LL206@inflateBac:

; 550  :                 PULLBYTE();

  00ba1	85 ff		 test	 edi, edi
  00ba3	75 18		 jne	 SHORT $LN212@inflateBac
  00ba5	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00ba9	49 8b cd	 mov	 rcx, r13
  00bac	41 ff d4	 call	 r12
  00baf	8b f8		 mov	 edi, eax
  00bb1	85 c0		 test	 eax, eax
  00bb3	0f 84 87 02 00
	00		 je	 $LN369@inflateBac
  00bb9	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
$LN212@inflateBac:
  00bbd	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  00bc1	8b ce		 mov	 ecx, esi
  00bc3	d3 e0		 shl	 eax, cl
  00bc5	49 ff c2	 inc	 r10
  00bc8	44 03 f0	 add	 r14d, eax
  00bcb	4c 89 55 c0	 mov	 QWORD PTR next$[rbp-120], r10
  00bcf	41 8b 4f 74	 mov	 ecx, DWORD PTR [r15+116]
  00bd3	8b c3		 mov	 eax, ebx
  00bd5	4d 8b 5f 68	 mov	 r11, QWORD PTR [r15+104]
  00bd9	ff cf		 dec	 edi
  00bdb	d3 e0		 shl	 eax, cl
  00bdd	83 c6 08	 add	 esi, 8
  00be0	ff c8		 dec	 eax
  00be2	41 8b d6	 mov	 edx, r14d
  00be5	48 23 c2	 and	 rax, rdx
  00be8	41 8b 04 83	 mov	 eax, DWORD PTR [r11+rax*4]
  00bec	8b c8		 mov	 ecx, eax
  00bee	c1 e9 08	 shr	 ecx, 8
  00bf1	0f b6 c9	 movzx	 ecx, cl
  00bf4	3b ce		 cmp	 ecx, esi
  00bf6	77 a9		 ja	 SHORT $LL206@inflateBac
$LN387@inflateBac:

; 551  :             }
; 552  :             if ((here.op & 0xf0) == 0) {

  00bf8	a8 f0		 test	 al, 240			; 000000f0H
  00bfa	0f 85 c9 00 00
	00		 jne	 $LN225@inflateBac

; 553  :                 last = here;

  00c00	44 8b c8	 mov	 r9d, eax
  00c03	0f b6 c8	 movzx	 ecx, al
  00c06	41 c1 e9 08	 shr	 r9d, 8

; 554  :                 for (;;) {
; 555  :                     here = state->distcode[last.val +

  00c0a	41 b8 01 00 00
	00		 mov	 r8d, 1
  00c10	41 0f b6 d1	 movzx	 edx, r9b
  00c14	8b d8		 mov	 ebx, eax
  00c16	03 ca		 add	 ecx, edx
  00c18	89 45 bc	 mov	 DWORD PTR last$[rbp-120], eax

; 556  :                             (BITS(last.bits + last.op) >> last.bits)];
; 557  :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  00c1b	44 0f b6 6d bd	 movzx	 r13d, BYTE PTR last$[rbp-119]
  00c20	41 d3 e0	 shl	 r8d, cl
  00c23	8b ca		 mov	 ecx, edx
  00c25	41 ff c8	 dec	 r8d
  00c28	c1 e8 10	 shr	 eax, 16
  00c2b	45 23 c6	 and	 r8d, r14d
  00c2e	41 d3 e8	 shr	 r8d, cl
  00c31	44 03 c0	 add	 r8d, eax
  00c34	43 8b 04 83	 mov	 eax, DWORD PTR [r11+r8*4]
  00c38	8b c8		 mov	 ecx, eax
  00c3a	c1 e9 08	 shr	 ecx, 8
  00c3d	0f b6 d1	 movzx	 edx, cl
  00c40	41 0f b6 c9	 movzx	 ecx, r9b
  00c44	03 d1		 add	 edx, ecx
  00c46	3b d6		 cmp	 edx, esi
  00c48	76 71		 jbe	 SHORT $LN226@inflateBac
  00c4a	44 0f b7 65 be	 movzx	 r12d, WORD PTR last$[rbp-118]
  00c4f	90		 npad	 1
$LL215@inflateBac:

; 558  :                     PULLBYTE();

  00c50	85 ff		 test	 edi, edi
  00c52	75 19		 jne	 SHORT $LN221@inflateBac
  00c54	48 8b 4d 38	 mov	 rcx, QWORD PTR in_desc$[rbp-120]
  00c58	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00c5c	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  00c5f	8b f8		 mov	 edi, eax
  00c61	85 c0		 test	 eax, eax
  00c63	0f 84 d7 01 00
	00		 je	 $LN369@inflateBac
  00c69	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
$LN221@inflateBac:
  00c6d	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  00c71	8b ce		 mov	 ecx, esi
  00c73	d3 e0		 shl	 eax, cl
  00c75	ba 01 00 00 00	 mov	 edx, 1
  00c7a	44 03 f0	 add	 r14d, eax
  00c7d	45 0f b6 c5	 movzx	 r8d, r13b
  00c81	49 ff c2	 inc	 r10
  00c84	41 0f b7 c4	 movzx	 eax, r12w
  00c88	4c 89 55 c0	 mov	 QWORD PTR next$[rbp-120], r10
  00c8c	ff cf		 dec	 edi
  00c8e	0f b6 cb	 movzx	 ecx, bl
  00c91	83 c6 08	 add	 esi, 8
  00c94	41 03 c8	 add	 ecx, r8d
  00c97	d3 e2		 shl	 edx, cl
  00c99	41 8b c8	 mov	 ecx, r8d
  00c9c	ff ca		 dec	 edx
  00c9e	41 23 d6	 and	 edx, r14d
  00ca1	d3 ea		 shr	 edx, cl
  00ca3	03 d0		 add	 edx, eax
  00ca5	49 8b 47 68	 mov	 rax, QWORD PTR [r15+104]
  00ca9	8b 04 90	 mov	 eax, DWORD PTR [rax+rdx*4]
  00cac	8b c8		 mov	 ecx, eax
  00cae	c1 e9 08	 shr	 ecx, 8
  00cb1	0f b6 d1	 movzx	 edx, cl
  00cb4	41 03 d0	 add	 edx, r8d
  00cb7	3b d6		 cmp	 edx, esi
  00cb9	77 95		 ja	 SHORT $LL215@inflateBac
$LN226@inflateBac:

; 559  :                 }
; 560  :                 DROPBITS(last.bits);

  00cbb	41 0f b6 cd	 movzx	 ecx, r13b
  00cbf	bb 01 00 00 00	 mov	 ebx, 1
  00cc4	41 d3 ee	 shr	 r14d, cl
  00cc7	2b f1		 sub	 esi, ecx
$LN225@inflateBac:

; 561  :             }
; 562  :             DROPBITS(here.bits);

  00cc9	8b c8		 mov	 ecx, eax
  00ccb	c1 e9 08	 shr	 ecx, 8
  00cce	0f b6 c9	 movzx	 ecx, cl
  00cd1	41 d3 ee	 shr	 r14d, cl
  00cd4	2b f1		 sub	 esi, ecx

; 563  :             if (here.op & 64) {

  00cd6	a8 40		 test	 al, 64			; 00000040H
  00cd8	74 10		 je	 SHORT $LN327@inflateBac

; 564  :                 strm->msg = (char *)"invalid distance code";

  00cda	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
  00cde	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@LBKINIKP@invalid?5distance?5code@
  00ce5	e9 c4 f7 ff ff	 jmp	 $LN501@inflateBac
$LN327@inflateBac:

; 565  :                 state->mode = BAD;
; 566  :                 break;
; 567  :             }
; 568  :             state->offset = (unsigned)here.val;

  00cea	8b d0		 mov	 edx, eax

; 569  : 
; 570  :             /* get distance extra bits, if any */
; 571  :             state->extra = (unsigned)(here.op) & 15;

  00cec	0f b6 c8	 movzx	 ecx, al
  00cef	c1 ea 10	 shr	 edx, 16
  00cf2	83 e1 0f	 and	 ecx, 15
  00cf5	41 89 57 54	 mov	 DWORD PTR [r15+84], edx
  00cf9	41 89 4f 58	 mov	 DWORD PTR [r15+88], ecx

; 572  :             if (state->extra != 0) {

  00cfd	74 59		 je	 SHORT $LN242@inflateBac

; 573  :                 NEEDBITS(state->extra);

  00cff	3b f1		 cmp	 esi, ecx
  00d01	73 3f		 jae	 SHORT $LN230@inflateBac
  00d03	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
$LL233@inflateBac:
  00d07	85 ff		 test	 edi, edi
  00d09	75 19		 jne	 SHORT $LN238@inflateBac
  00d0b	48 8b 4d 38	 mov	 rcx, QWORD PTR in_desc$[rbp-120]
  00d0f	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00d13	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  00d16	8b f8		 mov	 edi, eax
  00d18	85 c0		 test	 eax, eax
  00d1a	0f 84 20 01 00
	00		 je	 $LN369@inflateBac
  00d20	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
$LN238@inflateBac:
  00d24	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  00d27	8b ce		 mov	 ecx, esi
  00d29	d3 e0		 shl	 eax, cl
  00d2b	48 ff c2	 inc	 rdx
  00d2e	44 03 f0	 add	 r14d, eax
  00d31	48 89 55 c0	 mov	 QWORD PTR next$[rbp-120], rdx
  00d35	41 8b 4f 58	 mov	 ecx, DWORD PTR [r15+88]
  00d39	ff cf		 dec	 edi
  00d3b	83 c6 08	 add	 esi, 8
  00d3e	3b f1		 cmp	 esi, ecx
  00d40	72 c5		 jb	 SHORT $LL233@inflateBac
$LN230@inflateBac:

; 574  :                 state->offset += BITS(state->extra);

  00d42	8b c3		 mov	 eax, ebx
  00d44	d3 e0		 shl	 eax, cl
  00d46	ff c8		 dec	 eax
  00d48	41 23 c6	 and	 eax, r14d

; 575  :                 DROPBITS(state->extra);

  00d4b	41 d3 ee	 shr	 r14d, cl
  00d4e	41 01 47 54	 add	 DWORD PTR [r15+84], eax
  00d52	41 8b 57 54	 mov	 edx, DWORD PTR [r15+84]
  00d56	2b f1		 sub	 esi, ecx
$LN242@inflateBac:

; 576  :             }
; 577  :             if (state->offset > state->wsize - (state->whave < state->wsize ?

  00d58	41 8b 4f 34	 mov	 ecx, DWORD PTR [r15+52]
  00d5c	33 c0		 xor	 eax, eax
  00d5e	41 39 4f 38	 cmp	 DWORD PTR [r15+56], ecx
  00d62	44 8b 65 b8	 mov	 r12d, DWORD PTR left$1$[rbp-120]
  00d66	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
  00d6a	41 0f 42 c4	 cmovb	 eax, r12d
  00d6e	2b c8		 sub	 ecx, eax
  00d70	3b d1		 cmp	 edx, ecx
  00d72	76 1f		 jbe	 SHORT $LL246@inflateBac

; 578  :                                                 left : 0)) {
; 579  :                 strm->msg = (char *)"invalid distance too far back";

  00d74	4c 8b 55 28	 mov	 r10, QWORD PTR strm$[rbp-120]
  00d78	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back@

; 580  :                 state->mode = BAD;
; 581  :                 break;

  00d7f	45 8b cc	 mov	 r9d, r12d
  00d82	49 89 42 20	 mov	 QWORD PTR [r10+32], rax
  00d86	41 c7 47 08 51
	3f 00 00	 mov	 DWORD PTR [r15+8], 16209 ; 00003f51H
  00d8e	e9 90 00 00 00	 jmp	 $LN485@inflateBac
$LL246@inflateBac:

; 582  :             }
; 583  :             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
; 584  : 
; 585  :             /* copy match from window to output */
; 586  :             do {
; 587  :                 ROOM();

  00d93	45 85 e4	 test	 r12d, r12d
  00d96	75 21		 jne	 SHORT $LN247@inflateBac
  00d98	45 8b 67 34	 mov	 r12d, DWORD PTR [r15+52]
  00d9c	45 8b c4	 mov	 r8d, r12d
  00d9f	49 8b 5f 40	 mov	 rbx, QWORD PTR [r15+64]
  00da3	48 8b 4d 48	 mov	 rcx, QWORD PTR out_desc$[rbp-120]
  00da7	48 8b d3	 mov	 rdx, rbx
  00daa	45 89 67 38	 mov	 DWORD PTR [r15+56], r12d
  00dae	ff 55 40	 call	 QWORD PTR out$[rbp-120]
  00db1	85 c0		 test	 eax, eax
  00db3	0f 85 8d 00 00
	00		 jne	 $LN372@inflateBac
$LN247@inflateBac:

; 588  :                 copy = state->wsize - state->offset;

  00db9	41 8b 4f 54	 mov	 ecx, DWORD PTR [r15+84]

; 589  :                 if (copy < left) {

  00dbd	45 8b c4	 mov	 r8d, r12d
  00dc0	41 8b 47 34	 mov	 eax, DWORD PTR [r15+52]
  00dc4	2b c1		 sub	 eax, ecx
  00dc6	41 3b c4	 cmp	 eax, r12d
  00dc9	73 0a		 jae	 SHORT $LN334@inflateBac

; 590  :                     from = put + copy;

  00dcb	8b d0		 mov	 edx, eax
  00dcd	48 03 d3	 add	 rdx, rbx

; 591  :                     copy = left - copy;

  00dd0	44 2b c0	 sub	 r8d, eax

; 592  :                 }

  00dd3	eb 06		 jmp	 SHORT $LN335@inflateBac
$LN334@inflateBac:

; 593  :                 else {
; 594  :                     from = put - state->offset;

  00dd5	48 8b d3	 mov	 rdx, rbx
  00dd8	48 2b d1	 sub	 rdx, rcx
$LN335@inflateBac:

; 595  :                     copy = left;
; 596  :                 }
; 597  :                 if (copy > state->length) copy = state->length;

  00ddb	41 8b 47 50	 mov	 eax, DWORD PTR [r15+80]

; 598  :                 state->length -= copy;

  00ddf	44 3b c0	 cmp	 r8d, eax
  00de2	8b c8		 mov	 ecx, eax
  00de4	41 0f 46 c8	 cmovbe	 ecx, r8d
  00de8	2b c1		 sub	 eax, ecx

; 599  :                 left -= copy;

  00dea	44 2b e1	 sub	 r12d, ecx
  00ded	41 89 47 50	 mov	 DWORD PTR [r15+80], eax
  00df1	48 2b d3	 sub	 rdx, rbx
  00df4	44 89 65 b8	 mov	 DWORD PTR left$1$[rbp-120], r12d
  00df8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL252@inflateBac:

; 600  :                 do {
; 601  :                     *put++ = *from++;

  00e00	0f b6 04 1a	 movzx	 eax, BYTE PTR [rdx+rbx]
  00e04	88 03		 mov	 BYTE PTR [rbx], al
  00e06	48 ff c3	 inc	 rbx

; 602  :                 } while (--copy);

  00e09	83 c1 ff	 add	 ecx, -1			; ffffffffH
  00e0c	75 f2		 jne	 SHORT $LL252@inflateBac

; 603  :             } while (state->length != 0);

  00e0e	48 89 5d c8	 mov	 QWORD PTR put$1$[rbp-120], rbx
  00e12	41 39 4f 50	 cmp	 DWORD PTR [r15+80], ecx
  00e16	0f 85 77 ff ff
	ff		 jne	 $LL246@inflateBac
$LN493@inflateBac:

; 284  :     hold = 0;
; 285  :     bits = 0;
; 286  :     put = state->window;
; 287  :     left = state->wsize;
; 288  : 
; 289  :     /* Inflate until end of block marked as last */
; 290  :     for (;;)
; 291  :         switch (state->mode) {

  00e1c	45 8b cc	 mov	 r9d, r12d
$LN495@inflateBac:
  00e1f	4c 8b 55 28	 mov	 r10, QWORD PTR strm$[rbp-120]
$LN485@inflateBac:
  00e23	41 8b 47 08	 mov	 eax, DWORD PTR [r15+8]
  00e27	2d 3f 3f 00 00	 sub	 eax, 16191		; 00003f3fH
  00e2c	83 f8 12	 cmp	 eax, 18
  00e2f	77 46		 ja	 SHORT $LN341@inflateBac
  00e31	4c 8b 6d 38	 mov	 r13, QWORD PTR in_desc$[rbp-120]
  00e35	33 d2		 xor	 edx, edx
  00e37	4c 8b 65 30	 mov	 r12, QWORD PTR in$[rbp-120]
  00e3b	e9 5c f2 ff ff	 jmp	 $LN498@inflateBac
$LN369@inflateBac:

; 621  :             goto inf_leave;
; 622  :         }
; 623  : 
; 624  :     /* Return unused input */
; 625  :   inf_leave:
; 626  :     strm->next_in = next;

  00e40	33 c0		 xor	 eax, eax
  00e42	48 89 45 c0	 mov	 QWORD PTR next$[rbp-120], rax
$LN372@inflateBac:
  00e46	41 bb fb ff ff
	ff		 mov	 r11d, -5
  00e4c	eb 2f		 jmp	 SHORT $inf_leave$504
$LN337@inflateBac:

; 604  :             break;
; 605  : 
; 606  :         case DONE:
; 607  :             /* inflate stream terminated properly -- write leftover output */
; 608  :             ret = Z_STREAM_END;
; 609  :             if (left < state->wsize) {

  00e4e	45 8b 47 34	 mov	 r8d, DWORD PTR [r15+52]
  00e52	45 3b c8	 cmp	 r9d, r8d
  00e55	73 26		 jae	 SHORT $inf_leave$504

; 610  :                 if (out(out_desc, state->window, state->wsize - left))

  00e57	49 8b 57 40	 mov	 rdx, QWORD PTR [r15+64]
  00e5b	45 2b c1	 sub	 r8d, r9d
  00e5e	48 8b 4d 48	 mov	 rcx, QWORD PTR out_desc$[rbp-120]
  00e62	ff 55 40	 call	 QWORD PTR out$[rbp-120]
  00e65	85 c0		 test	 eax, eax
  00e67	75 dd		 jne	 SHORT $LN372@inflateBac
  00e69	44 8d 58 01	 lea	 r11d, QWORD PTR [rax+1]
  00e6d	eb 0e		 jmp	 SHORT $inf_leave$504
$LN340@inflateBac:

; 611  :                     ret = Z_BUF_ERROR;
; 612  :             }
; 613  :             goto inf_leave;
; 614  : 
; 615  :         case BAD:
; 616  :             ret = Z_DATA_ERROR;

  00e6f	41 bb fd ff ff
	ff		 mov	 r11d, -3

; 617  :             goto inf_leave;

  00e75	eb 06		 jmp	 SHORT $inf_leave$504
$LN341@inflateBac:

; 618  : 
; 619  :         default:                /* can't happen, but makes compilers happy */
; 620  :             ret = Z_STREAM_ERROR;

  00e77	41 bb fe ff ff
	ff		 mov	 r11d, -2
$inf_leave$504:

; 621  :             goto inf_leave;
; 622  :         }
; 623  : 
; 624  :     /* Return unused input */
; 625  :   inf_leave:
; 626  :     strm->next_in = next;

  00e7d	48 8b 45 28	 mov	 rax, QWORD PTR strm$[rbp-120]
  00e81	48 8b 4d c0	 mov	 rcx, QWORD PTR next$[rbp-120]

; 627  :     strm->avail_in = have;
; 628  :     return ret;

  00e85	4c 8b 74 24 58	 mov	 r14, QWORD PTR [rsp+88]
  00e8a	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  00e8f	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  00e94	89 78 08	 mov	 DWORD PTR [rax+8], edi
  00e97	48 8b 7c 24 60	 mov	 rdi, QWORD PTR [rsp+96]
  00e9c	48 89 08	 mov	 QWORD PTR [rax], rcx
  00e9f	41 8b c3	 mov	 eax, r11d

; 629  : }

  00ea2	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00ea6	41 5f		 pop	 r15
  00ea8	41 5d		 pop	 r13
  00eaa	41 5c		 pop	 r12
  00eac	5d		 pop	 rbp
  00ead	c3		 ret	 0
$LN254@inflateBac:

; 274  :         return Z_STREAM_ERROR;

  00eae	b8 fe ff ff ff	 mov	 eax, -2

; 629  : }

  00eb3	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00eb7	41 5f		 pop	 r15
  00eb9	41 5d		 pop	 r13
  00ebb	41 5c		 pop	 r12
  00ebd	5d		 pop	 rbp
  00ebe	c3		 ret	 0
  00ebf	90		 npad	 1
$LN478@inflateBac:
  00ec0	00 00 00 00	 DD	 $LN255@inflateBac
  00ec4	00 00 00 00	 DD	 $LN341@inflateBac
  00ec8	00 00 00 00	 DD	 $LN31@inflateBac
  00ecc	00 00 00 00	 DD	 $LN341@inflateBac
  00ed0	00 00 00 00	 DD	 $LN341@inflateBac
  00ed4	00 00 00 00	 DD	 $LN56@inflateBac
  00ed8	00 00 00 00	 DD	 $LN341@inflateBac
  00edc	00 00 00 00	 DD	 $LN341@inflateBac
  00ee0	00 00 00 00	 DD	 $LN341@inflateBac
  00ee4	00 00 00 00	 DD	 $LN302@inflateBac
  00ee8	00 00 00 00	 DD	 $LN341@inflateBac
  00eec	00 00 00 00	 DD	 $LN341@inflateBac
  00ef0	00 00 00 00	 DD	 $LN341@inflateBac
  00ef4	00 00 00 00	 DD	 $LN341@inflateBac
  00ef8	00 00 00 00	 DD	 $LN341@inflateBac
  00efc	00 00 00 00	 DD	 $LN341@inflateBac
  00f00	00 00 00 00	 DD	 $LN341@inflateBac
  00f04	00 00 00 00	 DD	 $LN337@inflateBac
  00f08	00 00 00 00	 DD	 $LN340@inflateBac
inflateBack ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\daten\projekte\simulationplatform\third_party_libraries\zlib\zlib-1.2.11\infback.c
;	COMDAT inflateBackEnd
_TEXT	SEGMENT
strm$ = 48
inflateBackEnd PROC					; COMDAT

; 633  : {

$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 634  :     if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)

  00009	48 85 c9	 test	 rcx, rcx
  0000c	74 28		 je	 SHORT $LN3@inflateBac
  0000e	48 8b 51 28	 mov	 rdx, QWORD PTR [rcx+40]
  00012	48 85 d2	 test	 rdx, rdx
  00015	74 1f		 je	 SHORT $LN3@inflateBac
  00017	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
  0001b	48 85 c0	 test	 rax, rax
  0001e	74 16		 je	 SHORT $LN3@inflateBac

; 636  :     ZFREE(strm, strm->state);

  00020	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00024	ff d0		 call	 rax

; 637  :     strm->state = Z_NULL;
; 638  :     Tracev((stderr, "inflate: end\n"));
; 639  :     return Z_OK;

  00026	33 c0		 xor	 eax, eax
  00028	48 c7 43 28 00
	00 00 00	 mov	 QWORD PTR [rbx+40], 0

; 640  : }

  00030	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00034	5b		 pop	 rbx
  00035	c3		 ret	 0
$LN3@inflateBac:

; 635  :         return Z_STREAM_ERROR;

  00036	b8 fe ff ff ff	 mov	 eax, -2

; 640  : }

  0003b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003f	5b		 pop	 rbx
  00040	c3		 ret	 0
inflateBackEnd ENDP
_TEXT	ENDS
END
