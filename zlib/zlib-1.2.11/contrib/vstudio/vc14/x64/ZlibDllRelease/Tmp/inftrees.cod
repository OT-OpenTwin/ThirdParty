; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27041.0 

include listing.inc

INCLUDELIB OLDNAMES

	ORG $+10
?dext@?1??inflate_table@@9@9 DW 010H			; `inflate_table'::`2'::dext
	DW	010H
	DW	010H
	DW	010H
	DW	011H
	DW	011H
	DW	012H
	DW	012H
	DW	013H
	DW	013H
	DW	014H
	DW	014H
	DW	015H
	DW	015H
	DW	016H
	DW	016H
	DW	017H
	DW	017H
	DW	018H
	DW	018H
	DW	019H
	DW	019H
	DW	01aH
	DW	01aH
	DW	01bH
	DW	01bH
	DW	01cH
	DW	01cH
	DW	01dH
	DW	01dH
	DW	040H
	DW	040H
?lext@?1??inflate_table@@9@9 DW 010H			; `inflate_table'::`2'::lext
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	011H
	DW	011H
	DW	011H
	DW	011H
	DW	012H
	DW	012H
	DW	012H
	DW	012H
	DW	013H
	DW	013H
	DW	013H
	DW	013H
	DW	014H
	DW	014H
	DW	014H
	DW	014H
	DW	015H
	DW	015H
	DW	015H
	DW	015H
	DW	010H
	DW	04dH
	DW	0caH
	ORG $+2
?lbase@?1??inflate_table@@9@9 DW 03H			; `inflate_table'::`2'::lbase
	DW	04H
	DW	05H
	DW	06H
	DW	07H
	DW	08H
	DW	09H
	DW	0aH
	DW	0bH
	DW	0dH
	DW	0fH
	DW	011H
	DW	013H
	DW	017H
	DW	01bH
	DW	01fH
	DW	023H
	DW	02bH
	DW	033H
	DW	03bH
	DW	043H
	DW	053H
	DW	063H
	DW	073H
	DW	083H
	DW	0a3H
	DW	0c3H
	DW	0e3H
	DW	0102H
	DW	00H
	DW	00H
	ORG $+2
?dbase@?1??inflate_table@@9@9 DW 01H			; `inflate_table'::`2'::dbase
	DW	02H
	DW	03H
	DW	04H
	DW	05H
	DW	07H
	DW	09H
	DW	0dH
	DW	011H
	DW	019H
	DW	021H
	DW	031H
	DW	041H
	DW	061H
	DW	081H
	DW	0c1H
	DW	0101H
	DW	0181H
	DW	0201H
	DW	0301H
	DW	0401H
	DW	0601H
	DW	0801H
	DW	0c01H
	DW	01001H
	DW	01801H
	DW	02001H
	DW	03001H
	DW	04001H
	DW	06001H
	DW	00H
	DW	00H
PUBLIC	inflate_table
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflate_table DD imagerel $LN192
	DD	imagerel $LN192+298
	DD	imagerel $unwind$inflate_table
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$inflate_table DD imagerel $LN192+298
	DD	imagerel $LN192+403
	DD	imagerel $chain$0$inflate_table
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$inflate_table DD imagerel $LN192+403
	DD	imagerel $LN192+662
	DD	imagerel $chain$1$inflate_table
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$inflate_table DD imagerel $LN192+662
	DD	imagerel $LN192+687
	DD	imagerel $chain$2$inflate_table
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$inflate_table DD imagerel $LN192+687
	DD	imagerel $LN192+1220
	DD	imagerel $chain$4$inflate_table
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$inflate_table DD imagerel $LN192+1220
	DD	imagerel $LN192+1230
	DD	imagerel $chain$5$inflate_table
;	COMDAT xdata
xdata	SEGMENT
$chain$5$inflate_table DD 020021H
	DD	0106400H
	DD	imagerel $LN192
	DD	imagerel $LN192+298
	DD	imagerel $unwind$inflate_table
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$inflate_table DD 040021H
	DD	0ff400H
	DD	0106400H
	DD	imagerel $LN192
	DD	imagerel $LN192+298
	DD	imagerel $unwind$inflate_table
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$inflate_table DD 021H
	DD	imagerel $LN192+298
	DD	imagerel $LN192+403
	DD	imagerel $chain$0$inflate_table
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$inflate_table DD 020521H
	DD	0ff405H
	DD	imagerel $LN192+298
	DD	imagerel $LN192+403
	DD	imagerel $chain$0$inflate_table
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$inflate_table DD 020821H
	DD	0106408H
	DD	imagerel $LN192
	DD	imagerel $LN192+298
	DD	imagerel $unwind$inflate_table
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflate_table DD 082301H
	DD	0110123H
	DD	0d015e017H
	DD	07011c013H
	DD	0500f3010H
; Function compile flags: /Ogtpy
; File c:\daten\projekte\simulationplatform\third_party_libraries\zlib\zlib-1.2.11\inftrees.c
;	COMDAT inflate_table
_TEXT	SEGMENT
match$1$ = 0
drop$1$ = 4
sym$1$ = 8
tv1826 = 12
mask$1$ = 16
extra$1$ = 24
base$1$ = 32
count$ = 40
offs$ = 72
type$ = 192
lens$ = 200
here$ = 208
codes$ = 208
table$ = 216
bits$ = 224
work$ = 232
inflate_table PROC					; COMDAT

; 39   : {

$LN192:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	55		 push	 rbp
  0000f	53		 push	 rbx
  00010	57		 push	 rdi
  00011	41 54		 push	 r12
  00013	41 55		 push	 r13
  00015	41 56		 push	 r14
  00017	48 8d 6c 24 e1	 lea	 rbp, QWORD PTR [rsp-31]
  0001c	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 40   :     unsigned len;               /* a code's length in bits */
; 41   :     unsigned sym;               /* index of code symbols */
; 42   :     unsigned min, max;          /* minimum and maximum code lengths */
; 43   :     unsigned root;              /* number of index bits for root table */
; 44   :     unsigned curr;              /* number of index bits for current table */
; 45   :     unsigned drop;              /* code bits to drop for sub-table */
; 46   :     int left;                   /* number of prefix codes available */
; 47   :     unsigned used;              /* code entries in table used */
; 48   :     unsigned huff;              /* Huffman code */
; 49   :     unsigned incr;              /* for incrementing code, index */
; 50   :     unsigned fill;              /* index for replicating entries */
; 51   :     unsigned low;               /* low bits for current root entry */
; 52   :     unsigned mask;              /* mask for low root bits */
; 53   :     code here;                  /* table entry for duplication */
; 54   :     code FAR *next;             /* next available space in table */
; 55   :     const unsigned short FAR *base;     /* base value table to use */
; 56   :     const unsigned short FAR *extra;    /* extra bits table to use */
; 57   :     unsigned match;             /* use base and extra for symbol >= match */
; 58   :     unsigned short count[MAXBITS+1];    /* number of codes of each length */
; 59   :     unsigned short offs[MAXBITS+1];     /* offsets in table for each length */
; 60   :     static const unsigned short lbase[31] = { /* Length codes 257..285 base */
; 61   :         3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
; 62   :         35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
; 63   :     static const unsigned short lext[31] = { /* Length codes 257..285 extra */
; 64   :         16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
; 65   :         19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 77, 202};
; 66   :     static const unsigned short dbase[32] = { /* Distance codes 0..29 base */
; 67   :         1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
; 68   :         257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
; 69   :         8193, 12289, 16385, 24577, 0, 0};
; 70   :     static const unsigned short dext[32] = { /* Distance codes 0..29 extra */
; 71   :         16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
; 72   :         23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
; 73   :         28, 28, 29, 29, 64, 64};
; 74   : 
; 75   :     /*
; 76   :        Process a set of code lengths to create a canonical Huffman code.  The
; 77   :        code lengths are lens[0..codes-1].  Each length corresponds to the
; 78   :        symbols 0..codes-1.  The Huffman code is generated by first sorting the
; 79   :        symbols by length from short to long, and retaining the symbol order
; 80   :        for codes with equal lengths.  Then the code starts with all zero bits
; 81   :        for the first code of the shortest length, and the codes are integer
; 82   :        increments for the same length, and zeros are appended as the length
; 83   :        increases.  For the deflate format, these bits are stored backwards
; 84   :        from their more natural integer increment ordering, and so when the
; 85   :        decoding tables are built in the large loop below, the integer codes
; 86   :        are incremented backwards.
; 87   : 
; 88   :        This routine assumes, but does not check, that all of the entries in
; 89   :        lens[] are in the range 0..MAXBITS.  The caller must assure this.
; 90   :        1..MAXBITS is interpreted as that code length.  zero means that that
; 91   :        symbol does not occur in this code.
; 92   : 
; 93   :        The codes are sorted by computing a count of codes for each length,
; 94   :        creating from that a table of starting indices for each length in the
; 95   :        sorted table, and then entering the symbols in order in the sorted
; 96   :        table.  The sorted table is work[], with that space being provided by
; 97   :        the caller.
; 98   : 
; 99   :        The length counts are used for other purposes as well, i.e. finding
; 100  :        the minimum and maximum length codes, determining if there are any
; 101  :        codes at all, checking for a valid set of lengths, and looking ahead
; 102  :        at length counts to determine sub-table sizes when building the
; 103  :        decoding tables.
; 104  :      */
; 105  : 
; 106  :     /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
; 107  :     for (len = 0; len <= MAXBITS; len++)

  00023	45 33 ed	 xor	 r13d, r13d
  00026	45 8b d8	 mov	 r11d, r8d
  00029	41 0f b7 c5	 movzx	 eax, r13w
  0002d	8b d9		 mov	 ebx, ecx
  0002f	48 8d 7d bf	 lea	 rdi, QWORD PTR count$[rbp-105]
  00033	b9 10 00 00 00	 mov	 ecx, 16
  00038	4d 8b f1	 mov	 r14, r9
  0003b	4c 8b ca	 mov	 r9, rdx
  0003e	66 f3 ab	 rep stosw

; 108  :         count[len] = 0;
; 109  :     for (sym = 0; sym < codes; sym++)

  00041	45 85 c0	 test	 r8d, r8d
  00044	74 1c		 je	 SHORT $LN6@inflate_ta
  00046	48 8b fa	 mov	 rdi, rdx
  00049	45 8b c3	 mov	 r8d, r11d
  0004c	0f 1f 40 00	 npad	 4
$LL7@inflate_ta:

; 110  :         count[lens[sym]]++;

  00050	0f b7 07	 movzx	 eax, WORD PTR [rdi]
  00053	48 8d 7f 02	 lea	 rdi, QWORD PTR [rdi+2]
  00057	66 ff 44 45 bf	 inc	 WORD PTR count$[rbp+rax*2-105]
  0005c	49 83 e8 01	 sub	 r8, 1
  00060	75 ee		 jne	 SHORT $LL7@inflate_ta
$LN6@inflate_ta:

; 111  : 
; 112  :     /* bound code lengths, force root to be within code lengths */
; 113  :     root = *bits;

  00062	4c 8b 55 77	 mov	 r10, QWORD PTR bits$[rbp-105]
  00066	ba 0d 00 00 00	 mov	 edx, 13

; 114  :     for (max = MAXBITS; max >= 1; max--)

  0006b	41 b8 0f 00 00
	00		 mov	 r8d, 15
  00071	41 8b 3a	 mov	 edi, DWORD PTR [r10]
  00074	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL10@inflate_ta:

; 115  :         if (count[max] != 0) break;

  00080	41 8b c0	 mov	 eax, r8d
  00083	41 bc ff ff ff
	ff		 mov	 r12d, -1		; ffffffffH
  00089	66 44 39 6c 45
	bf		 cmp	 WORD PTR count$[rbp+rax*2-105], r13w
  0008f	75 4f		 jne	 SHORT $LN78@inflate_ta
  00091	8d 42 01	 lea	 eax, DWORD PTR [rdx+1]
  00094	66 44 39 6c 45
	bf		 cmp	 WORD PTR count$[rbp+rax*2-105], r13w
  0009a	75 41		 jne	 SHORT $LN130@inflate_ta
  0009c	8b c2		 mov	 eax, edx
  0009e	66 44 39 6c 45
	bf		 cmp	 WORD PTR count$[rbp+rax*2-105], r13w
  000a4	75 31		 jne	 SHORT $LN131@inflate_ta
  000a6	8d 42 ff	 lea	 eax, DWORD PTR [rdx-1]
  000a9	66 44 39 6c 45
	bf		 cmp	 WORD PTR count$[rbp+rax*2-105], r13w
  000af	75 20		 jne	 SHORT $LN132@inflate_ta
  000b1	8d 42 fe	 lea	 eax, DWORD PTR [rdx-2]
  000b4	66 44 39 6c 45
	bf		 cmp	 WORD PTR count$[rbp+rax*2-105], r13w
  000ba	75 0f		 jne	 SHORT $LN133@inflate_ta

; 114  :     for (max = MAXBITS; max >= 1; max--)

  000bc	41 83 c0 fb	 add	 r8d, -5			; fffffffbH
  000c0	83 c2 fb	 add	 edx, -5			; fffffffbH
  000c3	41 83 f8 01	 cmp	 r8d, 1
  000c7	73 b7		 jae	 SHORT $LL10@inflate_ta
  000c9	eb 15		 jmp	 SHORT $LN78@inflate_ta
$LN133@inflate_ta:

; 115  :         if (count[max] != 0) break;

  000cb	41 83 c0 fc	 add	 r8d, -4			; fffffffcH
  000cf	eb 0f		 jmp	 SHORT $LN78@inflate_ta
$LN132@inflate_ta:
  000d1	41 83 c0 fd	 add	 r8d, -3			; fffffffdH
  000d5	eb 09		 jmp	 SHORT $LN78@inflate_ta
$LN131@inflate_ta:
  000d7	41 83 c0 fe	 add	 r8d, -2			; fffffffeH
  000db	eb 03		 jmp	 SHORT $LN78@inflate_ta
$LN130@inflate_ta:
  000dd	45 03 c4	 add	 r8d, r12d
$LN78@inflate_ta:

; 116  :     if (root > max) root = max;
; 117  :     if (max == 0) {                     /* no symbols to code at all */

  000e0	41 3b f8	 cmp	 edi, r8d
  000e3	41 8b c8	 mov	 ecx, r8d
  000e6	0f 46 cf	 cmovbe	 ecx, edi
  000e9	45 85 c0	 test	 r8d, r8d
  000ec	75 36		 jne	 SHORT $LN37@inflate_ta

; 118  :         here.op = (unsigned char)64;    /* invalid code marker */
; 119  :         here.bits = (unsigned char)1;
; 120  :         here.val = (unsigned short)0;
; 121  :         *(*table)++ = here;             /* make a table to force an error */

  000ee	49 8b 0e	 mov	 rcx, QWORD PTR [r14]
  000f1	c7 45 67 40 01
	00 00		 mov	 DWORD PTR here$[rbp-105], 320 ; 00000140H
  000f8	8b 45 67	 mov	 eax, DWORD PTR here$[rbp-105]
  000fb	89 01		 mov	 DWORD PTR [rcx], eax
  000fd	49 83 06 04	 add	 QWORD PTR [r14], 4
  00101	49 8b 0e	 mov	 rcx, QWORD PTR [r14]
  00104	89 01		 mov	 DWORD PTR [rcx], eax
  00106	49 83 06 04	 add	 QWORD PTR [r14], 4

; 122  :         *(*table)++ = here;
; 123  :         *bits = 1;
; 124  :         return 0;     /* no symbols, but wait for decoding to report error */

  0010a	33 c0		 xor	 eax, eax
  0010c	41 c7 02 01 00
	00 00		 mov	 DWORD PTR [r10], 1

; 304  : }

  00113	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  0011a	41 5e		 pop	 r14
  0011c	41 5d		 pop	 r13
  0011e	41 5c		 pop	 r12
  00120	5f		 pop	 rdi
  00121	5b		 pop	 rbx
  00122	5d		 pop	 rbp
  00123	c3		 ret	 0
$LN37@inflate_ta:

; 125  :     }
; 126  :     for (min = 1; min < max; min++)

  00124	41 ba 01 00 00
	00		 mov	 r10d, 1
  0012a	48 89 b4 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rsi
  00132	45 3b c2	 cmp	 r8d, r10d
  00135	76 1b		 jbe	 SHORT $LN178@inflate_ta

; 147  :         if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;

  00137	48 8d 45 c1	 lea	 rax, QWORD PTR count$[rbp-103]
  0013b	0f 1f 44 00 00	 npad	 5
$LL13@inflate_ta:

; 127  :         if (count[min] != 0) break;

  00140	66 44 39 28	 cmp	 WORD PTR [rax], r13w
  00144	75 0c		 jne	 SHORT $LN178@inflate_ta

; 125  :     }
; 126  :     for (min = 1; min < max; min++)

  00146	41 ff c2	 inc	 r10d
  00149	48 83 c0 02	 add	 rax, 2
  0014d	45 3b d0	 cmp	 r10d, r8d
  00150	72 ee		 jb	 SHORT $LL13@inflate_ta
$LN178@inflate_ta:

; 128  :     if (root < min) root = min;
; 129  : 
; 130  :     /* check for an over-subscribed or incomplete set of lengths */
; 131  :     left = 1;

  00152	41 3b ca	 cmp	 ecx, r10d
  00155	41 8b f2	 mov	 esi, r10d
  00158	bf 01 00 00 00	 mov	 edi, 1
  0015d	0f 43 f1	 cmovae	 esi, ecx

; 132  :     for (len = 1; len <= MAXBITS; len++) {

  00160	8b d7		 mov	 edx, edi
  00162	89 75 a3	 mov	 DWORD PTR tv1826[rbp-105], esi
$LL16@inflate_ta:

; 133  :         left <<= 1;
; 134  :         left -= count[len];

  00165	8b c2		 mov	 eax, edx
  00167	03 ff		 add	 edi, edi
  00169	0f b7 4c 45 bf	 movzx	 ecx, WORD PTR count$[rbp+rax*2-105]
  0016e	2b f9		 sub	 edi, ecx

; 135  :         if (left < 0) return -1;        /* over-subscribed */

  00170	0f 88 4e 03 00
	00		 js	 $LN42@inflate_ta

; 132  :     for (len = 1; len <= MAXBITS; len++) {

  00176	ff c2		 inc	 edx
  00178	83 fa 0f	 cmp	 edx, 15
  0017b	76 e8		 jbe	 SHORT $LL16@inflate_ta

; 136  :     }
; 137  :     if (left > 0 && (type == CODES || max != 1))

  0017d	85 ff		 test	 edi, edi
  0017f	7e 12		 jle	 SHORT $LN41@inflate_ta
  00181	85 db		 test	 ebx, ebx
  00183	0f 84 3b 03 00
	00		 je	 $LN42@inflate_ta
  00189	41 83 f8 01	 cmp	 r8d, 1
  0018d	0f 85 31 03 00
	00		 jne	 $LN42@inflate_ta
$LN41@inflate_ta:
  00193	4c 89 7c 24 78	 mov	 QWORD PTR [rsp+120], r15

; 139  : 
; 140  :     /* generate offsets into symbol table for each length for sorting */
; 141  :     offs[1] = 0;

  00198	49 8b cd	 mov	 rcx, r13
  0019b	66 44 89 6d e1	 mov	 WORD PTR offs$[rbp-103], r13w
  001a0	ba 0e 00 00 00	 mov	 edx, 14
  001a5	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL19@inflate_ta:

; 142  :     for (len = 1; len < MAXBITS; len++)
; 143  :         offs[len + 1] = offs[len] + count[len];

  001b0	0f b7 44 0d c1	 movzx	 eax, WORD PTR count$[rbp+rcx-103]
  001b5	66 03 44 0d e1	 add	 ax, WORD PTR offs$[rbp+rcx-103]
  001ba	66 89 44 0d e3	 mov	 WORD PTR offs$[rbp+rcx-101], ax
  001bf	48 8d 49 02	 lea	 rcx, QWORD PTR [rcx+2]
  001c3	48 83 ea 01	 sub	 rdx, 1
  001c7	75 e7		 jne	 SHORT $LL19@inflate_ta

; 144  : 
; 145  :     /* sort symbols by length, by symbol order within each length */
; 146  :     for (sym = 0; sym < codes; sym++)

  001c9	41 8b fd	 mov	 edi, r13d
  001cc	45 85 db	 test	 r11d, r11d
  001cf	74 2f		 je	 SHORT $LN21@inflate_ta
  001d1	49 8b d1	 mov	 rdx, r9
  001d4	4c 8b 4d 7f	 mov	 r9, QWORD PTR work$[rbp-105]
$LL22@inflate_ta:

; 147  :         if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;

  001d8	0f b7 02	 movzx	 eax, WORD PTR [rdx]
  001db	66 85 c0	 test	 ax, ax
  001de	74 15		 je	 SHORT $LN20@inflate_ta
  001e0	0f b7 c0	 movzx	 eax, ax
  001e3	0f b7 4c 45 df	 movzx	 ecx, WORD PTR offs$[rbp+rax*2-105]
  001e8	66 41 89 3c 49	 mov	 WORD PTR [r9+rcx*2], di
  001ed	0f b7 02	 movzx	 eax, WORD PTR [rdx]
  001f0	66 ff 44 45 df	 inc	 WORD PTR offs$[rbp+rax*2-105]
$LN20@inflate_ta:

; 144  : 
; 145  :     /* sort symbols by length, by symbol order within each length */
; 146  :     for (sym = 0; sym < codes; sym++)

  001f5	ff c7		 inc	 edi
  001f7	48 83 c2 02	 add	 rdx, 2
  001fb	41 3b fb	 cmp	 edi, r11d
  001fe	72 d8		 jb	 SHORT $LL22@inflate_ta
$LN21@inflate_ta:

; 148  : 
; 149  :     /*
; 150  :        Create and fill in decoding tables.  In this loop, the table being
; 151  :        filled is at next and has curr index bits.  The code being used is huff
; 152  :        with length len.  That code is converted to an index by dropping drop
; 153  :        bits off of the bottom.  For codes where len is less than drop + curr,
; 154  :        those top drop + curr - len bits are incremented through all values to
; 155  :        fill the table with replicated entries.
; 156  : 
; 157  :        root is the number of index bits for the root table.  When len exceeds
; 158  :        root, sub-tables are created pointed to by the root entry with an index
; 159  :        of the low root bits of huff.  This is saved in low to check for when a
; 160  :        new sub-table should be started.  drop is zero when the root table is
; 161  :        being filled, and drop is root when sub-tables are being filled.
; 162  : 
; 163  :        When a new sub-table is needed, it is necessary to look ahead in the
; 164  :        code lengths to determine what size sub-table is needed.  The length
; 165  :        counts are used for this, and so count[] is decremented as codes are
; 166  :        entered in the tables.
; 167  : 
; 168  :        used keeps track of how many table entries have been allocated from the
; 169  :        provided *table space.  It is checked for LENS and DIST tables against
; 170  :        the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
; 171  :        the initial root table size constants.  See the comments in inftrees.h
; 172  :        for more information.
; 173  : 
; 174  :        sym increments through all symbols, and the loop terminates when
; 175  :        all codes of length max, i.e. all codes, have been processed.  This
; 176  :        routine permits incomplete codes, so another loop after this one fills
; 177  :        in the rest of the decoding tables with invalid code markers.
; 178  :      */
; 179  : 
; 180  :     /* set up for code type */
; 181  :     switch (type) {

  00200	48 8b 7d 7f	 mov	 rdi, QWORD PTR work$[rbp-105]
  00204	85 db		 test	 ebx, ebx
  00206	74 3d		 je	 SHORT $LN44@inflate_ta
  00208	83 fb 01	 cmp	 ebx, 1
  0020b	74 1b		 je	 SHORT $LN45@inflate_ta

; 191  :     default:    /* DISTS */
; 192  :         base = dbase;

  0020d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?dbase@?1??inflate_table@@9@9

; 193  :         extra = dext;
; 194  :         match = 0;

  00214	41 8b d5	 mov	 edx, r13d
  00217	48 89 45 b7	 mov	 QWORD PTR base$1$[rbp-105], rax
  0021b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?dext@?1??inflate_table@@9@9
  00222	48 89 45 af	 mov	 QWORD PTR extra$1$[rbp-105], rax
  00226	eb 2a		 jmp	 SHORT $LN188@inflate_ta
$LN45@inflate_ta:

; 185  :         break;
; 186  :     case LENS:
; 187  :         base = lbase;

  00228	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?lbase@?1??inflate_table@@9@9

; 188  :         extra = lext;
; 189  :         match = 257;

  0022f	ba 01 01 00 00	 mov	 edx, 257		; 00000101H
  00234	48 89 45 b7	 mov	 QWORD PTR base$1$[rbp-105], rax
  00238	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?lext@?1??inflate_table@@9@9
  0023f	48 89 45 af	 mov	 QWORD PTR extra$1$[rbp-105], rax

; 190  :         break;

  00243	eb 0d		 jmp	 SHORT $LN188@inflate_ta
$LN44@inflate_ta:

; 182  :     case CODES:
; 183  :         base = extra = work;    /* dummy value--not used */

  00245	48 89 7d af	 mov	 QWORD PTR extra$1$[rbp-105], rdi

; 184  :         match = 20;

  00249	ba 14 00 00 00	 mov	 edx, 20
  0024e	48 89 7d b7	 mov	 QWORD PTR base$1$[rbp-105], rdi
$LN188@inflate_ta:

; 195  :     }
; 196  : 
; 197  :     /* initialize state for loop */
; 198  :     huff = 0;                   /* starting code */
; 199  :     sym = 0;                    /* starting code symbol */
; 200  :     len = min;                  /* starting code length */
; 201  :     next = *table;              /* current table to fill in */

  00252	4d 8b 3e	 mov	 r15, QWORD PTR [r14]

; 202  :     curr = root;                /* current table index bits */
; 203  :     drop = 0;                   /* current bits to drop from code for index */
; 204  :     low = (unsigned)(-1);       /* trigger new sub-table when len > root */
; 205  :     used = 1U << root;          /* use root table entries */

  00255	8b ce		 mov	 ecx, esi

; 206  :     mask = used - 1;            /* mask for comparing low */
; 207  : 
; 208  :     /* check available table space */
; 209  :     if ((type == LENS && used > ENOUGH_LENS) ||

  00257	44 8b 75 57	 mov	 r14d, DWORD PTR type$[rbp-105]
  0025b	41 8b dd	 mov	 ebx, r13d
  0025e	be 01 00 00 00	 mov	 esi, 1
  00263	44 89 6d 9f	 mov	 DWORD PTR sym$1$[rbp-105], r13d
  00267	d3 e6		 shl	 esi, cl
  00269	45 8b dd	 mov	 r11d, r13d
  0026c	89 55 97	 mov	 DWORD PTR match$1$[rbp-105], edx
  0026f	45 8b cd	 mov	 r9d, r13d
  00272	89 5d 9b	 mov	 DWORD PTR drop$1$[rbp-105], ebx
  00275	44 8b ee	 mov	 r13d, esi
  00278	8d 46 ff	 lea	 eax, DWORD PTR [rsi-1]
  0027b	89 45 a7	 mov	 DWORD PTR mask$1$[rbp-105], eax
  0027e	41 83 fe 01	 cmp	 r14d, 1
  00282	75 2b		 jne	 SHORT $LN49@inflate_ta
  00284	81 fe 54 03 00
	00		 cmp	 esi, 852		; 00000354H
  0028a	76 44		 jbe	 SHORT $LL25@inflate_ta
$LN62@inflate_ta:

; 279  :                 (type == DISTS && used > ENOUGH_DISTS))
; 280  :                 return 1;

  0028c	b8 01 00 00 00	 mov	 eax, 1
$LN187@inflate_ta:
  00291	4c 8b 7c 24 78	 mov	 r15, QWORD PTR [rsp+120]
$LN186@inflate_ta:
  00296	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR [rsp+128]

; 304  : }

  0029e	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  002a5	41 5e		 pop	 r14
  002a7	41 5d		 pop	 r13
  002a9	41 5c		 pop	 r12
  002ab	5f		 pop	 rdi
  002ac	5b		 pop	 rbx
  002ad	5d		 pop	 rbp
  002ae	c3		 ret	 0
$LN49@inflate_ta:

; 206  :     mask = used - 1;            /* mask for comparing low */
; 207  : 
; 208  :     /* check available table space */
; 209  :     if ((type == LENS && used > ENOUGH_LENS) ||

  002af	41 83 fe 02	 cmp	 r14d, 2
  002b3	75 1b		 jne	 SHORT $LL25@inflate_ta
  002b5	81 fe 50 02 00
	00		 cmp	 esi, 592		; 00000250H
  002bb	77 cf		 ja	 SHORT $LN62@inflate_ta

; 255  :         }
; 256  : 
; 257  :         /* create new sub-table if needed */
; 258  :         if (len > root && (huff & mask) != low) {

  002bd	eb 11		 jmp	 SHORT $LL25@inflate_ta
  002bf	90		 npad	 1
$LL181@inflate_ta:

; 210  :         (type == DISTS && used > ENOUGH_DISTS))
; 211  :         return 1;
; 212  : 
; 213  :     /* process all codes and make table entries */
; 214  :     for (;;) {
; 215  :         /* create table entry */
; 216  :         here.bits = (unsigned char)(len - drop);

  002c0	8b 5d 9b	 mov	 ebx, DWORD PTR drop$1$[rbp-105]
  002c3	0f 1f 40 00 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL25@inflate_ta:
  002d0	41 0f b6 c2	 movzx	 eax, r10b
  002d4	2a c3		 sub	 al, bl
  002d6	88 45 68	 mov	 BYTE PTR here$[rbp-104], al

; 217  :         if (work[sym] + 1U < match) {

  002d9	41 8b c1	 mov	 eax, r9d
  002dc	0f b7 0c 47	 movzx	 ecx, WORD PTR [rdi+rax*2]
  002e0	8d 41 01	 lea	 eax, DWORD PTR [rcx+1]
  002e3	3b c2		 cmp	 eax, edx
  002e5	73 0a		 jae	 SHORT $LN50@inflate_ta

; 218  :             here.op = (unsigned char)0;

  002e7	c6 45 67 00	 mov	 BYTE PTR here$[rbp-105], 0

; 219  :             here.val = work[sym];

  002eb	66 89 4d 69	 mov	 WORD PTR here$[rbp-103], cx

; 220  :         }

  002ef	eb 28		 jmp	 SHORT $LN53@inflate_ta
$LN50@inflate_ta:

; 221  :         else if (work[sym] >= match) {

  002f1	3b ca		 cmp	 ecx, edx
  002f3	72 1a		 jb	 SHORT $LN52@inflate_ta

; 222  :             here.op = (unsigned char)(extra[work[sym] - match]);

  002f5	48 8b 45 af	 mov	 rax, QWORD PTR extra$1$[rbp-105]
  002f9	2b ca		 sub	 ecx, edx
  002fb	48 03 c9	 add	 rcx, rcx
  002fe	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00302	88 45 67	 mov	 BYTE PTR here$[rbp-105], al

; 223  :             here.val = base[work[sym] - match];

  00305	48 8b 45 b7	 mov	 rax, QWORD PTR base$1$[rbp-105]
  00309	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]

; 224  :         }

  0030d	eb 06		 jmp	 SHORT $LN189@inflate_ta
$LN52@inflate_ta:

; 225  :         else {
; 226  :             here.op = (unsigned char)(32 + 64);         /* end of block */

  0030f	c6 45 67 60	 mov	 BYTE PTR here$[rbp-105], 96 ; 00000060H

; 227  :             here.val = 0;

  00313	33 c0		 xor	 eax, eax
$LN189@inflate_ta:

; 228  :         }
; 229  : 
; 230  :         /* replicate for those indices with low len bits equal to huff */
; 231  :         incr = 1U << (len - drop);

  00315	66 89 45 69	 mov	 WORD PTR here$[rbp-103], ax
$LN53@inflate_ta:
  00319	8b 45 67	 mov	 eax, DWORD PTR here$[rbp-105]
  0031c	41 8b ca	 mov	 ecx, r10d
  0031f	2b cb		 sub	 ecx, ebx

; 232  :         fill = 1U << curr;

  00321	8b fe		 mov	 edi, esi
  00323	41 b9 01 00 00
	00		 mov	 r9d, 1
  00329	41 8b d3	 mov	 edx, r11d
  0032c	41 d3 e1	 shl	 r9d, cl
  0032f	8b cb		 mov	 ecx, ebx
  00331	d3 ea		 shr	 edx, cl
  00333	03 d6		 add	 edx, esi
  00335	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL30@inflate_ta:

; 233  :         min = fill;                 /* save offset to next table */
; 234  :         do {
; 235  :             fill -= incr;

  00340	41 2b d1	 sub	 edx, r9d

; 236  :             next[(huff >> drop) + fill] = here;

  00343	41 89 04 97	 mov	 DWORD PTR [r15+rdx*4], eax
  00347	41 2b f9	 sub	 edi, r9d

; 237  :         } while (fill != 0);

  0034a	75 f4		 jne	 SHORT $LL30@inflate_ta

; 238  : 
; 239  :         /* backwards increment the len-bit code huff */
; 240  :         incr = 1U << (len - 1);

  0034c	41 8d 4a ff	 lea	 ecx, DWORD PTR [r10-1]
  00350	ba 01 00 00 00	 mov	 edx, 1
  00355	d3 e2		 shl	 edx, cl

; 241  :         while (huff & incr)

  00357	41 85 d3	 test	 edx, r11d
  0035a	74 0b		 je	 SHORT $LN32@inflate_ta
  0035c	0f 1f 40 00	 npad	 4
$LL31@inflate_ta:

; 242  :             incr >>= 1;

  00360	d1 ea		 shr	 edx, 1
  00362	41 85 d3	 test	 edx, r11d
  00365	75 f9		 jne	 SHORT $LL31@inflate_ta
$LN32@inflate_ta:

; 243  :         if (incr != 0) {

  00367	85 d2		 test	 edx, edx
  00369	74 0d		 je	 SHORT $LN54@inflate_ta

; 244  :             huff &= incr - 1;

  0036b	8d 42 ff	 lea	 eax, DWORD PTR [rdx-1]
  0036e	44 23 d8	 and	 r11d, eax

; 245  :             huff += incr;

  00371	44 03 da	 add	 r11d, edx

; 246  :         }

  00374	33 c9		 xor	 ecx, ecx
  00376	eb 05		 jmp	 SHORT $LN55@inflate_ta
$LN54@inflate_ta:

; 247  :         else
; 248  :             huff = 0;

  00378	33 c9		 xor	 ecx, ecx
  0037a	44 8b d9	 mov	 r11d, ecx
$LN55@inflate_ta:

; 249  : 
; 250  :         /* go to next symbol, update count, len */
; 251  :         sym++;

  0037d	44 8b 4d 9f	 mov	 r9d, DWORD PTR sym$1$[rbp-105]

; 252  :         if (--(count[len]) == 0) {

  00381	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  00386	41 ff c1	 inc	 r9d
  00389	41 8b c2	 mov	 eax, r10d
  0038c	44 89 4d 9f	 mov	 DWORD PTR sym$1$[rbp-105], r9d
  00390	66 01 54 45 bf	 add	 WORD PTR count$[rbp+rax*2-105], dx
  00395	75 1d		 jne	 SHORT $LN180@inflate_ta

; 253  :             if (len == max) break;

  00397	45 3b d0	 cmp	 r10d, r8d
  0039a	0f 84 ef 00 00
	00		 je	 $LN82@inflate_ta

; 254  :             len = lens[work[sym]];

  003a0	48 8b 7d 7f	 mov	 rdi, QWORD PTR work$[rbp-105]
  003a4	48 8b 45 5f	 mov	 rax, QWORD PTR lens$[rbp-105]
  003a8	42 0f b7 0c 4f	 movzx	 ecx, WORD PTR [rdi+r9*2]
  003ad	44 0f b7 14 48	 movzx	 r10d, WORD PTR [rax+rcx*2]
  003b2	eb 04		 jmp	 SHORT $LN56@inflate_ta
$LN180@inflate_ta:

; 252  :         if (--(count[len]) == 0) {

  003b4	48 8b 7d 7f	 mov	 rdi, QWORD PTR work$[rbp-105]
$LN56@inflate_ta:

; 255  :         }
; 256  : 
; 257  :         /* create new sub-table if needed */
; 258  :         if (len > root && (huff & mask) != low) {

  003b8	8b 45 a3	 mov	 eax, DWORD PTR tv1826[rbp-105]
  003bb	8b 55 97	 mov	 edx, DWORD PTR match$1$[rbp-105]
  003be	44 3b d0	 cmp	 r10d, eax
  003c1	0f 86 09 ff ff
	ff		 jbe	 $LL25@inflate_ta
  003c7	8b 5d a7	 mov	 ebx, DWORD PTR mask$1$[rbp-105]
  003ca	41 23 db	 and	 ebx, r11d
  003cd	41 3b dc	 cmp	 ebx, r12d
  003d0	0f 84 ea fe ff
	ff		 je	 $LL181@inflate_ta

; 259  :             /* if first time, transition to sub-tables */
; 260  :             if (drop == 0)
; 261  :                 drop = root;
; 262  : 
; 263  :             /* increment past last table */
; 264  :             next += min;            /* here min is 1 << curr */

  003d6	8b 4d 9b	 mov	 ecx, DWORD PTR drop$1$[rbp-105]
  003d9	4d 8d 3c b7	 lea	 r15, QWORD PTR [r15+rsi*4]
  003dd	85 c9		 test	 ecx, ecx

; 265  : 
; 266  :             /* determine length of next table */
; 267  :             curr = len - drop;

  003df	45 8b ca	 mov	 r9d, r10d

; 268  :             left = (int)(1 << curr);

  003e2	ba 01 00 00 00	 mov	 edx, 1
  003e7	0f 45 c1	 cmovne	 eax, ecx
  003ea	44 2b c8	 sub	 r9d, eax
  003ed	89 45 9b	 mov	 DWORD PTR drop$1$[rbp-105], eax
  003f0	41 8b c9	 mov	 ecx, r9d
  003f3	d3 e2		 shl	 edx, cl

; 269  :             while (curr + drop < max) {

  003f5	45 3b d0	 cmp	 r10d, r8d
  003f8	73 1f		 jae	 SHORT $LN179@inflate_ta

; 259  :             /* if first time, transition to sub-tables */
; 260  :             if (drop == 0)
; 261  :                 drop = root;
; 262  : 
; 263  :             /* increment past last table */
; 264  :             next += min;            /* here min is 1 << curr */

  003fa	41 8b fa	 mov	 edi, r10d
  003fd	0f 1f 00	 npad	 3
$LL33@inflate_ta:

; 270  :                 left -= count[curr + drop];

  00400	8b c7		 mov	 eax, edi
  00402	0f b7 4c 45 bf	 movzx	 ecx, WORD PTR count$[rbp+rax*2-105]
  00407	2b d1		 sub	 edx, ecx

; 271  :                 if (left <= 0) break;

  00409	85 d2		 test	 edx, edx
  0040b	7e 0c		 jle	 SHORT $LN179@inflate_ta

; 272  :                 curr++;

  0040d	41 ff c1	 inc	 r9d
  00410	ff c7		 inc	 edi

; 273  :                 left <<= 1;

  00412	03 d2		 add	 edx, edx
  00414	41 3b f8	 cmp	 edi, r8d
  00417	72 e7		 jb	 SHORT $LL33@inflate_ta
$LN179@inflate_ta:

; 274  :             }
; 275  : 
; 276  :             /* check for enough space */
; 277  :             used += 1U << curr;
; 278  :             if ((type == LENS && used > ENOUGH_LENS) ||

  00419	44 8b 75 57	 mov	 r14d, DWORD PTR type$[rbp-105]
  0041d	41 8b c9	 mov	 ecx, r9d
  00420	be 01 00 00 00	 mov	 esi, 1
  00425	d3 e6		 shl	 esi, cl
  00427	44 03 ee	 add	 r13d, esi
  0042a	41 83 fe 01	 cmp	 r14d, 1
  0042e	75 09		 jne	 SHORT $LN63@inflate_ta
  00430	41 81 fd 54 03
	00 00		 cmp	 r13d, 852		; 00000354H
  00437	eb 0d		 jmp	 SHORT $LN190@inflate_ta
$LN63@inflate_ta:
  00439	41 83 fe 02	 cmp	 r14d, 2
  0043d	75 0d		 jne	 SHORT $LN61@inflate_ta
  0043f	41 81 fd 50 02
	00 00		 cmp	 r13d, 592		; 00000250H
$LN190@inflate_ta:

; 281  : 
; 282  :             /* point entry in root table to sub-table */
; 283  :             low = huff & mask;

  00446	0f 87 40 fe ff
	ff		 ja	 $LN62@inflate_ta
$LN61@inflate_ta:

; 284  :             (*table)[low].op = (unsigned char)curr;

  0044c	48 8b 4d 6f	 mov	 rcx, QWORD PTR table$[rbp-105]
  00450	48 8d 14 9d 00
	00 00 00	 lea	 rdx, QWORD PTR [rbx*4]

; 285  :             (*table)[low].bits = (unsigned char)root;

  00458	8b 7d a3	 mov	 edi, DWORD PTR tv1826[rbp-105]
  0045b	44 8b e3	 mov	 r12d, ebx
  0045e	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00461	44 88 0c 02	 mov	 BYTE PTR [rdx+rax], r9b
  00465	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 286  :             (*table)[low].val = (unsigned short)(next - *table);
; 287  :         }
; 288  :     }

  00468	44 8b 4d 9f	 mov	 r9d, DWORD PTR sym$1$[rbp-105]
  0046c	40 88 7c 02 01	 mov	 BYTE PTR [rdx+rax+1], dil
  00471	49 8b c7	 mov	 rax, r15
  00474	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00477	48 8b 7d 7f	 mov	 rdi, QWORD PTR work$[rbp-105]
  0047b	48 2b c1	 sub	 rax, rcx
  0047e	48 c1 f8 02	 sar	 rax, 2
  00482	66 89 44 11 02	 mov	 WORD PTR [rcx+rdx+2], ax
  00487	8b 55 97	 mov	 edx, DWORD PTR match$1$[rbp-105]
  0048a	e9 31 fe ff ff	 jmp	 $LL181@inflate_ta
$LN82@inflate_ta:

; 289  : 
; 290  :     /* fill in remaining table entry if code is incomplete (guaranteed to have
; 291  :        at most one remaining entry, since if the code is incomplete, the
; 292  :        maximum code length that was allowed to get this far is one bit) */
; 293  :     if (huff != 0) {

  0048f	45 85 db	 test	 r11d, r11d
  00492	74 12		 je	 SHORT $LN64@inflate_ta

; 294  :         here.op = (unsigned char)64;            /* invalid code marker */
; 295  :         here.bits = (unsigned char)(len - drop);
; 296  :         here.val = (unsigned short)0;

  00494	66 89 4d 69	 mov	 WORD PTR here$[rbp-103], cx

; 297  :         next[huff] = here;

  00498	41 8b cb	 mov	 ecx, r11d
  0049b	c6 45 67 40	 mov	 BYTE PTR here$[rbp-105], 64 ; 00000040H
  0049f	8b 45 67	 mov	 eax, DWORD PTR here$[rbp-105]
  004a2	41 89 04 8f	 mov	 DWORD PTR [r15+rcx*4], eax
$LN64@inflate_ta:

; 298  :     }
; 299  : 
; 300  :     /* set return parameters */
; 301  :     *table += used;

  004a6	48 8b 4d 6f	 mov	 rcx, QWORD PTR table$[rbp-105]
  004aa	41 8b c5	 mov	 eax, r13d
  004ad	48 c1 e0 02	 shl	 rax, 2
  004b1	48 01 01	 add	 QWORD PTR [rcx], rax

; 302  :     *bits = root;

  004b4	8b 45 a3	 mov	 eax, DWORD PTR tv1826[rbp-105]
  004b7	48 8b 4d 77	 mov	 rcx, QWORD PTR bits$[rbp-105]
  004bb	89 01		 mov	 DWORD PTR [rcx], eax

; 303  :     return 0;

  004bd	33 c0		 xor	 eax, eax
  004bf	e9 cd fd ff ff	 jmp	 $LN187@inflate_ta
$LN42@inflate_ta:

; 138  :         return -1;                      /* incomplete set */

  004c4	b8 ff ff ff ff	 mov	 eax, -1
  004c9	e9 c8 fd ff ff	 jmp	 $LN186@inflate_ta
inflate_table ENDP
_TEXT	ENDS
END
