; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27041.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	_length_code
PUBLIC	_dist_code
_length_code DB	00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	05H
	DB	06H
	DB	07H
	DB	08H
	DB	08H
	DB	09H
	DB	09H
	DB	0aH
	DB	0aH
	DB	0bH
	DB	0bH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	010H
	DB	010H
	DB	010H
	DB	010H
	DB	010H
	DB	010H
	DB	010H
	DB	010H
	DB	011H
	DB	011H
	DB	011H
	DB	011H
	DB	011H
	DB	011H
	DB	011H
	DB	011H
	DB	012H
	DB	012H
	DB	012H
	DB	012H
	DB	012H
	DB	012H
	DB	012H
	DB	012H
	DB	013H
	DB	013H
	DB	013H
	DB	013H
	DB	013H
	DB	013H
	DB	013H
	DB	013H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01cH
_dist_code DB	00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	04H
	DB	05H
	DB	05H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	00H
	DB	00H
	DB	010H
	DB	011H
	DB	012H
	DB	012H
	DB	013H
	DB	013H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
static_dtree DW	00H
	DW	05H
	DW	010H
	DW	05H
	DW	08H
	DW	05H
	DW	018H
	DW	05H
	DW	04H
	DW	05H
	DW	014H
	DW	05H
	DW	0cH
	DW	05H
	DW	01cH
	DW	05H
	DW	02H
	DW	05H
	DW	012H
	DW	05H
	DW	0aH
	DW	05H
	DW	01aH
	DW	05H
	DW	06H
	DW	05H
	DW	016H
	DW	05H
	DW	0eH
	DW	05H
	DW	01eH
	DW	05H
	DW	01H
	DW	05H
	DW	011H
	DW	05H
	DW	09H
	DW	05H
	DW	019H
	DW	05H
	DW	05H
	DW	05H
	DW	015H
	DW	05H
	DW	0dH
	DW	05H
	DW	01dH
	DW	05H
	DW	03H
	DW	05H
	DW	013H
	DW	05H
	DW	0bH
	DW	05H
	DW	01bH
	DW	05H
	DW	07H
	DW	05H
	DW	017H
	DW	05H
	ORG $+8
extra_blbits DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	02H
	DD	03H
	DD	07H
	ORG $+4
extra_lbits DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	03H
	DD	03H
	DD	03H
	DD	03H
	DD	04H
	DD	04H
	DD	04H
	DD	04H
	DD	05H
	DD	05H
	DD	05H
	DD	05H
	DD	00H
	ORG $+12
base_dist DD	00H
	DD	01H
	DD	02H
	DD	03H
	DD	04H
	DD	06H
	DD	08H
	DD	0cH
	DD	010H
	DD	018H
	DD	020H
	DD	030H
	DD	040H
	DD	060H
	DD	080H
	DD	0c0H
	DD	0100H
	DD	0180H
	DD	0200H
	DD	0300H
	DD	0400H
	DD	0600H
	DD	0800H
	DD	0c00H
	DD	01000H
	DD	01800H
	DD	02000H
	DD	03000H
	DD	04000H
	DD	06000H
	ORG $+8
base_length DD	00H
	DD	01H
	DD	02H
	DD	03H
	DD	04H
	DD	05H
	DD	06H
	DD	07H
	DD	08H
	DD	0aH
	DD	0cH
	DD	0eH
	DD	010H
	DD	014H
	DD	018H
	DD	01cH
	DD	020H
	DD	028H
	DD	030H
	DD	038H
	DD	040H
	DD	050H
	DD	060H
	DD	070H
	DD	080H
	DD	0a0H
	DD	0c0H
	DD	0e0H
	DD	00H
	ORG $+4
static_l_desc DQ FLAT:static_ltree
	DQ	FLAT:extra_lbits
	DD	0101H
	DD	011eH
	DD	0fH
	ORG $+4
static_bl_desc DQ 0000000000000000H
	DQ	FLAT:extra_blbits
	DD	00H
	DD	013H
	DD	07H
	ORG $+4
	ORG $+8
extra_dbits DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	03H
	DD	03H
	DD	04H
	DD	04H
	DD	05H
	DD	05H
	DD	06H
	DD	06H
	DD	07H
	DD	07H
	DD	08H
	DD	08H
	DD	09H
	DD	09H
	DD	0aH
	DD	0aH
	DD	0bH
	DD	0bH
	DD	0cH
	DD	0cH
	DD	0dH
	DD	0dH
	ORG $+8
static_ltree DW	0cH
	DW	08H
	DW	08cH
	DW	08H
	DW	04cH
	DW	08H
	DW	0ccH
	DW	08H
	DW	02cH
	DW	08H
	DW	0acH
	DW	08H
	DW	06cH
	DW	08H
	DW	0ecH
	DW	08H
	DW	01cH
	DW	08H
	DW	09cH
	DW	08H
	DW	05cH
	DW	08H
	DW	0dcH
	DW	08H
	DW	03cH
	DW	08H
	DW	0bcH
	DW	08H
	DW	07cH
	DW	08H
	DW	0fcH
	DW	08H
	DW	02H
	DW	08H
	DW	082H
	DW	08H
	DW	042H
	DW	08H
	DW	0c2H
	DW	08H
	DW	022H
	DW	08H
	DW	0a2H
	DW	08H
	DW	062H
	DW	08H
	DW	0e2H
	DW	08H
	DW	012H
	DW	08H
	DW	092H
	DW	08H
	DW	052H
	DW	08H
	DW	0d2H
	DW	08H
	DW	032H
	DW	08H
	DW	0b2H
	DW	08H
	DW	072H
	DW	08H
	DW	0f2H
	DW	08H
	DW	0aH
	DW	08H
	DW	08aH
	DW	08H
	DW	04aH
	DW	08H
	DW	0caH
	DW	08H
	DW	02aH
	DW	08H
	DW	0aaH
	DW	08H
	DW	06aH
	DW	08H
	DW	0eaH
	DW	08H
	DW	01aH
	DW	08H
	DW	09aH
	DW	08H
	DW	05aH
	DW	08H
	DW	0daH
	DW	08H
	DW	03aH
	DW	08H
	DW	0baH
	DW	08H
	DW	07aH
	DW	08H
	DW	0faH
	DW	08H
	DW	06H
	DW	08H
	DW	086H
	DW	08H
	DW	046H
	DW	08H
	DW	0c6H
	DW	08H
	DW	026H
	DW	08H
	DW	0a6H
	DW	08H
	DW	066H
	DW	08H
	DW	0e6H
	DW	08H
	DW	016H
	DW	08H
	DW	096H
	DW	08H
	DW	056H
	DW	08H
	DW	0d6H
	DW	08H
	DW	036H
	DW	08H
	DW	0b6H
	DW	08H
	DW	076H
	DW	08H
	DW	0f6H
	DW	08H
	DW	0eH
	DW	08H
	DW	08eH
	DW	08H
	DW	04eH
	DW	08H
	DW	0ceH
	DW	08H
	DW	02eH
	DW	08H
	DW	0aeH
	DW	08H
	DW	06eH
	DW	08H
	DW	0eeH
	DW	08H
	DW	01eH
	DW	08H
	DW	09eH
	DW	08H
	DW	05eH
	DW	08H
	DW	0deH
	DW	08H
	DW	03eH
	DW	08H
	DW	0beH
	DW	08H
	DW	07eH
	DW	08H
	DW	0feH
	DW	08H
	DW	01H
	DW	08H
	DW	081H
	DW	08H
	DW	041H
	DW	08H
	DW	0c1H
	DW	08H
	DW	021H
	DW	08H
	DW	0a1H
	DW	08H
	DW	061H
	DW	08H
	DW	0e1H
	DW	08H
	DW	011H
	DW	08H
	DW	091H
	DW	08H
	DW	051H
	DW	08H
	DW	0d1H
	DW	08H
	DW	031H
	DW	08H
	DW	0b1H
	DW	08H
	DW	071H
	DW	08H
	DW	0f1H
	DW	08H
	DW	09H
	DW	08H
	DW	089H
	DW	08H
	DW	049H
	DW	08H
	DW	0c9H
	DW	08H
	DW	029H
	DW	08H
	DW	0a9H
	DW	08H
	DW	069H
	DW	08H
	DW	0e9H
	DW	08H
	DW	019H
	DW	08H
	DW	099H
	DW	08H
	DW	059H
	DW	08H
	DW	0d9H
	DW	08H
	DW	039H
	DW	08H
	DW	0b9H
	DW	08H
	DW	079H
	DW	08H
	DW	0f9H
	DW	08H
	DW	05H
	DW	08H
	DW	085H
	DW	08H
	DW	045H
	DW	08H
	DW	0c5H
	DW	08H
	DW	025H
	DW	08H
	DW	0a5H
	DW	08H
	DW	065H
	DW	08H
	DW	0e5H
	DW	08H
	DW	015H
	DW	08H
	DW	095H
	DW	08H
	DW	055H
	DW	08H
	DW	0d5H
	DW	08H
	DW	035H
	DW	08H
	DW	0b5H
	DW	08H
	DW	075H
	DW	08H
	DW	0f5H
	DW	08H
	DW	0dH
	DW	08H
	DW	08dH
	DW	08H
	DW	04dH
	DW	08H
	DW	0cdH
	DW	08H
	DW	02dH
	DW	08H
	DW	0adH
	DW	08H
	DW	06dH
	DW	08H
	DW	0edH
	DW	08H
	DW	01dH
	DW	08H
	DW	09dH
	DW	08H
	DW	05dH
	DW	08H
	DW	0ddH
	DW	08H
	DW	03dH
	DW	08H
	DW	0bdH
	DW	08H
	DW	07dH
	DW	08H
	DW	0fdH
	DW	08H
	DW	013H
	DW	09H
	DW	0113H
	DW	09H
	DW	093H
	DW	09H
	DW	0193H
	DW	09H
	DW	053H
	DW	09H
	DW	0153H
	DW	09H
	DW	0d3H
	DW	09H
	DW	01d3H
	DW	09H
	DW	033H
	DW	09H
	DW	0133H
	DW	09H
	DW	0b3H
	DW	09H
	DW	01b3H
	DW	09H
	DW	073H
	DW	09H
	DW	0173H
	DW	09H
	DW	0f3H
	DW	09H
	DW	01f3H
	DW	09H
	DW	0bH
	DW	09H
	DW	010bH
	DW	09H
	DW	08bH
	DW	09H
	DW	018bH
	DW	09H
	DW	04bH
	DW	09H
	DW	014bH
	DW	09H
	DW	0cbH
	DW	09H
	DW	01cbH
	DW	09H
	DW	02bH
	DW	09H
	DW	012bH
	DW	09H
	DW	0abH
	DW	09H
	DW	01abH
	DW	09H
	DW	06bH
	DW	09H
	DW	016bH
	DW	09H
	DW	0ebH
	DW	09H
	DW	01ebH
	DW	09H
	DW	01bH
	DW	09H
	DW	011bH
	DW	09H
	DW	09bH
	DW	09H
	DW	019bH
	DW	09H
	DW	05bH
	DW	09H
	DW	015bH
	DW	09H
	DW	0dbH
	DW	09H
	DW	01dbH
	DW	09H
	DW	03bH
	DW	09H
	DW	013bH
	DW	09H
	DW	0bbH
	DW	09H
	DW	01bbH
	DW	09H
	DW	07bH
	DW	09H
	DW	017bH
	DW	09H
	DW	0fbH
	DW	09H
	DW	01fbH
	DW	09H
	DW	07H
	DW	09H
	DW	0107H
	DW	09H
	DW	087H
	DW	09H
	DW	0187H
	DW	09H
	DW	047H
	DW	09H
	DW	0147H
	DW	09H
	DW	0c7H
	DW	09H
	DW	01c7H
	DW	09H
	DW	027H
	DW	09H
	DW	0127H
	DW	09H
	DW	0a7H
	DW	09H
	DW	01a7H
	DW	09H
	DW	067H
	DW	09H
	DW	0167H
	DW	09H
	DW	0e7H
	DW	09H
	DW	01e7H
	DW	09H
	DW	017H
	DW	09H
	DW	0117H
	DW	09H
	DW	097H
	DW	09H
	DW	0197H
	DW	09H
	DW	057H
	DW	09H
	DW	0157H
	DW	09H
	DW	0d7H
	DW	09H
	DW	01d7H
	DW	09H
	DW	037H
	DW	09H
	DW	0137H
	DW	09H
	DW	0b7H
	DW	09H
	DW	01b7H
	DW	09H
	DW	077H
	DW	09H
	DW	0177H
	DW	09H
	DW	0f7H
	DW	09H
	DW	01f7H
	DW	09H
	DW	0fH
	DW	09H
	DW	010fH
	DW	09H
	DW	08fH
	DW	09H
	DW	018fH
	DW	09H
	DW	04fH
	DW	09H
	DW	014fH
	DW	09H
	DW	0cfH
	DW	09H
	DW	01cfH
	DW	09H
	DW	02fH
	DW	09H
	DW	012fH
	DW	09H
	DW	0afH
	DW	09H
	DW	01afH
	DW	09H
	DW	06fH
	DW	09H
	DW	016fH
	DW	09H
	DW	0efH
	DW	09H
	DW	01efH
	DW	09H
	DW	01fH
	DW	09H
	DW	011fH
	DW	09H
	DW	09fH
	DW	09H
	DW	019fH
	DW	09H
	DW	05fH
	DW	09H
	DW	015fH
	DW	09H
	DW	0dfH
	DW	09H
	DW	01dfH
	DW	09H
	DW	03fH
	DW	09H
	DW	013fH
	DW	09H
	DW	0bfH
	DW	09H
	DW	01bfH
	DW	09H
	DW	07fH
	DW	09H
	DW	017fH
	DW	09H
	DW	0ffH
	DW	09H
	DW	01ffH
	DW	09H
	DW	00H
	DW	07H
	DW	040H
	DW	07H
	DW	020H
	DW	07H
	DW	060H
	DW	07H
	DW	010H
	DW	07H
	DW	050H
	DW	07H
	DW	030H
	DW	07H
	DW	070H
	DW	07H
	DW	08H
	DW	07H
	DW	048H
	DW	07H
	DW	028H
	DW	07H
	DW	068H
	DW	07H
	DW	018H
	DW	07H
	DW	058H
	DW	07H
	DW	038H
	DW	07H
	DW	078H
	DW	07H
	DW	04H
	DW	07H
	DW	044H
	DW	07H
	DW	024H
	DW	07H
	DW	064H
	DW	07H
	DW	014H
	DW	07H
	DW	054H
	DW	07H
	DW	034H
	DW	07H
	DW	074H
	DW	07H
	DW	03H
	DW	08H
	DW	083H
	DW	08H
	DW	043H
	DW	08H
	DW	0c3H
	DW	08H
	DW	023H
	DW	08H
	DW	0a3H
	DW	08H
	DW	063H
	DW	08H
	DW	0e3H
	DW	08H
static_d_desc DQ FLAT:static_dtree
	DQ	FLAT:extra_dbits
	DD	00H
	DD	01eH
	DD	0fH
	ORG $+4
bl_order DB	010H
	DB	011H
	DB	012H
	DB	00H
	DB	08H
	DB	07H
	DB	09H
	DB	06H
	DB	0aH
	DB	05H
	DB	0bH
	DB	04H
	DB	0cH
	DB	03H
	DB	0dH
	DB	02H
	DB	0eH
	DB	01H
	DB	0fH
PUBLIC	_tr_align
PUBLIC	_tr_init
PUBLIC	_tr_flush_block
PUBLIC	_tr_flush_bits
PUBLIC	_tr_stored_block
;	COMDAT pdata
pdata	SEGMENT
$pdata$compress_block DD imagerel compress_block
	DD	imagerel compress_block+6
	DD	imagerel $unwind$compress_block
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$compress_block DD imagerel compress_block+6
	DD	imagerel compress_block+49
	DD	imagerel $chain$2$compress_block
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$compress_block DD imagerel compress_block+49
	DD	imagerel compress_block+943
	DD	imagerel $chain$6$compress_block
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$compress_block DD imagerel compress_block+943
	DD	imagerel compress_block+1006
	DD	imagerel $chain$7$compress_block
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$compress_block DD imagerel compress_block+1006
	DD	imagerel compress_block+1120
	DD	imagerel $chain$8$compress_block
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$send_all_trees DD imagerel send_all_trees
	DD	imagerel send_all_trees+611
	DD	imagerel $unwind$send_all_trees
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$build_bl_tree DD imagerel build_bl_tree
	DD	imagerel build_bl_tree+197
	DD	imagerel $unwind$build_bl_tree
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$send_tree DD imagerel send_tree
	DD	imagerel send_tree+21
	DD	imagerel $unwind$send_tree
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$send_tree DD imagerel send_tree+21
	DD	imagerel send_tree+1379
	DD	imagerel $chain$6$send_tree
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$send_tree DD imagerel send_tree+1379
	DD	imagerel send_tree+1380
	DD	imagerel $chain$7$send_tree
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$scan_tree DD imagerel scan_tree
	DD	imagerel scan_tree+38
	DD	imagerel $unwind$scan_tree
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$scan_tree DD imagerel scan_tree+38
	DD	imagerel scan_tree+259
	DD	imagerel $chain$2$scan_tree
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$scan_tree DD imagerel scan_tree+259
	DD	imagerel scan_tree+261
	DD	imagerel $chain$3$scan_tree
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$build_tree DD imagerel build_tree
	DD	imagerel build_tree+607
	DD	imagerel $unwind$build_tree
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gen_codes DD imagerel gen_codes
	DD	imagerel gen_codes+282
	DD	imagerel $unwind$gen_codes
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gen_bitlen DD imagerel gen_bitlen
	DD	imagerel gen_bitlen+109
	DD	imagerel $unwind$gen_bitlen
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$gen_bitlen DD imagerel gen_bitlen+109
	DD	imagerel gen_bitlen+304
	DD	imagerel $chain$1$gen_bitlen
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$gen_bitlen DD imagerel gen_bitlen+304
	DD	imagerel gen_bitlen+525
	DD	imagerel $chain$2$gen_bitlen
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$pqdownheap DD imagerel pqdownheap
	DD	imagerel pqdownheap+39
	DD	imagerel $unwind$pqdownheap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$pqdownheap DD imagerel pqdownheap+39
	DD	imagerel pqdownheap+201
	DD	imagerel $chain$0$pqdownheap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$pqdownheap DD imagerel pqdownheap+201
	DD	imagerel pqdownheap+223
	DD	imagerel $chain$2$pqdownheap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$pqdownheap DD imagerel pqdownheap+223
	DD	imagerel pqdownheap+238
	DD	imagerel $chain$3$pqdownheap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_tr_flush_block DD imagerel $LN19
	DD	imagerel $LN19+564
	DD	imagerel $unwind$_tr_flush_block
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_tr_stored_block DD imagerel $LN6
	DD	imagerel $LN6+270
	DD	imagerel $unwind$_tr_stored_block
;	COMDAT xdata
xdata	SEGMENT
$unwind$_tr_stored_block DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_tr_flush_block DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$pqdownheap DD 021H
	DD	imagerel pqdownheap
	DD	imagerel pqdownheap+39
	DD	imagerel $unwind$pqdownheap
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$pqdownheap DD 020021H
	DD	026400H
	DD	imagerel pqdownheap
	DD	imagerel pqdownheap+39
	DD	imagerel $unwind$pqdownheap
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$pqdownheap DD 020521H
	DD	026405H
	DD	imagerel pqdownheap
	DD	imagerel pqdownheap+39
	DD	imagerel $unwind$pqdownheap
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pqdownheap DD 030601H
	DD	033406H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$gen_bitlen DD 021H
	DD	imagerel gen_bitlen
	DD	imagerel gen_bitlen+109
	DD	imagerel $unwind$gen_bitlen
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$gen_bitlen DD 040d21H
	DD	08e40dH
	DD	07c405H
	DD	imagerel gen_bitlen
	DD	imagerel gen_bitlen+109
	DD	imagerel $unwind$gen_bitlen
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gen_bitlen DD 070c01H
	DD	09340cH
	DD	0d00af00cH
	DD	060077008H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gen_codes DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$build_tree DD 0c1e01H
	DD	0b741eH
	DD	0a641eH
	DD	09541eH
	DD	08341eH
	DD	0f01a321eH
	DD	0c016e018H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$scan_tree DD 021H
	DD	imagerel scan_tree
	DD	imagerel scan_tree+38
	DD	imagerel $unwind$scan_tree
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$scan_tree DD 061e21H
	DD	04741eH
	DD	03640eH
	DD	025405H
	DD	imagerel scan_tree
	DD	imagerel scan_tree+38
	DD	imagerel $unwind$scan_tree
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$scan_tree DD 010201H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$send_tree DD 021H
	DD	imagerel send_tree
	DD	imagerel send_tree+21
	DD	imagerel $unwind$send_tree
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$send_tree DD 0e4221H
	DD	0f442H
	DD	01e43cH
	DD	02d424H
	DD	03c41fH
	DD	087414H
	DD	07540cH
	DD	063405H
	DD	imagerel send_tree
	DD	imagerel send_tree+21
	DD	imagerel $unwind$send_tree
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$send_tree DD 020e01H
	DD	0600a320eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$build_bl_tree DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$send_all_trees DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$compress_block DD 021H
	DD	imagerel compress_block
	DD	imagerel compress_block+6
	DD	imagerel $unwind$compress_block
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$compress_block DD 021H
	DD	imagerel compress_block+6
	DD	imagerel compress_block+49
	DD	imagerel $chain$2$compress_block
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$compress_block DD 081b21H
	DD	08741bH
	DD	076416H
	DD	065411H
	DD	02d405H
	DD	imagerel compress_block+6
	DD	imagerel compress_block+49
	DD	imagerel $chain$2$compress_block
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$compress_block DD 061721H
	DD	0f417H
	DD	01e40dH
	DD	03c405H
	DD	imagerel compress_block
	DD	imagerel compress_block+6
	DD	imagerel $unwind$compress_block
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compress_block DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
; File c:\daten\projekte\simulationplatform\third_party_libraries\zlib\zlib-1.2.11\trees.c
;	COMDAT _tr_stored_block
_TEXT	SEGMENT
s$ = 48
buf$ = 56
stored_len$ = 64
last$ = 72
_tr_stored_block PROC					; COMDAT

; 868  : {

$LN6:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b d9	 mov	 rbx, rcx
  00012	41 8b f8	 mov	 edi, r8d

; 869  :     send_bits(s, (STORED_BLOCK<<1)+last, 3);    /* send block type */

  00015	8b 89 14 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5908]
  0001b	48 8b f2	 mov	 rsi, rdx
  0001e	44 0f b7 9b 10
	17 00 00	 movzx	 r11d, WORD PTR [rbx+5904]
  00026	83 f9 0d	 cmp	 ecx, 13
  00029	7e 51		 jle	 SHORT $LN2@tr_stored_
  0002b	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  0002f	45 0f b7 d1	 movzx	 r10d, r9w
  00033	66 41 d3 e2	 shl	 r10w, cl
  00037	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]
  0003a	66 45 0b d3	 or	 r10w, r11w
  0003e	66 44 89 93 10
	17 00 00	 mov	 WORD PTR [rbx+5904], r10w
  00046	44 88 14 01	 mov	 BYTE PTR [rcx+rax], r10b
  0004a	ff 43 28	 inc	 DWORD PTR [rbx+40]
  0004d	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]
  00050	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  00054	0f b6 83 11 17
	00 00		 movzx	 eax, BYTE PTR [rbx+5905]
  0005b	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0005e	b9 10 00 00 00	 mov	 ecx, 16
  00063	0f b7 83 14 17
	00 00		 movzx	 eax, WORD PTR [rbx+5908]
  0006a	ff 43 28	 inc	 DWORD PTR [rbx+40]
  0006d	2a c8		 sub	 cl, al
  0006f	83 83 14 17 00
	00 f3		 add	 DWORD PTR [rbx+5908], -13
  00076	66 41 d3 e9	 shr	 r9w, cl
  0007a	eb 11		 jmp	 SHORT $LN3@tr_stored_
$LN2@tr_stored_:
  0007c	8d 41 03	 lea	 eax, DWORD PTR [rcx+3]
  0007f	66 41 d3 e1	 shl	 r9w, cl
  00083	89 83 14 17 00
	00		 mov	 DWORD PTR [rbx+5908], eax
  00089	66 45 0b cb	 or	 r9w, r11w
$LN3@tr_stored_:

; 870  :     bi_windup(s);        /* align on byte boundary */

  0008d	48 8b cb	 mov	 rcx, rbx
  00090	66 44 89 8b 10
	17 00 00	 mov	 WORD PTR [rbx+5904], r9w
  00098	e8 00 00 00 00	 call	 bi_windup

; 871  :     put_short(s, (ush)stored_len);

  0009d	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]

; 872  :     put_short(s, (ush)~stored_len);
; 873  :     zmemcpy(s->pending_buf + s->pending, (Bytef *)buf, stored_len);

  000a0	4c 8b c7	 mov	 r8, rdi
  000a3	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  000a7	40 88 3c 01	 mov	 BYTE PTR [rcx+rax], dil
  000ab	0f b7 cf	 movzx	 ecx, di
  000ae	ff 43 28	 inc	 DWORD PTR [rbx+40]
  000b1	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]
  000b4	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  000b8	66 c1 e9 08	 shr	 cx, 8
  000bc	88 0c 02	 mov	 BYTE PTR [rdx+rax], cl
  000bf	40 0f b6 cf	 movzx	 ecx, dil
  000c3	ff 43 28	 inc	 DWORD PTR [rbx+40]
  000c6	f6 d1		 not	 cl
  000c8	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]
  000cb	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  000cf	88 0c 02	 mov	 BYTE PTR [rdx+rax], cl
  000d2	0f b7 cf	 movzx	 ecx, di
  000d5	ff 43 28	 inc	 DWORD PTR [rbx+40]
  000d8	66 f7 d1	 not	 cx
  000db	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]
  000de	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  000e2	66 c1 e9 08	 shr	 cx, 8
  000e6	88 0c 02	 mov	 BYTE PTR [rdx+rax], cl
  000e9	48 8b d6	 mov	 rdx, rsi
  000ec	ff 43 28	 inc	 DWORD PTR [rbx+40]
  000ef	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]
  000f2	48 03 4b 10	 add	 rcx, QWORD PTR [rbx+16]
  000f6	e8 00 00 00 00	 call	 memcpy

; 874  :     s->pending += stored_len;

  000fb	01 7b 28	 add	 DWORD PTR [rbx+40], edi

; 875  : #ifdef ZLIB_DEBUG
; 876  :     s->compressed_len = (s->compressed_len + 3 + 7) & (ulg)~7L;
; 877  :     s->compressed_len += (stored_len + 4) << 3;
; 878  :     s->bits_sent += 2*16;
; 879  :     s->bits_sent += stored_len<<3;
; 880  : #endif
; 881  : }

  000fe	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00103	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00108	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0010c	5f		 pop	 rdi
  0010d	c3		 ret	 0
_tr_stored_block ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\daten\projekte\simulationplatform\third_party_libraries\zlib\zlib-1.2.11\trees.c
;	COMDAT _tr_flush_bits
_TEXT	SEGMENT
s$ = 8
_tr_flush_bits PROC					; COMDAT

; 889  :     bi_flush(s);

  00000	e9 00 00 00 00	 jmp	 bi_flush
_tr_flush_bits ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\daten\projekte\simulationplatform\third_party_libraries\zlib\zlib-1.2.11\trees.c
;	COMDAT _tr_flush_block
_TEXT	SEGMENT
s$ = 48
buf$ = 56
stored_len$ = 64
last$ = 72
_tr_flush_block PROC					; COMDAT

; 916  : {

$LN19:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 917  :     ulg opt_lenb, static_lenb; /* opt_len and static_len in bytes */
; 918  :     int max_blindex = 0;  /* index of last bit length code of non zero freq */

  00014	45 33 d2	 xor	 r10d, r10d
  00017	41 8b f9	 mov	 edi, r9d
  0001a	41 8b f0	 mov	 esi, r8d
  0001d	48 8b ea	 mov	 rbp, rdx
  00020	48 8b d9	 mov	 rbx, rcx

; 919  : 
; 920  :     /* Build the Huffman trees unless a stored block is forced */
; 921  :     if (s->level > 0) {

  00023	44 39 91 ac 00
	00 00		 cmp	 DWORD PTR [rcx+172], r10d
  0002a	7e 5f		 jle	 SHORT $LN2@tr_flush_b

; 922  : 
; 923  :         /* Check if the file is binary or text */
; 924  :         if (s->strm->data_type == Z_UNKNOWN)

  0002c	4c 8b 11	 mov	 r10, QWORD PTR [rcx]
  0002f	41 83 7a 48 02	 cmp	 DWORD PTR [r10+72], 2
  00034	75 09		 jne	 SHORT $LN4@tr_flush_b

; 925  :             s->strm->data_type = detect_data_type(s);

  00036	e8 00 00 00 00	 call	 detect_data_type
  0003b	41 89 42 48	 mov	 DWORD PTR [r10+72], eax
$LN4@tr_flush_b:

; 926  : 
; 927  :         /* Construct the literal and distance trees */
; 928  :         build_tree(s, (tree_desc *)(&(s->l_desc)));

  0003f	48 8d 93 40 0b
	00 00		 lea	 rdx, QWORD PTR [rbx+2880]
  00046	48 8b cb	 mov	 rcx, rbx
  00049	e8 00 00 00 00	 call	 build_tree

; 929  :         Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
; 930  :                 s->static_len));
; 931  : 
; 932  :         build_tree(s, (tree_desc *)(&(s->d_desc)));

  0004e	48 8d 93 58 0b
	00 00		 lea	 rdx, QWORD PTR [rbx+2904]
  00055	48 8b cb	 mov	 rcx, rbx
  00058	e8 00 00 00 00	 call	 build_tree

; 933  :         Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
; 934  :                 s->static_len));
; 935  :         /* At this point, opt_len and static_len are the total bit lengths of
; 936  :          * the compressed block data, excluding the tree representations.
; 937  :          */
; 938  : 
; 939  :         /* Build the bit length tree for the above two trees, and get the index
; 940  :          * in bl_order of the last bit length code to send.
; 941  :          */
; 942  :         max_blindex = build_bl_tree(s);

  0005d	48 8b cb	 mov	 rcx, rbx
  00060	e8 00 00 00 00	 call	 build_bl_tree

; 943  : 
; 944  :         /* Determine the best encoding. Compute the block lengths in bytes. */
; 945  :         opt_lenb = (s->opt_len+3+7)>>3;

  00065	8b 8b 00 17 00
	00		 mov	 ecx, DWORD PTR [rbx+5888]
  0006b	44 8b d0	 mov	 r10d, eax

; 946  :         static_lenb = (s->static_len+3+7)>>3;

  0006e	8b 93 04 17 00
	00		 mov	 edx, DWORD PTR [rbx+5892]
  00074	83 c1 0a	 add	 ecx, 10
  00077	83 c2 0a	 add	 edx, 10
  0007a	c1 e9 03	 shr	 ecx, 3
  0007d	c1 ea 03	 shr	 edx, 3

; 947  : 
; 948  :         Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
; 949  :                 opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
; 950  :                 s->last_lit));
; 951  : 
; 952  :         if (static_lenb <= opt_lenb) opt_lenb = static_lenb;
; 953  : 
; 954  :     } else {

  00080	3b d1		 cmp	 edx, ecx
  00082	44 8b c2	 mov	 r8d, edx
  00085	44 0f 47 c1	 cmova	 r8d, ecx
  00089	eb 07		 jmp	 SHORT $LN3@tr_flush_b
$LN2@tr_flush_b:

; 955  :         Assert(buf != (char*)0, "lost buf");
; 956  :         opt_lenb = static_lenb = stored_len + 5; /* force a stored block */

  0008b	41 8d 50 05	 lea	 edx, DWORD PTR [r8+5]
  0008f	44 8b c2	 mov	 r8d, edx
$LN3@tr_flush_b:

; 957  :     }
; 958  : 
; 959  : #ifdef FORCE_STORED
; 960  :     if (buf != (char*)0) { /* force stored block */
; 961  : #else
; 962  :     if (stored_len+4 <= opt_lenb && buf != (char*)0) {

  00092	8d 46 04	 lea	 eax, DWORD PTR [rsi+4]
  00095	41 3b c0	 cmp	 eax, r8d
  00098	77 1b		 ja	 SHORT $LN6@tr_flush_b
  0009a	48 85 ed	 test	 rbp, rbp
  0009d	74 16		 je	 SHORT $LN6@tr_flush_b

; 963  :                        /* 4: two words for the lengths */
; 964  : #endif
; 965  :         /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
; 966  :          * Otherwise we can't have processed more than WSIZE input bytes since
; 967  :          * the last block flush, because compression would have been
; 968  :          * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
; 969  :          * transform a block into a stored block.
; 970  :          */
; 971  :         _tr_stored_block(s, buf, stored_len, last);

  0009f	44 8b cf	 mov	 r9d, edi
  000a2	44 8b c6	 mov	 r8d, esi
  000a5	48 8b d5	 mov	 rdx, rbp
  000a8	48 8b cb	 mov	 rcx, rbx
  000ab	e8 00 00 00 00	 call	 _tr_stored_block
  000b0	e9 59 01 00 00	 jmp	 $LN9@tr_flush_b
$LN6@tr_flush_b:

; 972  : 
; 973  : #ifdef FORCE_STATIC
; 974  :     } else if (static_lenb >= 0) { /* force static trees */
; 975  : #else
; 976  :     } else if (s->strategy == Z_FIXED || static_lenb == opt_lenb) {

  000b5	83 bb b0 00 00
	00 04		 cmp	 DWORD PTR [rbx+176], 4
  000bc	0f 84 b8 00 00
	00		 je	 $LN10@tr_flush_b
  000c2	41 3b d0	 cmp	 edx, r8d
  000c5	0f 84 af 00 00
	00		 je	 $LN10@tr_flush_b

; 980  :                        (const ct_data *)static_dtree);
; 981  : #ifdef ZLIB_DEBUG
; 982  :         s->compressed_len += 3 + s->static_len;
; 983  : #endif
; 984  :     } else {
; 985  :         send_bits(s, (DYN_TREES<<1)+last, 3);

  000cb	8b 8b 14 17 00
	00		 mov	 ecx, DWORD PTR [rbx+5908]
  000d1	44 8d 47 04	 lea	 r8d, DWORD PTR [rdi+4]
  000d5	44 0f b7 8b 10
	17 00 00	 movzx	 r9d, WORD PTR [rbx+5904]
  000dd	83 f9 0d	 cmp	 ecx, 13
  000e0	7e 4e		 jle	 SHORT $LN13@tr_flush_b
  000e2	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  000e6	41 0f b7 d0	 movzx	 edx, r8w
  000ea	66 d3 e2	 shl	 dx, cl
  000ed	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]
  000f0	66 41 0b d1	 or	 dx, r9w
  000f4	66 89 93 10 17
	00 00		 mov	 WORD PTR [rbx+5904], dx
  000fb	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  000fe	ff 43 28	 inc	 DWORD PTR [rbx+40]
  00101	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]
  00104	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  00108	0f b6 83 11 17
	00 00		 movzx	 eax, BYTE PTR [rbx+5905]
  0010f	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00112	b9 10 00 00 00	 mov	 ecx, 16
  00117	0f b7 83 14 17
	00 00		 movzx	 eax, WORD PTR [rbx+5908]
  0011e	ff 43 28	 inc	 DWORD PTR [rbx+40]
  00121	2a c8		 sub	 cl, al
  00123	83 83 14 17 00
	00 f3		 add	 DWORD PTR [rbx+5908], -13
  0012a	66 41 d3 e8	 shr	 r8w, cl
  0012e	eb 11		 jmp	 SHORT $LN14@tr_flush_b
$LN13@tr_flush_b:
  00130	8d 41 03	 lea	 eax, DWORD PTR [rcx+3]
  00133	66 41 d3 e0	 shl	 r8w, cl
  00137	89 83 14 17 00
	00		 mov	 DWORD PTR [rbx+5908], eax
  0013d	66 45 0b c1	 or	 r8w, r9w
$LN14@tr_flush_b:

; 986  :         send_all_trees(s, s->l_desc.max_code+1, s->d_desc.max_code+1,

  00141	66 44 89 83 10
	17 00 00	 mov	 WORD PTR [rbx+5904], r8w
  00149	45 8d 4a 01	 lea	 r9d, DWORD PTR [r10+1]
  0014d	44 8b 83 60 0b
	00 00		 mov	 r8d, DWORD PTR [rbx+2912]
  00154	48 8b cb	 mov	 rcx, rbx
  00157	8b 93 48 0b 00
	00		 mov	 edx, DWORD PTR [rbx+2888]
  0015d	41 ff c0	 inc	 r8d
  00160	ff c2		 inc	 edx
  00162	e8 00 00 00 00	 call	 send_all_trees

; 987  :                        max_blindex+1);
; 988  :         compress_block(s, (const ct_data *)s->dyn_ltree,

  00167	4c 8d 83 b0 09
	00 00		 lea	 r8, QWORD PTR [rbx+2480]
  0016e	48 8d 93 bc 00
	00 00		 lea	 rdx, QWORD PTR [rbx+188]
  00175	e9 8c 00 00 00	 jmp	 $LN17@tr_flush_b
$LN10@tr_flush_b:

; 977  : #endif
; 978  :         send_bits(s, (STATIC_TREES<<1)+last, 3);

  0017a	8b 8b 14 17 00
	00		 mov	 ecx, DWORD PTR [rbx+5908]
  00180	44 8d 47 02	 lea	 r8d, DWORD PTR [rdi+2]
  00184	44 0f b7 8b 10
	17 00 00	 movzx	 r9d, WORD PTR [rbx+5904]
  0018c	83 f9 0d	 cmp	 ecx, 13
  0018f	7e 4e		 jle	 SHORT $LN11@tr_flush_b
  00191	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  00195	41 0f b7 d0	 movzx	 edx, r8w
  00199	66 d3 e2	 shl	 dx, cl
  0019c	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]
  0019f	66 41 0b d1	 or	 dx, r9w
  001a3	66 89 93 10 17
	00 00		 mov	 WORD PTR [rbx+5904], dx
  001aa	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  001ad	ff 43 28	 inc	 DWORD PTR [rbx+40]
  001b0	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]
  001b3	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  001b7	0f b6 83 11 17
	00 00		 movzx	 eax, BYTE PTR [rbx+5905]
  001be	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  001c1	b9 10 00 00 00	 mov	 ecx, 16
  001c6	0f b7 83 14 17
	00 00		 movzx	 eax, WORD PTR [rbx+5908]
  001cd	ff 43 28	 inc	 DWORD PTR [rbx+40]
  001d0	2a c8		 sub	 cl, al
  001d2	83 83 14 17 00
	00 f3		 add	 DWORD PTR [rbx+5908], -13
  001d9	66 41 d3 e8	 shr	 r8w, cl
  001dd	eb 11		 jmp	 SHORT $LN12@tr_flush_b
$LN11@tr_flush_b:
  001df	8d 41 03	 lea	 eax, DWORD PTR [rcx+3]
  001e2	66 41 d3 e0	 shl	 r8w, cl
  001e6	89 83 14 17 00
	00		 mov	 DWORD PTR [rbx+5908], eax
  001ec	66 45 0b c1	 or	 r8w, r9w
$LN12@tr_flush_b:

; 979  :         compress_block(s, (const ct_data *)static_ltree,

  001f0	66 44 89 83 10
	17 00 00	 mov	 WORD PTR [rbx+5904], r8w
  001f8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:static_ltree
  001ff	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:static_dtree
$LN17@tr_flush_b:

; 989  :                        (const ct_data *)s->dyn_dtree);
; 990  : #ifdef ZLIB_DEBUG
; 991  :         s->compressed_len += 3 + s->opt_len;
; 992  : #endif
; 993  :     }
; 994  :     Assert (s->compressed_len == s->bits_sent, "bad compressed size");
; 995  :     /* The above check is made mod 2^32, for files larger than 512 MB
; 996  :      * and uLong implemented on 32 bits.
; 997  :      */
; 998  :     init_block(s);

  00206	48 8b cb	 mov	 rcx, rbx
  00209	e8 00 00 00 00	 call	 compress_block
$LN9@tr_flush_b:
  0020e	48 8b cb	 mov	 rcx, rbx
  00211	e8 00 00 00 00	 call	 init_block

; 999  : 
; 1000 :     if (last) {

  00216	85 ff		 test	 edi, edi
  00218	74 05		 je	 SHORT $LN15@tr_flush_b

; 1001 :         bi_windup(s);

  0021a	e8 00 00 00 00	 call	 bi_windup
$LN15@tr_flush_b:

; 1002 : #ifdef ZLIB_DEBUG
; 1003 :         s->compressed_len += 7;  /* align on byte boundary */
; 1004 : #endif
; 1005 :     }
; 1006 :     Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
; 1007 :            s->compressed_len-7*last));
; 1008 : }

  0021f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00224	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00229	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0022e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00232	5f		 pop	 rdi
  00233	c3		 ret	 0
_tr_flush_block ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\daten\projekte\simulationplatform\third_party_libraries\zlib\zlib-1.2.11\trees.c
;	COMDAT _tr_init
_TEXT	SEGMENT
s$ = 8
_tr_init PROC						; COMDAT

; 382  :     tr_static_init();
; 383  : 
; 384  :     s->l_desc.dyn_tree = s->dyn_ltree;

  00000	48 8d 81 bc 00
	00 00		 lea	 rax, QWORD PTR [rcx+188]
  00007	48 89 81 40 0b
	00 00		 mov	 QWORD PTR [rcx+2880], rax

; 385  :     s->l_desc.stat_desc = &static_l_desc;

  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:static_l_desc
  00015	48 89 81 50 0b
	00 00		 mov	 QWORD PTR [rcx+2896], rax

; 386  : 
; 387  :     s->d_desc.dyn_tree = s->dyn_dtree;

  0001c	48 8d 81 b0 09
	00 00		 lea	 rax, QWORD PTR [rcx+2480]
  00023	48 89 81 58 0b
	00 00		 mov	 QWORD PTR [rcx+2904], rax

; 388  :     s->d_desc.stat_desc = &static_d_desc;

  0002a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:static_d_desc
  00031	48 89 81 68 0b
	00 00		 mov	 QWORD PTR [rcx+2920], rax

; 389  : 
; 390  :     s->bl_desc.dyn_tree = s->bl_tree;

  00038	48 8d 81 a4 0a
	00 00		 lea	 rax, QWORD PTR [rcx+2724]
  0003f	48 89 81 70 0b
	00 00		 mov	 QWORD PTR [rcx+2928], rax

; 391  :     s->bl_desc.stat_desc = &static_bl_desc;

  00046	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:static_bl_desc
  0004d	48 89 81 80 0b
	00 00		 mov	 QWORD PTR [rcx+2944], rax

; 392  : 
; 393  :     s->bi_buf = 0;

  00054	33 c0		 xor	 eax, eax
  00056	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax

; 394  :     s->bi_valid = 0;

  0005d	89 81 14 17 00
	00		 mov	 DWORD PTR [rcx+5908], eax

; 395  : #ifdef ZLIB_DEBUG
; 396  :     s->compressed_len = 0L;
; 397  :     s->bits_sent = 0L;
; 398  : #endif
; 399  : 
; 400  :     /* Initialize the first block of the first file: */
; 401  :     init_block(s);

  00063	e9 00 00 00 00	 jmp	 init_block
_tr_init ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\daten\projekte\simulationplatform\third_party_libraries\zlib\zlib-1.2.11\trees.c
;	COMDAT _tr_align
_TEXT	SEGMENT
s$ = 8
_tr_align PROC						; COMDAT

; 898  : {

  00000	4c 8b c1	 mov	 r8, rcx

; 899  :     send_bits(s, STATIC_TREES<<1, 3);

  00003	41 b9 02 00 00
	00		 mov	 r9d, 2
  00009	8b 89 14 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5908]
  0000f	41 8b d1	 mov	 edx, r9d
  00012	66 d3 e2	 shl	 dx, cl
  00015	66 41 0b 90 10
	17 00 00	 or	 dx, WORD PTR [r8+5904]
  0001d	83 f9 0d	 cmp	 ecx, 13
  00020	7e 4b		 jle	 SHORT $LN2@tr_align
  00022	41 8b 48 28	 mov	 ecx, DWORD PTR [r8+40]
  00026	49 8b 40 10	 mov	 rax, QWORD PTR [r8+16]
  0002a	66 41 89 90 10
	17 00 00	 mov	 WORD PTR [r8+5904], dx
  00032	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00035	41 ff 40 28	 inc	 DWORD PTR [r8+40]
  00039	41 8b 50 28	 mov	 edx, DWORD PTR [r8+40]
  0003d	49 8b 48 10	 mov	 rcx, QWORD PTR [r8+16]
  00041	41 0f b6 80 11
	17 00 00	 movzx	 eax, BYTE PTR [r8+5905]
  00049	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0004c	b9 10 00 00 00	 mov	 ecx, 16
  00051	41 0f b7 80 14
	17 00 00	 movzx	 eax, WORD PTR [r8+5908]
  00059	41 ff 40 28	 inc	 DWORD PTR [r8+40]
  0005d	2a c8		 sub	 cl, al
  0005f	41 83 80 14 17
	00 00 f3	 add	 DWORD PTR [r8+5908], -13
  00067	66 41 d3 e9	 shr	 r9w, cl
  0006b	eb 0e		 jmp	 SHORT $LN3@tr_align
$LN2@tr_align:
  0006d	8d 41 03	 lea	 eax, DWORD PTR [rcx+3]
  00070	44 0f b7 ca	 movzx	 r9d, dx
  00074	41 89 80 14 17
	00 00		 mov	 DWORD PTR [r8+5908], eax
$LN3@tr_align:

; 900  :     send_code(s, END_BLOCK, static_ltree);

  0007b	66 45 89 88 10
	17 00 00	 mov	 WORD PTR [r8+5904], r9w
  00083	41 0f b7 d1	 movzx	 edx, r9w
  00087	41 8b 80 14 17
	00 00		 mov	 eax, DWORD PTR [r8+5908]
  0008e	83 f8 09	 cmp	 eax, 9
  00091	7e 32		 jle	 SHORT $LN4@tr_align
  00093	41 8b 48 28	 mov	 ecx, DWORD PTR [r8+40]
  00097	49 8b 40 10	 mov	 rax, QWORD PTR [r8+16]
  0009b	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  0009e	41 ff 40 28	 inc	 DWORD PTR [r8+40]
  000a2	41 8b 50 28	 mov	 edx, DWORD PTR [r8+40]
  000a6	41 0f b6 80 11
	17 00 00	 movzx	 eax, BYTE PTR [r8+5905]
  000ae	49 8b 48 10	 mov	 rcx, QWORD PTR [r8+16]
  000b2	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  000b5	41 ff 40 28	 inc	 DWORD PTR [r8+40]
  000b9	41 83 80 14 17
	00 00 f7	 add	 DWORD PTR [r8+5908], -9
  000c1	33 c0		 xor	 eax, eax
  000c3	eb 0d		 jmp	 SHORT $LN5@tr_align
$LN4@tr_align:
  000c5	83 c0 07	 add	 eax, 7
  000c8	41 89 80 14 17
	00 00		 mov	 DWORD PTR [r8+5908], eax
  000cf	0f b7 c2	 movzx	 eax, dx
$LN5@tr_align:

; 901  : #ifdef ZLIB_DEBUG
; 902  :     s->compressed_len += 10L; /* 3 for block type, 7 for EOB */
; 903  : #endif
; 904  :     bi_flush(s);

  000d2	49 8b c8	 mov	 rcx, r8
  000d5	66 41 89 80 10
	17 00 00	 mov	 WORD PTR [r8+5904], ax
  000dd	e9 00 00 00 00	 jmp	 bi_flush
_tr_align ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\daten\projekte\simulationplatform\third_party_libraries\zlib\zlib-1.2.11\trees.c
;	COMDAT tr_static_init
_TEXT	SEGMENT
tr_static_init PROC					; COMDAT

; 234  : #if defined(GEN_TREES_H) || !defined(STDC)
; 235  :     static int static_init_done = 0;
; 236  :     int n;        /* iterates over tree elements */
; 237  :     int bits;     /* bit counter */
; 238  :     int length;   /* length value */
; 239  :     int code;     /* code value */
; 240  :     int dist;     /* distance index */
; 241  :     ush bl_count[MAX_BITS+1];
; 242  :     /* number of codes at each bit length for an optimal tree */
; 243  : 
; 244  :     if (static_init_done) return;
; 245  : 
; 246  :     /* For some embedded targets, global variables are not initialized: */
; 247  : #ifdef NO_INIT_GLOBAL_POINTERS
; 248  :     static_l_desc.static_tree = static_ltree;
; 249  :     static_l_desc.extra_bits = extra_lbits;
; 250  :     static_d_desc.static_tree = static_dtree;
; 251  :     static_d_desc.extra_bits = extra_dbits;
; 252  :     static_bl_desc.extra_bits = extra_blbits;
; 253  : #endif
; 254  : 
; 255  :     /* Initialize the mapping length (0..255) -> length code (0..28) */
; 256  :     length = 0;
; 257  :     for (code = 0; code < LENGTH_CODES-1; code++) {
; 258  :         base_length[code] = length;
; 259  :         for (n = 0; n < (1<<extra_lbits[code]); n++) {
; 260  :             _length_code[length++] = (uch)code;
; 261  :         }
; 262  :     }
; 263  :     Assert (length == 256, "tr_static_init: length != 256");
; 264  :     /* Note that the length 255 (match length 258) can be represented
; 265  :      * in two different ways: code 284 + 5 bits or code 285, so we
; 266  :      * overwrite length_code[255] to use the best encoding:
; 267  :      */
; 268  :     _length_code[length-1] = (uch)code;
; 269  : 
; 270  :     /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
; 271  :     dist = 0;
; 272  :     for (code = 0 ; code < 16; code++) {
; 273  :         base_dist[code] = dist;
; 274  :         for (n = 0; n < (1<<extra_dbits[code]); n++) {
; 275  :             _dist_code[dist++] = (uch)code;
; 276  :         }
; 277  :     }
; 278  :     Assert (dist == 256, "tr_static_init: dist != 256");
; 279  :     dist >>= 7; /* from now on, all distances are divided by 128 */
; 280  :     for ( ; code < D_CODES; code++) {
; 281  :         base_dist[code] = dist << 7;
; 282  :         for (n = 0; n < (1<<(extra_dbits[code]-7)); n++) {
; 283  :             _dist_code[256 + dist++] = (uch)code;
; 284  :         }
; 285  :     }
; 286  :     Assert (dist == 256, "tr_static_init: 256+dist != 512");
; 287  : 
; 288  :     /* Construct the codes of the static literal tree */
; 289  :     for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;
; 290  :     n = 0;
; 291  :     while (n <= 143) static_ltree[n++].Len = 8, bl_count[8]++;
; 292  :     while (n <= 255) static_ltree[n++].Len = 9, bl_count[9]++;
; 293  :     while (n <= 279) static_ltree[n++].Len = 7, bl_count[7]++;
; 294  :     while (n <= 287) static_ltree[n++].Len = 8, bl_count[8]++;
; 295  :     /* Codes 286 and 287 do not exist, but we must include them in the
; 296  :      * tree construction to get a canonical Huffman tree (longest code
; 297  :      * all ones)
; 298  :      */
; 299  :     gen_codes((ct_data *)static_ltree, L_CODES+1, bl_count);
; 300  : 
; 301  :     /* The static distance tree is trivial: */
; 302  :     for (n = 0; n < D_CODES; n++) {
; 303  :         static_dtree[n].Len = 5;
; 304  :         static_dtree[n].Code = bi_reverse((unsigned)n, 5);
; 305  :     }
; 306  :     static_init_done = 1;
; 307  : 
; 308  : #  ifdef GEN_TREES_H
; 309  :     gen_trees_header();
; 310  : #  endif
; 311  : #endif /* defined(GEN_TREES_H) || !defined(STDC) */
; 312  : }

  00000	c2 00 00	 ret	 0
tr_static_init ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\daten\projekte\simulationplatform\third_party_libraries\zlib\zlib-1.2.11\trees.c
;	COMDAT init_block
_TEXT	SEGMENT
s$ = 8
init_block PROC						; COMDAT

; 409  : {

  00000	48 8d 81 bc 00
	00 00		 lea	 rax, QWORD PTR [rcx+188]
  00007	ba 1e 01 00 00	 mov	 edx, 286		; 0000011eH
  0000c	45 33 c0	 xor	 r8d, r8d
  0000f	90		 npad	 1
$LL4@init_block:

; 410  :     int n; /* iterates over tree elements */
; 411  : 
; 412  :     /* Initialize the trees. */
; 413  :     for (n = 0; n < L_CODES;  n++) s->dyn_ltree[n].Freq = 0;

  00010	66 44 89 00	 mov	 WORD PTR [rax], r8w
  00014	48 8d 40 04	 lea	 rax, QWORD PTR [rax+4]
  00018	48 83 ea 01	 sub	 rdx, 1
  0001c	75 f2		 jne	 SHORT $LL4@init_block

; 414  :     for (n = 0; n < D_CODES;  n++) s->dyn_dtree[n].Freq = 0;

  0001e	66 44 89 81 b0
	09 00 00	 mov	 WORD PTR [rcx+2480], r8w

; 415  :     for (n = 0; n < BL_CODES; n++) s->bl_tree[n].Freq = 0;
; 416  : 
; 417  :     s->dyn_ltree[END_BLOCK].Freq = 1;

  00026	b8 01 00 00 00	 mov	 eax, 1
  0002b	66 44 89 81 b4
	09 00 00	 mov	 WORD PTR [rcx+2484], r8w
  00033	66 44 89 81 b8
	09 00 00	 mov	 WORD PTR [rcx+2488], r8w
  0003b	66 44 89 81 bc
	09 00 00	 mov	 WORD PTR [rcx+2492], r8w
  00043	66 44 89 81 c0
	09 00 00	 mov	 WORD PTR [rcx+2496], r8w
  0004b	66 44 89 81 c4
	09 00 00	 mov	 WORD PTR [rcx+2500], r8w
  00053	66 44 89 81 c8
	09 00 00	 mov	 WORD PTR [rcx+2504], r8w
  0005b	66 44 89 81 cc
	09 00 00	 mov	 WORD PTR [rcx+2508], r8w
  00063	66 44 89 81 d0
	09 00 00	 mov	 WORD PTR [rcx+2512], r8w
  0006b	66 44 89 81 d4
	09 00 00	 mov	 WORD PTR [rcx+2516], r8w
  00073	66 44 89 81 d8
	09 00 00	 mov	 WORD PTR [rcx+2520], r8w
  0007b	66 44 89 81 dc
	09 00 00	 mov	 WORD PTR [rcx+2524], r8w
  00083	66 44 89 81 e0
	09 00 00	 mov	 WORD PTR [rcx+2528], r8w
  0008b	66 44 89 81 e4
	09 00 00	 mov	 WORD PTR [rcx+2532], r8w
  00093	66 44 89 81 e8
	09 00 00	 mov	 WORD PTR [rcx+2536], r8w
  0009b	66 44 89 81 ec
	09 00 00	 mov	 WORD PTR [rcx+2540], r8w
  000a3	66 44 89 81 f0
	09 00 00	 mov	 WORD PTR [rcx+2544], r8w
  000ab	66 44 89 81 f4
	09 00 00	 mov	 WORD PTR [rcx+2548], r8w
  000b3	66 44 89 81 f8
	09 00 00	 mov	 WORD PTR [rcx+2552], r8w
  000bb	66 44 89 81 fc
	09 00 00	 mov	 WORD PTR [rcx+2556], r8w
  000c3	66 44 89 81 00
	0a 00 00	 mov	 WORD PTR [rcx+2560], r8w
  000cb	66 44 89 81 04
	0a 00 00	 mov	 WORD PTR [rcx+2564], r8w
  000d3	66 44 89 81 08
	0a 00 00	 mov	 WORD PTR [rcx+2568], r8w
  000db	66 44 89 81 0c
	0a 00 00	 mov	 WORD PTR [rcx+2572], r8w
  000e3	66 44 89 81 10
	0a 00 00	 mov	 WORD PTR [rcx+2576], r8w
  000eb	66 44 89 81 14
	0a 00 00	 mov	 WORD PTR [rcx+2580], r8w
  000f3	66 44 89 81 18
	0a 00 00	 mov	 WORD PTR [rcx+2584], r8w
  000fb	66 44 89 81 1c
	0a 00 00	 mov	 WORD PTR [rcx+2588], r8w
  00103	66 44 89 81 20
	0a 00 00	 mov	 WORD PTR [rcx+2592], r8w
  0010b	66 44 89 81 24
	0a 00 00	 mov	 WORD PTR [rcx+2596], r8w
  00113	66 44 89 81 a4
	0a 00 00	 mov	 WORD PTR [rcx+2724], r8w
  0011b	66 44 89 81 a8
	0a 00 00	 mov	 WORD PTR [rcx+2728], r8w
  00123	66 44 89 81 ac
	0a 00 00	 mov	 WORD PTR [rcx+2732], r8w
  0012b	66 44 89 81 b0
	0a 00 00	 mov	 WORD PTR [rcx+2736], r8w
  00133	66 44 89 81 b4
	0a 00 00	 mov	 WORD PTR [rcx+2740], r8w
  0013b	66 44 89 81 b8
	0a 00 00	 mov	 WORD PTR [rcx+2744], r8w
  00143	66 44 89 81 bc
	0a 00 00	 mov	 WORD PTR [rcx+2748], r8w
  0014b	66 44 89 81 c0
	0a 00 00	 mov	 WORD PTR [rcx+2752], r8w
  00153	66 44 89 81 c4
	0a 00 00	 mov	 WORD PTR [rcx+2756], r8w
  0015b	66 44 89 81 c8
	0a 00 00	 mov	 WORD PTR [rcx+2760], r8w
  00163	66 44 89 81 cc
	0a 00 00	 mov	 WORD PTR [rcx+2764], r8w
  0016b	66 44 89 81 d0
	0a 00 00	 mov	 WORD PTR [rcx+2768], r8w
  00173	66 44 89 81 d4
	0a 00 00	 mov	 WORD PTR [rcx+2772], r8w
  0017b	66 44 89 81 d8
	0a 00 00	 mov	 WORD PTR [rcx+2776], r8w
  00183	66 44 89 81 dc
	0a 00 00	 mov	 WORD PTR [rcx+2780], r8w
  0018b	66 44 89 81 e0
	0a 00 00	 mov	 WORD PTR [rcx+2784], r8w
  00193	66 44 89 81 e4
	0a 00 00	 mov	 WORD PTR [rcx+2788], r8w
  0019b	66 44 89 81 e8
	0a 00 00	 mov	 WORD PTR [rcx+2792], r8w
  001a3	66 44 89 81 ec
	0a 00 00	 mov	 WORD PTR [rcx+2796], r8w
  001ab	66 89 81 bc 04
	00 00		 mov	 WORD PTR [rcx+1212], ax

; 418  :     s->opt_len = s->static_len = 0L;

  001b2	4c 89 81 00 17
	00 00		 mov	 QWORD PTR [rcx+5888], r8

; 419  :     s->last_lit = s->matches = 0;

  001b9	44 89 81 08 17
	00 00		 mov	 DWORD PTR [rcx+5896], r8d
  001c0	44 89 81 f4 16
	00 00		 mov	 DWORD PTR [rcx+5876], r8d

; 420  : }

  001c7	c3		 ret	 0
init_block ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\daten\projekte\simulationplatform\third_party_libraries\zlib\zlib-1.2.11\trees.c
;	COMDAT pqdownheap
_TEXT	SEGMENT
s$ = 16
tree$ = 24
k$ = 32
pqdownheap PROC						; COMDAT

; 455  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi

; 456  :     int v = s->heap[k];
; 457  :     int j = k << 1;  /* left son of k */
; 458  :     while (j <= s->heap_len) {

  00006	8b 81 9c 14 00
	00		 mov	 eax, DWORD PTR [rcx+5276]
  0000c	48 8b da	 mov	 rbx, rdx
  0000f	4d 63 d8	 movsxd	 r11, r8d
  00012	4a 63 bc 99 a8
	0b 00 00	 movsxd	 rdi, DWORD PTR [rcx+r11*4+2984]
  0001a	47 8d 0c 1b	 lea	 r9d, DWORD PTR [r11+r11]
  0001e	44 3b c8	 cmp	 r9d, eax
  00021	0f 8f b8 00 00
	00		 jg	 $LN17@pqdownheap
  00027	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
$LN20@pqdownheap:

; 459  :         /* Set j to the smallest of the two sons: */
; 460  :         if (j < s->heap_len &&

  0002c	7d 3a		 jge	 SHORT $LN4@pqdownheap
  0002e	49 63 c1	 movsxd	 rax, r9d
  00031	4c 63 94 81 a8
	0b 00 00	 movsxd	 r10, DWORD PTR [rcx+rax*4+2984]
  00039	4c 63 84 81 ac
	0b 00 00	 movsxd	 r8, DWORD PTR [rcx+rax*4+2988]
  00041	42 0f b7 14 93	 movzx	 edx, WORD PTR [rbx+r10*4]
  00046	42 0f b7 04 83	 movzx	 eax, WORD PTR [rbx+r8*4]
  0004b	66 3b c2	 cmp	 ax, dx
  0004e	72 15		 jb	 SHORT $LN5@pqdownheap
  00050	75 16		 jne	 SHORT $LN4@pqdownheap
  00052	41 0f b6 84 0a
	a4 14 00 00	 movzx	 eax, BYTE PTR [r10+rcx+5284]
  0005b	42 38 84 01 a4
	14 00 00	 cmp	 BYTE PTR [rcx+r8+5284], al
  00063	77 03		 ja	 SHORT $LN4@pqdownheap
$LN5@pqdownheap:

; 461  :             smaller(tree, s->heap[j+1], s->heap[j], s->depth)) {
; 462  :             j++;

  00065	41 ff c1	 inc	 r9d
$LN4@pqdownheap:

; 463  :         }
; 464  :         /* Exit if v is smaller than both sons */
; 465  :         if (smaller(tree, v, s->heap[j], s->depth)) break;

  00068	49 63 c1	 movsxd	 rax, r9d
  0006b	4c 63 94 81 a8
	0b 00 00	 movsxd	 r10, DWORD PTR [rcx+rax*4+2984]
  00073	0f b7 04 bb	 movzx	 eax, WORD PTR [rbx+rdi*4]
  00077	42 0f b7 14 93	 movzx	 edx, WORD PTR [rbx+r10*4]
  0007c	66 3b c2	 cmp	 ax, dx
  0007f	72 48		 jb	 SHORT $LN15@pqdownheap
  00081	75 12		 jne	 SHORT $LN13@pqdownheap
  00083	41 0f b6 84 0a
	a4 14 00 00	 movzx	 eax, BYTE PTR [r10+rcx+5284]
  0008c	38 84 0f a4 14
	00 00		 cmp	 BYTE PTR [rdi+rcx+5284], al
  00093	76 34		 jbe	 SHORT $LN15@pqdownheap
$LN13@pqdownheap:

; 466  : 
; 467  :         /* Exchange v with the smallest son */
; 468  :         s->heap[k] = s->heap[j];  k = j;

  00095	49 63 c3	 movsxd	 rax, r11d
  00098	4d 63 d9	 movsxd	 r11, r9d

; 469  : 
; 470  :         /* And continue down the tree, setting j to the left son of k */
; 471  :         j <<= 1;

  0009b	45 03 c9	 add	 r9d, r9d
  0009e	44 89 94 81 a8
	0b 00 00	 mov	 DWORD PTR [rcx+rax*4+2984], r10d
  000a6	8b 81 9c 14 00
	00		 mov	 eax, DWORD PTR [rcx+5276]
  000ac	44 3b c8	 cmp	 r9d, eax
  000af	0f 8e 77 ff ff
	ff		 jle	 $LN20@pqdownheap

; 472  :     }
; 473  :     s->heap[k] = v;

  000b5	48 8b 74 24 10	 mov	 rsi, QWORD PTR [rsp+16]
  000ba	42 89 bc 99 a8
	0b 00 00	 mov	 DWORD PTR [rcx+r11*4+2984], edi

; 474  : }

  000c2	48 8b 5c 24 18	 mov	 rbx, QWORD PTR [rsp+24]
  000c7	5f		 pop	 rdi
  000c8	c3		 ret	 0
$LN15@pqdownheap:
  000c9	48 8b 74 24 10	 mov	 rsi, QWORD PTR [rsp+16]

; 472  :     }
; 473  :     s->heap[k] = v;

  000ce	49 63 c3	 movsxd	 rax, r11d
  000d1	89 bc 81 a8 0b
	00 00		 mov	 DWORD PTR [rcx+rax*4+2984], edi

; 474  : }

  000d8	48 8b 5c 24 18	 mov	 rbx, QWORD PTR [rsp+24]
  000dd	5f		 pop	 rdi
  000de	c3		 ret	 0
$LN17@pqdownheap:
  000df	48 8b 5c 24 18	 mov	 rbx, QWORD PTR [rsp+24]
  000e4	42 89 bc 99 a8
	0b 00 00	 mov	 DWORD PTR [rcx+r11*4+2984], edi
  000ec	5f		 pop	 rdi
  000ed	c3		 ret	 0
pqdownheap ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\daten\projekte\simulationplatform\third_party_libraries\zlib\zlib-1.2.11\trees.c
;	COMDAT gen_bitlen
_TEXT	SEGMENT
h$1$ = 48
s$ = 48
desc$ = 56
gen_bitlen PROC						; COMDAT

; 489  : {

  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	41 55		 push	 r13
  0000a	41 57		 push	 r15

; 490  :     ct_data *tree        = desc->dyn_tree;
; 491  :     int max_code         = desc->max_code;
; 492  :     const ct_data *stree = desc->stat_desc->static_tree;

  0000c	48 8b 42 10	 mov	 rax, QWORD PTR [rdx+16]
  00010	48 8d b9 88 0b
	00 00		 lea	 rdi, QWORD PTR [rcx+2952]
  00017	48 8b 32	 mov	 rsi, QWORD PTR [rdx]
  0001a	4c 8b c1	 mov	 r8, rcx
  0001d	8b 5a 08	 mov	 ebx, DWORD PTR [rdx+8]
  00020	b9 10 00 00 00	 mov	 ecx, 16

; 493  :     const intf *extra    = desc->stat_desc->extra_bits;
; 494  :     int base             = desc->stat_desc->extra_base;
; 495  :     int max_length       = desc->stat_desc->max_length;
; 496  :     int h;              /* heap index */
; 497  :     int n, m;           /* iterate over the tree elements */
; 498  :     int bits;           /* bit length */
; 499  :     int xbits;          /* extra bits */
; 500  :     ush f;              /* frequency */
; 501  :     int overflow = 0;   /* number of elements with bit length too large */

  00025	33 d2		 xor	 edx, edx
  00027	48 8b 28	 mov	 rbp, QWORD PTR [rax]
  0002a	44 8b d2	 mov	 r10d, edx
  0002d	4c 8b 68 08	 mov	 r13, QWORD PTR [rax+8]
  00031	44 8b 78 10	 mov	 r15d, DWORD PTR [rax+16]
  00035	4c 63 48 18	 movsxd	 r9, DWORD PTR [rax+24]
  00039	0f b7 c2	 movzx	 eax, dx
  0003c	66 f3 ab	 rep stosw

; 502  : 
; 503  :     for (bits = 0; bits <= MAX_BITS; bits++) s->bl_count[bits] = 0;
; 504  : 
; 505  :     /* In a first pass, compute the optimal bit lengths (which may
; 506  :      * overflow in the case of the bit length tree).
; 507  :      */
; 508  :     tree[s->heap[s->heap_max]].Len = 0; /* root of the heap */

  0003f	49 63 80 a0 14
	00 00		 movsxd	 rax, DWORD PTR [r8+5280]

; 509  : 
; 510  :     for (h = s->heap_max+1; h < HEAP_SIZE; h++) {

  00046	bf 3d 02 00 00	 mov	 edi, 573		; 0000023dH
  0004b	49 63 8c 80 a8
	0b 00 00	 movsxd	 rcx, DWORD PTR [r8+rax*4+2984]
  00053	66 89 54 8e 02	 mov	 WORD PTR [rsi+rcx*4+2], dx
  00058	41 8b 88 a0 14
	00 00		 mov	 ecx, DWORD PTR [r8+5280]
  0005f	ff c1		 inc	 ecx
  00061	48 63 c1	 movsxd	 rax, ecx
  00064	48 3b c7	 cmp	 rax, rdi
  00067	0f 8d 93 01 00
	00		 jge	 $LN14@gen_bitlen

; 502  : 
; 503  :     for (bits = 0; bits <= MAX_BITS; bits++) s->bl_count[bits] = 0;
; 504  : 
; 505  :     /* In a first pass, compute the optimal bit lengths (which may
; 506  :      * overflow in the case of the bit length tree).
; 507  :      */
; 508  :     tree[s->heap[s->heap_max]].Len = 0; /* root of the heap */

  0006d	4c 89 64 24 38	 mov	 QWORD PTR [rsp+56], r12
  00072	48 2b f8	 sub	 rdi, rax
  00075	4c 89 74 24 40	 mov	 QWORD PTR [rsp+64], r14
  0007a	03 cf		 add	 ecx, edi
  0007c	4d 8d b0 a8 0b
	00 00		 lea	 r14, QWORD PTR [r8+2984]
  00083	89 4c 24 30	 mov	 DWORD PTR h$1$[rsp], ecx
  00087	4d 8d 34 86	 lea	 r14, QWORD PTR [r14+rax*4]
  0008b	0f 1f 44 00 00	 npad	 5
$LL7@gen_bitlen:

; 511  :         n = s->heap[h];

  00090	49 63 16	 movsxd	 rdx, DWORD PTR [r14]

; 512  :         bits = tree[tree[n].Dad].Len + 1;
; 513  :         if (bits > max_length) bits = max_length, overflow++;
; 514  :         tree[n].Len = (ush)bits;

  00093	45 8b d9	 mov	 r11d, r9d
  00096	4c 8d 24 95 00
	00 00 00	 lea	 r12, QWORD PTR [rdx*4]
  0009e	41 0f b7 44 34
	02		 movzx	 eax, WORD PTR [r12+rsi+2]
  000a4	0f b7 4c 86 02	 movzx	 ecx, WORD PTR [rsi+rax*4+2]
  000a9	41 8d 42 01	 lea	 eax, DWORD PTR [r10+1]
  000ad	ff c1		 inc	 ecx
  000af	41 3b c9	 cmp	 ecx, r9d
  000b2	44 0f 4e d9	 cmovle	 r11d, ecx
  000b6	41 0f 4e c2	 cmovle	 eax, r10d
  000ba	66 45 89 5c 34
	02		 mov	 WORD PTR [r12+rsi+2], r11w
  000c0	44 8b d0	 mov	 r10d, eax

; 515  :         /* We overwrite tree[n].Dad which is no longer needed */
; 516  : 
; 517  :         if (n > max_code) continue; /* not a leaf node */

  000c3	3b d3		 cmp	 edx, ebx
  000c5	7f 48		 jg	 SHORT $LN5@gen_bitlen

; 518  : 
; 519  :         s->bl_count[bits]++;

  000c7	49 63 c3	 movsxd	 rax, r11d

; 520  :         xbits = 0;

  000ca	33 c9		 xor	 ecx, ecx
  000cc	66 41 ff 84 40
	88 0b 00 00	 inc	 WORD PTR [r8+rax*2+2952]

; 521  :         if (n >= base) xbits = extra[n-base];

  000d5	41 3b d7	 cmp	 edx, r15d
  000d8	7c 0b		 jl	 SHORT $LN20@gen_bitlen
  000da	41 2b d7	 sub	 edx, r15d
  000dd	48 63 c2	 movsxd	 rax, edx
  000e0	41 8b 4c 85 00	 mov	 ecx, DWORD PTR [r13+rax*4]
$LN20@gen_bitlen:

; 522  :         f = tree[n].Freq;
; 523  :         s->opt_len += (ulg)f * (unsigned)(bits + xbits);

  000e5	41 0f b7 14 34	 movzx	 edx, WORD PTR [r12+rsi]
  000ea	41 8d 04 0b	 lea	 eax, DWORD PTR [r11+rcx]
  000ee	0f af c2	 imul	 eax, edx
  000f1	41 01 80 00 17
	00 00		 add	 DWORD PTR [r8+5888], eax

; 524  :         if (stree) s->static_len += (ulg)f * (unsigned)(stree[n].Len + xbits);

  000f8	48 85 ed	 test	 rbp, rbp
  000fb	74 12		 je	 SHORT $LN5@gen_bitlen
  000fd	41 0f b7 44 2c
	02		 movzx	 eax, WORD PTR [r12+rbp+2]
  00103	03 c1		 add	 eax, ecx
  00105	0f af c2	 imul	 eax, edx
  00108	41 01 80 04 17
	00 00		 add	 DWORD PTR [r8+5892], eax
$LN5@gen_bitlen:

; 509  : 
; 510  :     for (h = s->heap_max+1; h < HEAP_SIZE; h++) {

  0010f	49 83 c6 04	 add	 r14, 4
  00113	48 83 ef 01	 sub	 rdi, 1
  00117	0f 85 73 ff ff
	ff		 jne	 $LL7@gen_bitlen

; 525  :     }
; 526  :     if (overflow == 0) return;

  0011d	4c 8b 74 24 40	 mov	 r14, QWORD PTR [rsp+64]
  00122	4c 8b 64 24 38	 mov	 r12, QWORD PTR [rsp+56]
  00127	45 85 d2	 test	 r10d, r10d
  0012a	0f 84 d0 00 00
	00		 je	 $LN14@gen_bitlen
  00130	41 8d 79 ff	 lea	 edi, DWORD PTR [r9-1]
  00134	41 bb ff ff 00
	00		 mov	 r11d, 65535		; 0000ffffH
  0013a	4b 8d 14 48	 lea	 rdx, QWORD PTR [r8+r9*2]
  0013e	66 90		 npad	 2
$LL10@gen_bitlen:

; 527  : 
; 528  :     Tracev((stderr,"\nbit length overflow\n"));
; 529  :     /* This happens for example on obj2 and pic of the Calgary corpus */
; 530  : 
; 531  :     /* Find the first bit length which could increase: */
; 532  :     do {
; 533  :         bits = max_length-1;

  00140	48 63 cf	 movsxd	 rcx, edi

; 534  :         while (s->bl_count[bits] == 0) bits--;

  00143	66 41 83 bc 48
	88 0b 00 00 00	 cmp	 WORD PTR [r8+rcx*2+2952], 0
  0014d	75 12		 jne	 SHORT $LN12@gen_bitlen
  0014f	90		 npad	 1
$LL11@gen_bitlen:
  00150	ff c9		 dec	 ecx
  00152	48 63 c1	 movsxd	 rax, ecx
  00155	66 41 83 bc 40
	88 0b 00 00 00	 cmp	 WORD PTR [r8+rax*2+2952], 0
  0015f	74 ef		 je	 SHORT $LL11@gen_bitlen
$LN12@gen_bitlen:

; 535  :         s->bl_count[bits]--;      /* move one leaf down the tree */

  00161	48 63 c1	 movsxd	 rax, ecx

; 536  :         s->bl_count[bits+1] += 2; /* move one overflow item as its brother */
; 537  :         s->bl_count[max_length]--;
; 538  :         /* The brother of the overflow item also moves one step up,
; 539  :          * but this does not affect bl_count[max_length]
; 540  :          */
; 541  :         overflow -= 2;

  00164	41 83 ea 02	 sub	 r10d, 2
  00168	66 45 01 9c 40
	88 0b 00 00	 add	 WORD PTR [r8+rax*2+2952], r11w
  00171	66 41 83 84 40
	8a 0b 00 00 02	 add	 WORD PTR [r8+rax*2+2954], 2
  0017b	66 44 01 9a 88
	0b 00 00	 add	 WORD PTR [rdx+2952], r11w

; 542  :     } while (overflow > 0);

  00183	45 85 d2	 test	 r10d, r10d
  00186	7f b8		 jg	 SHORT $LL10@gen_bitlen

; 543  : 
; 544  :     /* Now recompute all bit lengths, scanning in increasing frequency.
; 545  :      * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
; 546  :      * lengths instead of fixing only the wrong ones. This idea is taken
; 547  :      * from 'ar' written by Haruhiko Okumura.)
; 548  :      */
; 549  :     for (bits = max_length; bits != 0; bits--) {

  00188	45 85 c9	 test	 r9d, r9d
  0018b	74 73		 je	 SHORT $LN14@gen_bitlen
  0018d	4c 63 5c 24 30	 movsxd	 r11, DWORD PTR h$1$[rsp]
  00192	0f 1f 40 00 66
	66 0f 1f 84 00
	00 00 00 00	 npad	 14
$LL15@gen_bitlen:

; 550  :         n = s->bl_count[bits];

  001a0	49 63 c1	 movsxd	 rax, r9d
  001a3	41 0f b7 94 40
	88 0b 00 00	 movzx	 edx, WORD PTR [r8+rax*2+2952]

; 551  :         while (n != 0) {

  001ac	85 d2		 test	 edx, edx
  001ae	74 4a		 je	 SHORT $LN13@gen_bitlen

; 550  :         n = s->bl_count[bits];

  001b0	4d 8d 90 a8 0b
	00 00		 lea	 r10, QWORD PTR [r8+2984]
  001b7	4f 8d 14 9a	 lea	 r10, QWORD PTR [r10+r11*4]
  001bb	0f 1f 44 00 00	 npad	 5
$LL16@gen_bitlen:

; 552  :             m = s->heap[--h];

  001c0	49 63 42 fc	 movsxd	 rax, DWORD PTR [r10-4]
  001c4	4d 8d 52 fc	 lea	 r10, QWORD PTR [r10-4]
  001c8	49 ff cb	 dec	 r11

; 553  :             if (m > max_code) continue;

  001cb	3b c3		 cmp	 eax, ebx
  001cd	7f 27		 jg	 SHORT $LN36@gen_bitlen

; 554  :             if ((unsigned) tree[m].Len != (unsigned) bits) {

  001cf	48 8d 3c 86	 lea	 rdi, QWORD PTR [rsi+rax*4]
  001d3	0f b7 44 86 02	 movzx	 eax, WORD PTR [rsi+rax*4+2]
  001d8	41 3b c1	 cmp	 eax, r9d
  001db	74 17		 je	 SHORT $LN24@gen_bitlen

; 555  :                 Tracev((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
; 556  :                 s->opt_len += ((ulg)bits - tree[m].Len) * tree[m].Freq;

  001dd	41 8b c9	 mov	 ecx, r9d
  001e0	2b c8		 sub	 ecx, eax
  001e2	0f b7 07	 movzx	 eax, WORD PTR [rdi]
  001e5	0f af c8	 imul	 ecx, eax
  001e8	41 01 88 00 17
	00 00		 add	 DWORD PTR [r8+5888], ecx

; 557  :                 tree[m].Len = (ush)bits;

  001ef	66 44 89 4f 02	 mov	 WORD PTR [rdi+2], r9w
$LN24@gen_bitlen:

; 558  :             }
; 559  :             n--;

  001f4	ff ca		 dec	 edx
$LN36@gen_bitlen:

; 551  :         while (n != 0) {

  001f6	85 d2		 test	 edx, edx
  001f8	75 c6		 jne	 SHORT $LL16@gen_bitlen
$LN13@gen_bitlen:

; 543  : 
; 544  :     /* Now recompute all bit lengths, scanning in increasing frequency.
; 545  :      * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
; 546  :      * lengths instead of fixing only the wrong ones. This idea is taken
; 547  :      * from 'ar' written by Haruhiko Okumura.)
; 548  :      */
; 549  :     for (bits = max_length; bits != 0; bits--) {

  001fa	41 83 e9 01	 sub	 r9d, 1
  001fe	75 a0		 jne	 SHORT $LL15@gen_bitlen
$LN14@gen_bitlen:

; 560  :         }
; 561  :     }
; 562  : }

  00200	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00205	41 5f		 pop	 r15
  00207	41 5d		 pop	 r13
  00209	5f		 pop	 rdi
  0020a	5e		 pop	 rsi
  0020b	5d		 pop	 rbp
  0020c	c3		 ret	 0
gen_bitlen ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\daten\projekte\simulationplatform\third_party_libraries\zlib\zlib-1.2.11\trees.c
;	COMDAT gen_codes
_TEXT	SEGMENT
next_code$ = 32
tree$ = 80
max_code$ = 88
bl_count$ = 96
gen_codes PROC						; COMDAT

; 576  : {

  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 577  :     ush next_code[MAX_BITS+1]; /* next code value for each bit length */
; 578  :     unsigned code = 0;         /* running code value */
; 579  :     int bits;                  /* bit index */
; 580  :     int n;                     /* code index */
; 581  : 
; 582  :     /* The distribution counts are first used to generate the code values
; 583  :      * without bit reversal.
; 584  :      */
; 585  :     for (bits = 1; bits <= MAX_BITS; bits++) {
; 586  :         code = (code + bl_count[bits-1]) << 1;

  00004	41 0f b7 00	 movzx	 eax, WORD PTR [r8]
  00008	4c 8b d1	 mov	 r10, rcx
  0000b	45 0f b7 48 02	 movzx	 r9d, WORD PTR [r8+2]
  00010	03 c0		 add	 eax, eax
  00012	41 0f b7 48 06	 movzx	 ecx, WORD PTR [r8+6]
  00017	44 03 c8	 add	 r9d, eax

; 587  :         next_code[bits] = (ush)code;

  0001a	66 89 44 24 22	 mov	 WORD PTR next_code$[rsp+2], ax
  0001f	45 03 c9	 add	 r9d, r9d
  00022	41 0f b7 40 04	 movzx	 eax, WORD PTR [r8+4]
  00027	41 03 c1	 add	 eax, r9d
  0002a	66 44 89 4c 24
	24		 mov	 WORD PTR next_code$[rsp+4], r9w
  00030	03 c0		 add	 eax, eax

; 588  :     }
; 589  :     /* Check that the bit counts in bl_count are consistent. The last code
; 590  :      * must be all ones.
; 591  :      */
; 592  :     Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
; 593  :             "inconsistent bit counts");
; 594  :     Tracev((stderr,"\ngen_codes: max_code %d ", max_code));
; 595  : 
; 596  :     for (n = 0;  n <= max_code; n++) {

  00032	4c 63 da	 movsxd	 r11, edx
  00035	03 c8		 add	 ecx, eax
  00037	66 89 44 24 26	 mov	 WORD PTR next_code$[rsp+6], ax
  0003c	41 0f b7 40 08	 movzx	 eax, WORD PTR [r8+8]
  00041	03 c9		 add	 ecx, ecx
  00043	03 c1		 add	 eax, ecx
  00045	66 89 4c 24 28	 mov	 WORD PTR next_code$[rsp+8], cx
  0004a	41 0f b7 48 0a	 movzx	 ecx, WORD PTR [r8+10]
  0004f	03 c0		 add	 eax, eax
  00051	03 c8		 add	 ecx, eax
  00053	66 89 44 24 2a	 mov	 WORD PTR next_code$[rsp+10], ax
  00058	41 0f b7 40 0c	 movzx	 eax, WORD PTR [r8+12]
  0005d	03 c9		 add	 ecx, ecx
  0005f	03 c1		 add	 eax, ecx
  00061	66 89 4c 24 2c	 mov	 WORD PTR next_code$[rsp+12], cx
  00066	41 0f b7 48 0e	 movzx	 ecx, WORD PTR [r8+14]
  0006b	03 c0		 add	 eax, eax
  0006d	03 c8		 add	 ecx, eax
  0006f	66 89 44 24 2e	 mov	 WORD PTR next_code$[rsp+14], ax
  00074	41 0f b7 40 10	 movzx	 eax, WORD PTR [r8+16]
  00079	03 c9		 add	 ecx, ecx
  0007b	03 c1		 add	 eax, ecx
  0007d	66 89 4c 24 30	 mov	 WORD PTR next_code$[rsp+16], cx
  00082	41 0f b7 48 12	 movzx	 ecx, WORD PTR [r8+18]
  00087	03 c0		 add	 eax, eax
  00089	03 c8		 add	 ecx, eax
  0008b	66 89 44 24 32	 mov	 WORD PTR next_code$[rsp+18], ax
  00090	41 0f b7 40 14	 movzx	 eax, WORD PTR [r8+20]
  00095	03 c9		 add	 ecx, ecx
  00097	03 c1		 add	 eax, ecx
  00099	66 89 4c 24 34	 mov	 WORD PTR next_code$[rsp+20], cx
  0009e	41 0f b7 48 16	 movzx	 ecx, WORD PTR [r8+22]
  000a3	03 c0		 add	 eax, eax
  000a5	03 c8		 add	 ecx, eax
  000a7	66 89 44 24 36	 mov	 WORD PTR next_code$[rsp+22], ax
  000ac	41 0f b7 40 18	 movzx	 eax, WORD PTR [r8+24]
  000b1	03 c9		 add	 ecx, ecx
  000b3	03 c1		 add	 eax, ecx
  000b5	66 89 4c 24 38	 mov	 WORD PTR next_code$[rsp+24], cx
  000ba	41 0f b7 48 1a	 movzx	 ecx, WORD PTR [r8+26]
  000bf	03 c0		 add	 eax, eax
  000c1	03 c8		 add	 ecx, eax
  000c3	66 89 44 24 3a	 mov	 WORD PTR next_code$[rsp+26], ax
  000c8	41 0f b7 40 1c	 movzx	 eax, WORD PTR [r8+28]
  000cd	03 c9		 add	 ecx, ecx
  000cf	03 c1		 add	 eax, ecx
  000d1	66 89 4c 24 3c	 mov	 WORD PTR next_code$[rsp+28], cx
  000d6	03 c0		 add	 eax, eax
  000d8	66 89 44 24 3e	 mov	 WORD PTR next_code$[rsp+30], ax
  000dd	85 d2		 test	 edx, edx
  000df	78 34		 js	 SHORT $LN6@gen_codes
  000e1	45 33 c9	 xor	 r9d, r9d
$LL7@gen_codes:

; 597  :         int len = tree[n].Len;

  000e4	43 0f b7 54 8a
	02		 movzx	 edx, WORD PTR [r10+r9*4+2]

; 598  :         if (len == 0) continue;

  000ea	85 d2		 test	 edx, edx
  000ec	74 1f		 je	 SHORT $LN5@gen_codes

; 599  :         /* Now reverse the bits */
; 600  :         tree[n].Code = (ush)bi_reverse(next_code[len]++, len);

  000ee	4c 8d 44 24 20	 lea	 r8, QWORD PTR next_code$[rsp]
  000f3	41 0f b7 0c 50	 movzx	 ecx, WORD PTR [r8+rdx*2]
  000f8	4d 8d 04 50	 lea	 r8, QWORD PTR [r8+rdx*2]
  000fc	8d 41 01	 lea	 eax, DWORD PTR [rcx+1]
  000ff	66 41 89 00	 mov	 WORD PTR [r8], ax
  00103	e8 00 00 00 00	 call	 bi_reverse
  00108	66 43 89 04 8a	 mov	 WORD PTR [r10+r9*4], ax
$LN5@gen_codes:

; 588  :     }
; 589  :     /* Check that the bit counts in bl_count are consistent. The last code
; 590  :      * must be all ones.
; 591  :      */
; 592  :     Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
; 593  :             "inconsistent bit counts");
; 594  :     Tracev((stderr,"\ngen_codes: max_code %d ", max_code));
; 595  : 
; 596  :     for (n = 0;  n <= max_code; n++) {

  0010d	49 ff c1	 inc	 r9
  00110	4d 3b cb	 cmp	 r9, r11
  00113	7e cf		 jle	 SHORT $LL7@gen_codes
$LN6@gen_codes:

; 601  : 
; 602  :         Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
; 603  :              n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
; 604  :     }
; 605  : }

  00115	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00119	c3		 ret	 0
gen_codes ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\daten\projekte\simulationplatform\third_party_libraries\zlib\zlib-1.2.11\trees.c
;	COMDAT build_tree
_TEXT	SEGMENT
s$ = 64
desc$ = 72
build_tree PROC						; COMDAT

; 618  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	41 56		 push	 r14
  00018	41 57		 push	 r15
  0001a	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 619  :     ct_data *tree         = desc->dyn_tree;
; 620  :     const ct_data *stree  = desc->stat_desc->static_tree;

  0001e	48 8b 42 10	 mov	 rax, QWORD PTR [rdx+16]

; 621  :     int elems             = desc->stat_desc->elems;
; 622  :     int n, m;          /* iterate over heap elements */
; 623  :     int max_code = -1; /* largest code with non zero frequency */
; 624  :     int node;          /* new node being created */
; 625  : 
; 626  :     /* Construct the initial heap, with least frequent element in
; 627  :      * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
; 628  :      * heap[0] is not used.
; 629  :      */
; 630  :     s->heap_len = 0, s->heap_max = HEAP_SIZE;

  00022	45 33 db	 xor	 r11d, r11d
  00025	4c 8b 32	 mov	 r14, QWORD PTR [rdx]
  00028	be ff ff ff ff	 mov	 esi, -1
  0002d	4c 8b fa	 mov	 r15, rdx
  00030	48 8b d9	 mov	 rbx, rcx
  00033	45 8b c3	 mov	 r8d, r11d

; 631  : 
; 632  :     for (n = 0; n < elems; n++) {

  00036	41 8b d3	 mov	 edx, r11d
  00039	48 63 68 14	 movsxd	 rbp, DWORD PTR [rax+20]
  0003d	4c 8b 10	 mov	 r10, QWORD PTR [rax]
  00040	44 8d 66 02	 lea	 r12d, QWORD PTR [rsi+2]
  00044	44 89 99 9c 14
	00 00		 mov	 DWORD PTR [rcx+5276], r11d
  0004b	c7 81 a0 14 00
	00 3d 02 00 00	 mov	 DWORD PTR [rcx+5280], 573 ; 0000023dH
  00055	85 ed		 test	 ebp, ebp
  00057	7e 57		 jle	 SHORT $LL5@build_tree
  00059	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@build_tree:

; 633  :         if (tree[n].Freq != 0) {

  00060	66 45 39 1c 96	 cmp	 WORD PTR [r14+rdx*4], r11w
  00065	74 25		 je	 SHORT $LN13@build_tree

; 634  :             s->heap[++(s->heap_len)] = max_code = n;

  00067	48 63 8b 9c 14
	00 00		 movsxd	 rcx, DWORD PTR [rbx+5276]
  0006e	41 8b f0	 mov	 esi, r8d
  00071	8d 41 01	 lea	 eax, DWORD PTR [rcx+1]
  00074	89 83 9c 14 00
	00		 mov	 DWORD PTR [rbx+5276], eax
  0007a	44 89 84 8b ac
	0b 00 00	 mov	 DWORD PTR [rbx+rcx*4+2988], r8d

; 635  :             s->depth[n] = 0;

  00082	44 88 9c 1a a4
	14 00 00	 mov	 BYTE PTR [rdx+rbx+5284], r11b

; 636  :         } else {

  0008a	eb 06		 jmp	 SHORT $LN2@build_tree
$LN13@build_tree:

; 637  :             tree[n].Len = 0;

  0008c	66 45 89 5c 96
	02		 mov	 WORD PTR [r14+rdx*4+2], r11w
$LN2@build_tree:

; 631  : 
; 632  :     for (n = 0; n < elems; n++) {

  00092	41 ff c0	 inc	 r8d
  00095	48 ff c2	 inc	 rdx
  00098	48 3b d5	 cmp	 rdx, rbp
  0009b	7c c3		 jl	 SHORT $LL4@build_tree

; 638  :         }
; 639  :     }
; 640  : 
; 641  :     /* The pkzip format requires that at least one distance code exists,
; 642  :      * and that at least one bit should be sent even if there is only one
; 643  :      * possible code. So to avoid special checks later on we force at least
; 644  :      * two codes of non zero frequency.
; 645  :      */
; 646  :     while (s->heap_len < 2) {

  0009d	8b 93 9c 14 00
	00		 mov	 edx, DWORD PTR [rbx+5276]
  000a3	83 fa 02	 cmp	 edx, 2
  000a6	7d 5f		 jge	 SHORT $LN6@build_tree
  000a8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL5@build_tree:

; 647  :         node = s->heap[++(s->heap_len)] = (max_code < 2 ? ++max_code : 0);

  000b0	83 fe 02	 cmp	 esi, 2
  000b3	8d 46 01	 lea	 eax, DWORD PTR [rsi+1]
  000b6	8d 4e 01	 lea	 ecx, DWORD PTR [rsi+1]
  000b9	0f 4d c6	 cmovge	 eax, esi
  000bc	41 0f 4d cb	 cmovge	 ecx, r11d
  000c0	8b f0		 mov	 esi, eax
  000c2	8d 42 01	 lea	 eax, DWORD PTR [rdx+1]
  000c5	89 83 9c 14 00
	00		 mov	 DWORD PTR [rbx+5276], eax
  000cb	48 63 c2	 movsxd	 rax, edx
  000ce	89 8c 83 ac 0b
	00 00		 mov	 DWORD PTR [rbx+rax*4+2988], ecx

; 648  :         tree[node].Freq = 1;

  000d5	48 63 c1	 movsxd	 rax, ecx
  000d8	66 45 89 24 86	 mov	 WORD PTR [r14+rax*4], r12w

; 649  :         s->depth[node] = 0;

  000dd	44 88 9c 18 a4
	14 00 00	 mov	 BYTE PTR [rax+rbx+5284], r11b

; 650  :         s->opt_len--; if (stree) s->static_len -= stree[node].Len;

  000e5	ff 8b 00 17 00
	00		 dec	 DWORD PTR [rbx+5888]
  000eb	4d 85 d2	 test	 r10, r10
  000ee	74 0c		 je	 SHORT $LN31@build_tree
  000f0	41 0f b7 44 82
	02		 movzx	 eax, WORD PTR [r10+rax*4+2]
  000f6	29 83 04 17 00
	00		 sub	 DWORD PTR [rbx+5892], eax
$LN31@build_tree:

; 638  :         }
; 639  :     }
; 640  : 
; 641  :     /* The pkzip format requires that at least one distance code exists,
; 642  :      * and that at least one bit should be sent even if there is only one
; 643  :      * possible code. So to avoid special checks later on we force at least
; 644  :      * two codes of non zero frequency.
; 645  :      */
; 646  :     while (s->heap_len < 2) {

  000fc	8b 93 9c 14 00
	00		 mov	 edx, DWORD PTR [rbx+5276]
  00102	83 fa 02	 cmp	 edx, 2
  00105	7c a9		 jl	 SHORT $LL5@build_tree
$LN6@build_tree:

; 651  :         /* node is 0 or 1 so it does not have extra bits */
; 652  :     }
; 653  :     desc->max_code = max_code;

  00107	41 89 77 08	 mov	 DWORD PTR [r15+8], esi

; 654  : 
; 655  :     /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
; 656  :      * establish sub-heaps of increasing lengths:
; 657  :      */
; 658  :     for (n = s->heap_len/2; n >= 1; n--) pqdownheap(s, tree, n);

  0010b	8b 8b 9c 14 00
	00		 mov	 ecx, DWORD PTR [rbx+5276]
  00111	8b c1		 mov	 eax, ecx
  00113	99		 cdq
  00114	2b c2		 sub	 eax, edx
  00116	d1 f8		 sar	 eax, 1
  00118	8b f8		 mov	 edi, eax
  0011a	41 3b c4	 cmp	 eax, r12d
  0011d	7c 21		 jl	 SHORT $LL12@build_tree
  0011f	90		 npad	 1
$LL9@build_tree:
  00120	44 8b c7	 mov	 r8d, edi
  00123	49 8b d6	 mov	 rdx, r14
  00126	48 8b cb	 mov	 rcx, rbx
  00129	e8 00 00 00 00	 call	 pqdownheap
  0012e	ff cf		 dec	 edi
  00130	41 3b fc	 cmp	 edi, r12d
  00133	7d eb		 jge	 SHORT $LL9@build_tree

; 650  :         s->opt_len--; if (stree) s->static_len -= stree[node].Len;

  00135	8b 8b 9c 14 00
	00		 mov	 ecx, DWORD PTR [rbx+5276]
  0013b	0f 1f 44 00 00	 npad	 5
$LL12@build_tree:

; 659  : 
; 660  :     /* Construct the Huffman tree by repeatedly combining the least two
; 661  :      * frequent nodes.
; 662  :      */
; 663  :     node = elems;              /* next internal node of the tree */
; 664  :     do {
; 665  :         pqremove(s, tree, n);  /* n = node of least frequency */

  00140	48 63 bb ac 0b
	00 00		 movsxd	 rdi, DWORD PTR [rbx+2988]
  00147	45 8b c4	 mov	 r8d, r12d
  0014a	48 63 c1	 movsxd	 rax, ecx
  0014d	49 8b d6	 mov	 rdx, r14
  00150	8b 8c 83 a8 0b
	00 00		 mov	 ecx, DWORD PTR [rbx+rax*4+2984]
  00157	89 8b ac 0b 00
	00		 mov	 DWORD PTR [rbx+2988], ecx
  0015d	48 8b cb	 mov	 rcx, rbx
  00160	ff 8b 9c 14 00
	00		 dec	 DWORD PTR [rbx+5276]
  00166	e8 00 00 00 00	 call	 pqdownheap

; 666  :         m = s->heap[SMALLEST]; /* m = node of next least frequency */

  0016b	48 63 93 ac 0b
	00 00		 movsxd	 rdx, DWORD PTR [rbx+2988]

; 667  : 
; 668  :         s->heap[--(s->heap_max)] = n; /* keep the nodes sorted by frequency */

  00172	48 63 8b a0 14
	00 00		 movsxd	 rcx, DWORD PTR [rbx+5280]

; 669  :         s->heap[--(s->heap_max)] = m;
; 670  : 
; 671  :         /* Create a new node father of n and m */
; 672  :         tree[node].Freq = tree[n].Freq + tree[m].Freq;

  00179	4c 8b c2	 mov	 r8, rdx
  0017c	4c 63 cd	 movsxd	 r9, ebp
  0017f	8d 41 ff	 lea	 eax, DWORD PTR [rcx-1]
  00182	89 83 a0 14 00
	00		 mov	 DWORD PTR [rbx+5280], eax
  00188	89 bc 8b a4 0b
	00 00		 mov	 DWORD PTR [rbx+rcx*4+2980], edi
  0018f	48 63 8b a0 14
	00 00		 movsxd	 rcx, DWORD PTR [rbx+5280]
  00196	8d 41 ff	 lea	 eax, DWORD PTR [rcx-1]
  00199	89 83 a0 14 00
	00		 mov	 DWORD PTR [rbx+5280], eax
  0019f	89 94 8b a4 0b
	00 00		 mov	 DWORD PTR [rbx+rcx*4+2980], edx

; 673  :         s->depth[node] = (uch)((s->depth[n] >= s->depth[m] ?
; 674  :                                 s->depth[n] : s->depth[m]) + 1);
; 675  :         tree[n].Dad = tree[m].Dad = (ush)node;
; 676  : #ifdef DUMP_BL_TREE
; 677  :         if (tree == s->bl_tree) {
; 678  :             fprintf(stderr,"\nnode %d(%d), sons %d(%d) %d(%d)",
; 679  :                     node, tree[node].Freq, n, tree[n].Freq, m, tree[m].Freq);
; 680  :         }
; 681  : #endif
; 682  :         /* and insert the new node in the heap */
; 683  :         s->heap[SMALLEST] = node++;
; 684  :         pqdownheap(s, tree, SMALLEST);

  001a6	48 8b cb	 mov	 rcx, rbx
  001a9	41 0f b7 04 be	 movzx	 eax, WORD PTR [r14+rdi*4]
  001ae	66 41 03 04 96	 add	 ax, WORD PTR [r14+rdx*4]
  001b3	66 43 89 04 8e	 mov	 WORD PTR [r14+r9*4], ax
  001b8	0f b6 94 1f a4
	14 00 00	 movzx	 edx, BYTE PTR [rdi+rbx+5284]
  001c0	41 0f b6 84 18
	a4 14 00 00	 movzx	 eax, BYTE PTR [r8+rbx+5284]
  001c9	3a d0		 cmp	 dl, al
  001cb	0f 42 d0	 cmovb	 edx, eax
  001ce	fe c2		 inc	 dl
  001d0	41 88 94 19 a4
	14 00 00	 mov	 BYTE PTR [r9+rbx+5284], dl
  001d8	49 8b d6	 mov	 rdx, r14
  001db	66 43 89 6c 86
	02		 mov	 WORD PTR [r14+r8*4+2], bp
  001e1	45 8b c4	 mov	 r8d, r12d
  001e4	66 41 89 6c be
	02		 mov	 WORD PTR [r14+rdi*4+2], bp
  001ea	89 ab ac 0b 00
	00		 mov	 DWORD PTR [rbx+2988], ebp
  001f0	ff c5		 inc	 ebp
  001f2	e8 00 00 00 00	 call	 pqdownheap

; 685  : 
; 686  :     } while (s->heap_len >= 2);

  001f7	8b 8b 9c 14 00
	00		 mov	 ecx, DWORD PTR [rbx+5276]
  001fd	83 f9 02	 cmp	 ecx, 2
  00200	0f 8d 3a ff ff
	ff		 jge	 $LL12@build_tree

; 687  : 
; 688  :     s->heap[--(s->heap_max)] = s->heap[SMALLEST];

  00206	4c 63 83 a0 14
	00 00		 movsxd	 r8, DWORD PTR [rbx+5280]

; 689  : 
; 690  :     /* At this point, the fields freq and dad are set. We can now
; 691  :      * generate the bit lengths.
; 692  :      */
; 693  :     gen_bitlen(s, (tree_desc *)desc);

  0020d	49 8b d7	 mov	 rdx, r15
  00210	48 8b cb	 mov	 rcx, rbx
  00213	41 8d 40 ff	 lea	 eax, DWORD PTR [r8-1]
  00217	89 83 a0 14 00
	00		 mov	 DWORD PTR [rbx+5280], eax
  0021d	8b 83 ac 0b 00
	00		 mov	 eax, DWORD PTR [rbx+2988]
  00223	42 89 84 83 a4
	0b 00 00	 mov	 DWORD PTR [rbx+r8*4+2980], eax
  0022b	e8 00 00 00 00	 call	 gen_bitlen

; 694  : 
; 695  :     /* The field len is now set, we can generate the bit codes */
; 696  :     gen_codes ((ct_data *)tree, max_code, s->bl_count);

  00230	4c 8d 83 88 0b
	00 00		 lea	 r8, QWORD PTR [rbx+2952]
  00237	8b d6		 mov	 edx, esi
  00239	49 8b ce	 mov	 rcx, r14

; 697  : }

  0023c	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00241	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00246	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  0024b	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  00250	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00254	41 5f		 pop	 r15
  00256	41 5e		 pop	 r14
  00258	41 5c		 pop	 r12

; 694  : 
; 695  :     /* The field len is now set, we can generate the bit codes */
; 696  :     gen_codes ((ct_data *)tree, max_code, s->bl_count);

  0025a	e9 00 00 00 00	 jmp	 gen_codes
build_tree ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\daten\projekte\simulationplatform\third_party_libraries\zlib\zlib-1.2.11\trees.c
;	COMDAT scan_tree
_TEXT	SEGMENT
s$ = 16
tree$ = 24
max_code$ = 32
scan_tree PROC						; COMDAT

; 707  : {

  00000	40 53		 push	 rbx

; 708  :     int n;                     /* iterates over all tree elements */
; 709  :     int prevlen = -1;          /* last emitted length */
; 710  :     int curlen;                /* length of current code */
; 711  :     int nextlen = tree[0].Len; /* length of next code */

  00002	44 0f b7 52 02	 movzx	 r10d, WORD PTR [rdx+2]

; 712  :     int count = 0;             /* repeat count of the current code */

  00007	45 33 c9	 xor	 r9d, r9d

; 713  :     int max_count = 7;         /* max repeat count */
; 714  :     int min_count = 4;         /* min repeat count */
; 715  : 
; 716  :     if (nextlen == 0) max_count = 138, min_count = 3;
; 717  :     tree[max_code+1].Len = (ush)0xffff; /* guard */

  0000a	4d 63 d8	 movsxd	 r11, r8d
  0000d	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00012	bb ff ff ff ff	 mov	 ebx, -1
  00017	66 42 89 44 9a
	06		 mov	 WORD PTR [rdx+r11*4+6], ax

; 718  : 
; 719  :     for (n = 0; n <= max_code; n++) {

  0001d	45 85 c0	 test	 r8d, r8d
  00020	0f 88 dd 00 00
	00		 js	 $LN3@scan_tree

; 713  :     int max_count = 7;         /* max repeat count */
; 714  :     int min_count = 4;         /* min repeat count */
; 715  : 
; 716  :     if (nextlen == 0) max_count = 138, min_count = 3;
; 717  :     tree[max_code+1].Len = (ush)0xffff; /* guard */

  00026	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0002b	66 45 85 d2	 test	 r10w, r10w
  0002f	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  00034	bd 07 00 00 00	 mov	 ebp, 7
  00039	41 b8 8a 00 00
	00		 mov	 r8d, 138		; 0000008aH
  0003f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00044	44 0f 45 c5	 cmovne	 r8d, ebp
  00048	48 8d 7a 06	 lea	 rdi, QWORD PTR [rdx+6]
  0004c	33 c0		 xor	 eax, eax
  0004e	49 8d 73 01	 lea	 rsi, QWORD PTR [r11+1]
  00052	66 45 85 d2	 test	 r10w, r10w
  00056	0f 95 c0	 setne	 al
  00059	83 c0 03	 add	 eax, 3
  0005c	0f 1f 40 00	 npad	 4
$LL4@scan_tree:

; 720  :         curlen = nextlen; nextlen = tree[n+1].Len;
; 721  :         if (++count < max_count && curlen == nextlen) {

  00060	41 ff c1	 inc	 r9d
  00063	41 8b d2	 mov	 edx, r10d
  00066	45 8b da	 mov	 r11d, r10d
  00069	44 0f b7 17	 movzx	 r10d, WORD PTR [rdi]
  0006d	45 3b c8	 cmp	 r9d, r8d
  00070	7d 05		 jge	 SHORT $LN6@scan_tree
  00072	41 3b d2	 cmp	 edx, r10d
  00075	74 6f		 je	 SHORT $LN2@scan_tree
$LN6@scan_tree:

; 722  :             continue;
; 723  :         } else if (count < min_count) {

  00077	44 3b c8	 cmp	 r9d, eax
  0007a	7d 0b		 jge	 SHORT $LN8@scan_tree

; 724  :             s->bl_tree[curlen].Freq += count;

  0007c	66 44 01 8c 91
	a4 0a 00 00	 add	 WORD PTR [rcx+rdx*4+2724], r9w
  00085	eb 30		 jmp	 SHORT $LN14@scan_tree
$LN8@scan_tree:

; 725  :         } else if (curlen != 0) {

  00087	85 d2		 test	 edx, edx
  00089	74 16		 je	 SHORT $LN10@scan_tree

; 726  :             if (curlen != prevlen) s->bl_tree[curlen].Freq++;

  0008b	44 3b db	 cmp	 r11d, ebx
  0008e	74 08		 je	 SHORT $LN25@scan_tree
  00090	66 ff 84 91 a4
	0a 00 00	 inc	 WORD PTR [rcx+rdx*4+2724]
$LN25@scan_tree:

; 727  :             s->bl_tree[REP_3_6].Freq++;

  00098	66 ff 81 e4 0a
	00 00		 inc	 WORD PTR [rcx+2788]
  0009f	eb 16		 jmp	 SHORT $LN14@scan_tree
$LN10@scan_tree:

; 728  :         } else if (count <= 10) {

  000a1	41 83 f9 0a	 cmp	 r9d, 10
  000a5	7f 09		 jg	 SHORT $LN13@scan_tree

; 729  :             s->bl_tree[REPZ_3_10].Freq++;

  000a7	66 ff 81 e8 0a
	00 00		 inc	 WORD PTR [rcx+2792]

; 730  :         } else {

  000ae	eb 07		 jmp	 SHORT $LN14@scan_tree
$LN13@scan_tree:

; 731  :             s->bl_tree[REPZ_11_138].Freq++;

  000b0	66 ff 81 ec 0a
	00 00		 inc	 WORD PTR [rcx+2796]
$LN14@scan_tree:

; 732  :         }
; 733  :         count = 0; prevlen = curlen;

  000b7	45 33 c9	 xor	 r9d, r9d
  000ba	41 8b db	 mov	 ebx, r11d

; 734  :         if (nextlen == 0) {

  000bd	45 85 d2	 test	 r10d, r10d
  000c0	75 0c		 jne	 SHORT $LN15@scan_tree

; 735  :             max_count = 138, min_count = 3;

  000c2	41 8d 41 03	 lea	 eax, QWORD PTR [r9+3]
  000c6	41 b8 8a 00 00
	00		 mov	 r8d, 138		; 0000008aH
  000cc	eb 18		 jmp	 SHORT $LN2@scan_tree
$LN15@scan_tree:

; 736  :         } else if (curlen == nextlen) {

  000ce	41 3b d2	 cmp	 edx, r10d
  000d1	75 0b		 jne	 SHORT $LN17@scan_tree

; 737  :             max_count = 6, min_count = 3;

  000d3	b8 03 00 00 00	 mov	 eax, 3
  000d8	44 8d 40 03	 lea	 r8d, QWORD PTR [rax+3]

; 738  :         } else {

  000dc	eb 08		 jmp	 SHORT $LN2@scan_tree
$LN17@scan_tree:

; 739  :             max_count = 7, min_count = 4;

  000de	44 8b c5	 mov	 r8d, ebp
  000e1	b8 04 00 00 00	 mov	 eax, 4
$LN2@scan_tree:

; 718  : 
; 719  :     for (n = 0; n <= max_code; n++) {

  000e6	48 83 c7 04	 add	 rdi, 4
  000ea	48 83 ee 01	 sub	 rsi, 1
  000ee	0f 85 6c ff ff
	ff		 jne	 $LL4@scan_tree
  000f4	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]
  000f9	48 8b 74 24 18	 mov	 rsi, QWORD PTR [rsp+24]
  000fe	48 8b 6c 24 10	 mov	 rbp, QWORD PTR [rsp+16]
$LN3@scan_tree:

; 740  :         }
; 741  :     }
; 742  : }

  00103	5b		 pop	 rbx
  00104	c3		 ret	 0
scan_tree ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\daten\projekte\simulationplatform\third_party_libraries\zlib\zlib-1.2.11\trees.c
;	COMDAT send_tree
_TEXT	SEGMENT
s$ = 48
tree$ = 56
max_code$ = 64
send_tree PROC						; COMDAT

; 758  :     int max_count = 7;         /* max repeat count */
; 759  :     int min_count = 4;         /* min repeat count */
; 760  : 
; 761  :     /* tree[max_code+1].Len = -1; */  /* guard already set */
; 762  :     if (nextlen == 0) max_count = 138, min_count = 3;
; 763  : 
; 764  :     for (n = 0; n <= max_code; n++) {

  00000	45 85 c0	 test	 r8d, r8d
  00003	0f 88 5a 05 00
	00		 js	 $LN46@send_tree
  00009	56		 push	 rsi
  0000a	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 753  :     int n;                     /* iterates over all tree elements */
; 754  :     int prevlen = -1;          /* last emitted length */
; 755  :     int curlen;                /* length of current code */
; 756  :     int nextlen = tree[0].Len; /* length of next code */

  0000e	0f b7 72 02	 movzx	 esi, WORD PTR [rdx+2]

; 757  :     int count = 0;             /* repeat count of the current code */

  00012	45 33 c9	 xor	 r9d, r9d

; 758  :     int max_count = 7;         /* max repeat count */
; 759  :     int min_count = 4;         /* min repeat count */
; 760  : 
; 761  :     /* tree[max_code+1].Len = -1; */  /* guard already set */
; 762  :     if (nextlen == 0) max_count = 138, min_count = 3;
; 763  : 
; 764  :     for (n = 0; n <= max_code; n++) {

  00015	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0001a	85 f6		 test	 esi, esi
  0001c	48 89 6c 24 38	 mov	 QWORD PTR [rsp+56], rbp
  00021	48 8b c1	 mov	 rax, rcx
  00024	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  00029	41 ba ff ff ff
	ff		 mov	 r10d, -1
  0002f	4c 89 64 24 18	 mov	 QWORD PTR [rsp+24], r12
  00034	4c 89 6c 24 10	 mov	 QWORD PTR [rsp+16], r13
  00039	41 bd 07 00 00
	00		 mov	 r13d, 7
  0003f	4d 63 d8	 movsxd	 r11, r8d
  00042	41 b8 8a 00 00
	00		 mov	 r8d, 138		; 0000008aH
  00048	45 0f 45 c5	 cmovne	 r8d, r13d
  0004c	4c 89 74 24 08	 mov	 QWORD PTR [rsp+8], r14
  00051	33 c9		 xor	 ecx, ecx
  00053	4c 89 3c 24	 mov	 QWORD PTR [rsp], r15
  00057	85 f6		 test	 esi, esi
  00059	4c 8d 7a 06	 lea	 r15, QWORD PTR [rdx+6]
  0005d	4d 8d 63 01	 lea	 r12, QWORD PTR [r11+1]
  00061	0f 95 c1	 setne	 cl
  00064	83 c1 03	 add	 ecx, 3
  00067	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL4@send_tree:

; 765  :         curlen = nextlen; nextlen = tree[n+1].Len;
; 766  :         if (++count < max_count && curlen == nextlen) {

  00070	41 ff c1	 inc	 r9d
  00073	8b ee		 mov	 ebp, esi
  00075	44 8b f6	 mov	 r14d, esi
  00078	41 0f b7 37	 movzx	 esi, WORD PTR [r15]
  0007c	45 3b c8	 cmp	 r9d, r8d
  0007f	7d 08		 jge	 SHORT $LN9@send_tree
  00081	3b ee		 cmp	 ebp, esi
  00083	0f 84 a5 04 00
	00		 je	 $LN2@send_tree
$LN9@send_tree:

; 767  :             continue;
; 768  :         } else if (count < min_count) {

  00089	44 3b c9	 cmp	 r9d, ecx
  0008c	0f 8d ac 00 00
	00		 jge	 $LN11@send_tree
  00092	48 8d 1c a8	 lea	 rbx, QWORD PTR [rax+rbp*4]
  00096	48 8d 3c a8	 lea	 rdi, QWORD PTR [rax+rbp*4]
  0009a	66 0f 1f 44 00
	00		 npad	 6
$LL7@send_tree:

; 769  :             do { send_code(s, curlen, s->bl_tree); } while (--count != 0);

  000a0	8b 90 14 17 00
	00		 mov	 edx, DWORD PTR [rax+5908]
  000a6	8b ca		 mov	 ecx, edx
  000a8	44 0f b7 97 a4
	0a 00 00	 movzx	 r10d, WORD PTR [rdi+2724]
  000b0	44 0f b7 9b a6
	0a 00 00	 movzx	 r11d, WORD PTR [rbx+2726]
  000b8	45 0f b7 c2	 movzx	 r8d, r10w
  000bc	66 41 d3 e0	 shl	 r8w, cl
  000c0	b9 10 00 00 00	 mov	 ecx, 16
  000c5	66 44 0b 80 10
	17 00 00	 or	 r8w, WORD PTR [rax+5904]
  000cd	41 2b cb	 sub	 ecx, r11d
  000d0	3b d1		 cmp	 edx, ecx
  000d2	7e 46		 jle	 SHORT $LN13@send_tree
  000d4	8b 50 28	 mov	 edx, DWORD PTR [rax+40]
  000d7	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  000db	66 44 89 80 10
	17 00 00	 mov	 WORD PTR [rax+5904], r8w
  000e3	44 88 04 0a	 mov	 BYTE PTR [rdx+rcx], r8b
  000e7	ff 40 28	 inc	 DWORD PTR [rax+40]
  000ea	44 8b 40 28	 mov	 r8d, DWORD PTR [rax+40]
  000ee	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  000f2	0f b6 88 11 17
	00 00		 movzx	 ecx, BYTE PTR [rax+5905]
  000f9	41 88 0c 10	 mov	 BYTE PTR [r8+rdx], cl
  000fd	b9 10 00 00 00	 mov	 ecx, 16
  00102	2a 88 14 17 00
	00		 sub	 cl, BYTE PTR [rax+5908]
  00108	ff 40 28	 inc	 DWORD PTR [rax+40]
  0010b	8b 90 14 17 00
	00		 mov	 edx, DWORD PTR [rax+5908]
  00111	66 41 d3 ea	 shr	 r10w, cl
  00115	83 c2 f0	 add	 edx, -16
  00118	eb 04		 jmp	 SHORT $LN47@send_tree
$LN13@send_tree:
  0011a	45 0f b7 d0	 movzx	 r10d, r8w
$LN47@send_tree:
  0011e	41 03 d3	 add	 edx, r11d
  00121	89 90 14 17 00
	00		 mov	 DWORD PTR [rax+5908], edx
  00127	66 44 89 90 10
	17 00 00	 mov	 WORD PTR [rax+5904], r10w
  0012f	41 83 e9 01	 sub	 r9d, 1
  00133	0f 85 67 ff ff
	ff		 jne	 $LL7@send_tree

; 770  : 
; 771  :         } else if (curlen != 0) {

  00139	e9 c4 03 00 00	 jmp	 $LN33@send_tree
$LN11@send_tree:
  0013e	85 ed		 test	 ebp, ebp
  00140	0f 84 ad 01 00
	00		 je	 $LN15@send_tree

; 772  :             if (curlen != prevlen) {

  00146	45 3b f2	 cmp	 r14d, r10d
  00149	0f 84 94 00 00
	00		 je	 $LN17@send_tree

; 773  :                 send_code(s, curlen, s->bl_tree); count--;

  0014f	8b 90 14 17 00
	00		 mov	 edx, DWORD PTR [rax+5908]
  00155	8b ca		 mov	 ecx, edx
  00157	44 0f b7 94 a8
	a4 0a 00 00	 movzx	 r10d, WORD PTR [rax+rbp*4+2724]
  00160	44 0f b7 9c a8
	a6 0a 00 00	 movzx	 r11d, WORD PTR [rax+rbp*4+2726]
  00169	45 0f b7 c2	 movzx	 r8d, r10w
  0016d	66 41 d3 e0	 shl	 r8w, cl
  00171	b9 10 00 00 00	 mov	 ecx, 16
  00176	66 44 0b 80 10
	17 00 00	 or	 r8w, WORD PTR [rax+5904]
  0017e	41 2b cb	 sub	 ecx, r11d
  00181	3b d1		 cmp	 edx, ecx
  00183	7e 46		 jle	 SHORT $LN18@send_tree
  00185	8b 50 28	 mov	 edx, DWORD PTR [rax+40]
  00188	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  0018c	66 44 89 80 10
	17 00 00	 mov	 WORD PTR [rax+5904], r8w
  00194	44 88 04 0a	 mov	 BYTE PTR [rdx+rcx], r8b
  00198	ff 40 28	 inc	 DWORD PTR [rax+40]
  0019b	44 8b 40 28	 mov	 r8d, DWORD PTR [rax+40]
  0019f	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  001a3	0f b6 88 11 17
	00 00		 movzx	 ecx, BYTE PTR [rax+5905]
  001aa	41 88 0c 10	 mov	 BYTE PTR [r8+rdx], cl
  001ae	b9 10 00 00 00	 mov	 ecx, 16
  001b3	2a 88 14 17 00
	00		 sub	 cl, BYTE PTR [rax+5908]
  001b9	ff 40 28	 inc	 DWORD PTR [rax+40]
  001bc	8b 90 14 17 00
	00		 mov	 edx, DWORD PTR [rax+5908]
  001c2	66 41 d3 ea	 shr	 r10w, cl
  001c6	83 c2 f0	 add	 edx, -16
  001c9	eb 04		 jmp	 SHORT $LN48@send_tree
$LN18@send_tree:
  001cb	45 0f b7 d0	 movzx	 r10d, r8w
$LN48@send_tree:
  001cf	41 03 d3	 add	 edx, r11d
  001d2	89 90 14 17 00
	00		 mov	 DWORD PTR [rax+5908], edx
  001d8	41 ff c9	 dec	 r9d
  001db	66 44 89 90 10
	17 00 00	 mov	 WORD PTR [rax+5904], r10w
$LN17@send_tree:

; 774  :             }
; 775  :             Assert(count >= 3 && count <= 6, " 3_6?");
; 776  :             send_code(s, REP_3_6, s->bl_tree); send_bits(s, count-3, 2);

  001e3	8b 90 14 17 00
	00		 mov	 edx, DWORD PTR [rax+5908]
  001e9	8b ca		 mov	 ecx, edx
  001eb	44 0f b7 90 e4
	0a 00 00	 movzx	 r10d, WORD PTR [rax+2788]
  001f3	44 0f b7 98 e6
	0a 00 00	 movzx	 r11d, WORD PTR [rax+2790]
  001fb	45 0f b7 c2	 movzx	 r8d, r10w
  001ff	66 41 d3 e0	 shl	 r8w, cl
  00203	b9 10 00 00 00	 mov	 ecx, 16
  00208	66 44 0b 80 10
	17 00 00	 or	 r8w, WORD PTR [rax+5904]
  00210	41 2b cb	 sub	 ecx, r11d
  00213	3b d1		 cmp	 edx, ecx
  00215	7e 47		 jle	 SHORT $LN20@send_tree
  00217	8b 50 28	 mov	 edx, DWORD PTR [rax+40]
  0021a	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  0021e	66 44 89 80 10
	17 00 00	 mov	 WORD PTR [rax+5904], r8w
  00226	44 88 04 0a	 mov	 BYTE PTR [rdx+rcx], r8b
  0022a	ff 40 28	 inc	 DWORD PTR [rax+40]
  0022d	44 8b 40 28	 mov	 r8d, DWORD PTR [rax+40]
  00231	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  00235	0f b6 88 11 17
	00 00		 movzx	 ecx, BYTE PTR [rax+5905]
  0023c	41 88 0c 10	 mov	 BYTE PTR [r8+rdx], cl
  00240	b9 10 00 00 00	 mov	 ecx, 16
  00245	2a 88 14 17 00
	00		 sub	 cl, BYTE PTR [rax+5908]
  0024b	41 8d 53 f0	 lea	 edx, DWORD PTR [r11-16]
  0024f	ff 40 28	 inc	 DWORD PTR [rax+40]
  00252	66 41 d3 ea	 shr	 r10w, cl
  00256	03 90 14 17 00
	00		 add	 edx, DWORD PTR [rax+5908]
  0025c	eb 07		 jmp	 SHORT $LN21@send_tree
$LN20@send_tree:
  0025e	45 0f b7 d0	 movzx	 r10d, r8w
  00262	41 03 d3	 add	 edx, r11d
$LN21@send_tree:
  00265	89 90 14 17 00
	00		 mov	 DWORD PTR [rax+5908], edx
  0026b	66 41 83 e9 03	 sub	 r9w, 3
  00270	66 44 89 90 10
	17 00 00	 mov	 WORD PTR [rax+5904], r10w
  00278	8b 90 14 17 00
	00		 mov	 edx, DWORD PTR [rax+5908]
  0027e	83 fa 0e	 cmp	 edx, 14
  00281	7e 58		 jle	 SHORT $LN22@send_tree
  00283	8b ca		 mov	 ecx, edx
  00285	45 0f b7 c1	 movzx	 r8d, r9w
  00289	8b 50 28	 mov	 edx, DWORD PTR [rax+40]
  0028c	66 41 d3 e0	 shl	 r8w, cl
  00290	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00294	66 45 0b c2	 or	 r8w, r10w
  00298	66 44 89 80 10
	17 00 00	 mov	 WORD PTR [rax+5904], r8w
  002a0	44 88 04 0a	 mov	 BYTE PTR [rdx+rcx], r8b
  002a4	ff 40 28	 inc	 DWORD PTR [rax+40]
  002a7	44 8b 40 28	 mov	 r8d, DWORD PTR [rax+40]
  002ab	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  002af	0f b6 88 11 17
	00 00		 movzx	 ecx, BYTE PTR [rax+5905]
  002b6	41 88 0c 10	 mov	 BYTE PTR [r8+rdx], cl
  002ba	b9 10 00 00 00	 mov	 ecx, 16
  002bf	0f b7 90 14 17
	00 00		 movzx	 edx, WORD PTR [rax+5908]
  002c6	ff 40 28	 inc	 DWORD PTR [rax+40]
  002c9	2a ca		 sub	 cl, dl
  002cb	83 80 14 17 00
	00 f2		 add	 DWORD PTR [rax+5908], -14
  002d2	66 41 d3 e9	 shr	 r9w, cl
  002d6	e9 1f 02 00 00	 jmp	 $LN23@send_tree
$LN22@send_tree:
  002db	8d 4a 02	 lea	 ecx, DWORD PTR [rdx+2]
$LN49@send_tree:

; 783  :         }
; 784  :         count = 0; prevlen = curlen;

  002de	89 88 14 17 00
	00		 mov	 DWORD PTR [rax+5908], ecx
  002e4	8b ca		 mov	 ecx, edx
  002e6	66 41 d3 e1	 shl	 r9w, cl
  002ea	66 45 0b ca	 or	 r9w, r10w
  002ee	e9 07 02 00 00	 jmp	 $LN23@send_tree
$LN15@send_tree:

; 777  : 
; 778  :         } else if (count <= 10) {

  002f3	8b 90 14 17 00
	00		 mov	 edx, DWORD PTR [rax+5908]
  002f9	8b ca		 mov	 ecx, edx
  002fb	41 83 f9 0a	 cmp	 r9d, 10
  002ff	0f 8f f8 00 00
	00		 jg	 $LN24@send_tree

; 779  :             send_code(s, REPZ_3_10, s->bl_tree); send_bits(s, count-3, 3);

  00305	44 0f b7 90 e8
	0a 00 00	 movzx	 r10d, WORD PTR [rax+2792]
  0030d	44 0f b7 98 ea
	0a 00 00	 movzx	 r11d, WORD PTR [rax+2794]
  00315	45 0f b7 c2	 movzx	 r8d, r10w
  00319	66 41 d3 e0	 shl	 r8w, cl
  0031d	b9 10 00 00 00	 mov	 ecx, 16
  00322	66 44 0b 80 10
	17 00 00	 or	 r8w, WORD PTR [rax+5904]
  0032a	41 2b cb	 sub	 ecx, r11d
  0032d	3b d1		 cmp	 edx, ecx
  0032f	7e 47		 jle	 SHORT $LN26@send_tree
  00331	8b 50 28	 mov	 edx, DWORD PTR [rax+40]
  00334	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00338	66 44 89 80 10
	17 00 00	 mov	 WORD PTR [rax+5904], r8w
  00340	44 88 04 0a	 mov	 BYTE PTR [rdx+rcx], r8b
  00344	ff 40 28	 inc	 DWORD PTR [rax+40]
  00347	44 8b 40 28	 mov	 r8d, DWORD PTR [rax+40]
  0034b	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  0034f	0f b6 88 11 17
	00 00		 movzx	 ecx, BYTE PTR [rax+5905]
  00356	41 88 0c 10	 mov	 BYTE PTR [r8+rdx], cl
  0035a	b9 10 00 00 00	 mov	 ecx, 16
  0035f	2a 88 14 17 00
	00		 sub	 cl, BYTE PTR [rax+5908]
  00365	41 8d 53 f0	 lea	 edx, DWORD PTR [r11-16]
  00369	ff 40 28	 inc	 DWORD PTR [rax+40]
  0036c	66 41 d3 ea	 shr	 r10w, cl
  00370	03 90 14 17 00
	00		 add	 edx, DWORD PTR [rax+5908]
  00376	eb 07		 jmp	 SHORT $LN27@send_tree
$LN26@send_tree:
  00378	45 0f b7 d0	 movzx	 r10d, r8w
  0037c	41 03 d3	 add	 edx, r11d
$LN27@send_tree:
  0037f	89 90 14 17 00
	00		 mov	 DWORD PTR [rax+5908], edx
  00385	66 41 83 e9 03	 sub	 r9w, 3
  0038a	66 44 89 90 10
	17 00 00	 mov	 WORD PTR [rax+5904], r10w
  00392	8b 90 14 17 00
	00		 mov	 edx, DWORD PTR [rax+5908]
  00398	83 fa 0d	 cmp	 edx, 13
  0039b	7e 58		 jle	 SHORT $LN28@send_tree
  0039d	8b ca		 mov	 ecx, edx
  0039f	45 0f b7 c1	 movzx	 r8d, r9w
  003a3	8b 50 28	 mov	 edx, DWORD PTR [rax+40]
  003a6	66 41 d3 e0	 shl	 r8w, cl
  003aa	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  003ae	66 45 0b c2	 or	 r8w, r10w
  003b2	66 44 89 80 10
	17 00 00	 mov	 WORD PTR [rax+5904], r8w
  003ba	44 88 04 0a	 mov	 BYTE PTR [rdx+rcx], r8b
  003be	ff 40 28	 inc	 DWORD PTR [rax+40]
  003c1	44 8b 40 28	 mov	 r8d, DWORD PTR [rax+40]
  003c5	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  003c9	0f b6 88 11 17
	00 00		 movzx	 ecx, BYTE PTR [rax+5905]
  003d0	41 88 0c 10	 mov	 BYTE PTR [r8+rdx], cl
  003d4	b9 10 00 00 00	 mov	 ecx, 16
  003d9	0f b7 90 14 17
	00 00		 movzx	 edx, WORD PTR [rax+5908]
  003e0	ff 40 28	 inc	 DWORD PTR [rax+40]
  003e3	2a ca		 sub	 cl, dl
  003e5	83 80 14 17 00
	00 f3		 add	 DWORD PTR [rax+5908], -13
  003ec	66 41 d3 e9	 shr	 r9w, cl
  003f0	e9 05 01 00 00	 jmp	 $LN23@send_tree
$LN28@send_tree:
  003f5	8d 4a 03	 lea	 ecx, DWORD PTR [rdx+3]

; 780  : 
; 781  :         } else {

  003f8	e9 e1 fe ff ff	 jmp	 $LN49@send_tree
$LN24@send_tree:

; 782  :             send_code(s, REPZ_11_138, s->bl_tree); send_bits(s, count-11, 7);

  003fd	44 0f b7 90 ec
	0a 00 00	 movzx	 r10d, WORD PTR [rax+2796]
  00405	44 0f b7 98 ee
	0a 00 00	 movzx	 r11d, WORD PTR [rax+2798]
  0040d	45 0f b7 c2	 movzx	 r8d, r10w
  00411	66 41 d3 e0	 shl	 r8w, cl
  00415	b9 10 00 00 00	 mov	 ecx, 16
  0041a	66 44 0b 80 10
	17 00 00	 or	 r8w, WORD PTR [rax+5904]
  00422	41 2b cb	 sub	 ecx, r11d
  00425	3b d1		 cmp	 edx, ecx
  00427	7e 47		 jle	 SHORT $LN30@send_tree
  00429	8b 50 28	 mov	 edx, DWORD PTR [rax+40]
  0042c	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00430	66 44 89 80 10
	17 00 00	 mov	 WORD PTR [rax+5904], r8w
  00438	44 88 04 0a	 mov	 BYTE PTR [rdx+rcx], r8b
  0043c	ff 40 28	 inc	 DWORD PTR [rax+40]
  0043f	44 8b 40 28	 mov	 r8d, DWORD PTR [rax+40]
  00443	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  00447	0f b6 88 11 17
	00 00		 movzx	 ecx, BYTE PTR [rax+5905]
  0044e	41 88 0c 10	 mov	 BYTE PTR [r8+rdx], cl
  00452	b9 10 00 00 00	 mov	 ecx, 16
  00457	2a 88 14 17 00
	00		 sub	 cl, BYTE PTR [rax+5908]
  0045d	41 8d 53 f0	 lea	 edx, DWORD PTR [r11-16]
  00461	ff 40 28	 inc	 DWORD PTR [rax+40]
  00464	66 41 d3 ea	 shr	 r10w, cl
  00468	03 90 14 17 00
	00		 add	 edx, DWORD PTR [rax+5908]
  0046e	eb 07		 jmp	 SHORT $LN31@send_tree
$LN30@send_tree:
  00470	45 0f b7 d0	 movzx	 r10d, r8w
  00474	41 03 d3	 add	 edx, r11d
$LN31@send_tree:
  00477	89 90 14 17 00
	00		 mov	 DWORD PTR [rax+5908], edx
  0047d	66 41 83 e9 0b	 sub	 r9w, 11
  00482	66 44 89 90 10
	17 00 00	 mov	 WORD PTR [rax+5904], r10w
  0048a	41 0f b7 d2	 movzx	 edx, r10w
  0048e	8b 88 14 17 00
	00		 mov	 ecx, DWORD PTR [rax+5908]
  00494	83 f9 09	 cmp	 ecx, 9
  00497	7e 50		 jle	 SHORT $LN32@send_tree
  00499	45 0f b7 c1	 movzx	 r8d, r9w
  0049d	66 41 d3 e0	 shl	 r8w, cl
  004a1	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  004a5	66 44 0b c2	 or	 r8w, dx
  004a9	8b 50 28	 mov	 edx, DWORD PTR [rax+40]
  004ac	66 44 89 80 10
	17 00 00	 mov	 WORD PTR [rax+5904], r8w
  004b4	44 88 04 0a	 mov	 BYTE PTR [rdx+rcx], r8b
  004b8	ff 40 28	 inc	 DWORD PTR [rax+40]
  004bb	44 8b 40 28	 mov	 r8d, DWORD PTR [rax+40]
  004bf	0f b6 88 11 17
	00 00		 movzx	 ecx, BYTE PTR [rax+5905]
  004c6	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  004ca	41 88 0c 10	 mov	 BYTE PTR [r8+rdx], cl
  004ce	b9 10 00 00 00	 mov	 ecx, 16
  004d3	2a 88 14 17 00
	00		 sub	 cl, BYTE PTR [rax+5908]
  004d9	ff 40 28	 inc	 DWORD PTR [rax+40]
  004dc	66 41 d3 e9	 shr	 r9w, cl
  004e0	83 80 14 17 00
	00 f7		 add	 DWORD PTR [rax+5908], -9
  004e7	eb 11		 jmp	 SHORT $LN23@send_tree
$LN32@send_tree:
  004e9	66 41 d3 e1	 shl	 r9w, cl
  004ed	66 44 0b ca	 or	 r9w, dx
  004f1	41 03 cd	 add	 ecx, r13d
  004f4	89 88 14 17 00
	00		 mov	 DWORD PTR [rax+5908], ecx
$LN23@send_tree:

; 783  :         }
; 784  :         count = 0; prevlen = curlen;

  004fa	66 44 89 88 10
	17 00 00	 mov	 WORD PTR [rax+5904], r9w
$LN33@send_tree:
  00502	45 33 c9	 xor	 r9d, r9d
  00505	45 8b d6	 mov	 r10d, r14d

; 785  :         if (nextlen == 0) {

  00508	85 f6		 test	 esi, esi
  0050a	75 0b		 jne	 SHORT $LN34@send_tree

; 786  :             max_count = 138, min_count = 3;

  0050c	8d 4e 03	 lea	 ecx, QWORD PTR [rsi+3]
  0050f	41 b8 8a 00 00
	00		 mov	 r8d, 138		; 0000008aH
  00515	eb 17		 jmp	 SHORT $LN2@send_tree
$LN34@send_tree:

; 787  :         } else if (curlen == nextlen) {

  00517	3b ee		 cmp	 ebp, esi
  00519	75 0b		 jne	 SHORT $LN36@send_tree

; 788  :             max_count = 6, min_count = 3;

  0051b	b9 03 00 00 00	 mov	 ecx, 3
  00520	44 8d 41 03	 lea	 r8d, QWORD PTR [rcx+3]

; 789  :         } else {

  00524	eb 08		 jmp	 SHORT $LN2@send_tree
$LN36@send_tree:

; 790  :             max_count = 7, min_count = 4;

  00526	45 8b c5	 mov	 r8d, r13d
  00529	b9 04 00 00 00	 mov	 ecx, 4
$LN2@send_tree:

; 758  :     int max_count = 7;         /* max repeat count */
; 759  :     int min_count = 4;         /* min repeat count */
; 760  : 
; 761  :     /* tree[max_code+1].Len = -1; */  /* guard already set */
; 762  :     if (nextlen == 0) max_count = 138, min_count = 3;
; 763  : 
; 764  :     for (n = 0; n <= max_code; n++) {

  0052e	49 83 c7 04	 add	 r15, 4
  00532	49 83 ec 01	 sub	 r12, 1
  00536	0f 85 34 fb ff
	ff		 jne	 $LL4@send_tree
  0053c	4c 8b 3c 24	 mov	 r15, QWORD PTR [rsp]
  00540	4c 8b 74 24 08	 mov	 r14, QWORD PTR [rsp+8]
  00545	4c 8b 6c 24 10	 mov	 r13, QWORD PTR [rsp+16]
  0054a	4c 8b 64 24 18	 mov	 r12, QWORD PTR [rsp+24]
  0054f	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  00554	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00559	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 791  :         }
; 792  :     }
; 793  : }

  0055e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00562	5e		 pop	 rsi
$LN46@send_tree:
  00563	c3		 ret	 0
send_tree ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\daten\projekte\simulationplatform\third_party_libraries\zlib\zlib-1.2.11\trees.c
;	COMDAT build_bl_tree
_TEXT	SEGMENT
s$ = 48
build_bl_tree PROC					; COMDAT

; 801  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 802  :     int max_blindex;  /* index of last bit length code of non zero freq */
; 803  : 
; 804  :     /* Determine the bit length frequencies for literal and distance trees */
; 805  :     scan_tree(s, (ct_data *)s->dyn_ltree, s->l_desc.max_code);

  00006	44 8b 81 48 0b
	00 00		 mov	 r8d, DWORD PTR [rcx+2888]
  0000d	48 8d 91 bc 00
	00 00		 lea	 rdx, QWORD PTR [rcx+188]
  00014	48 8b d9	 mov	 rbx, rcx
  00017	e8 00 00 00 00	 call	 scan_tree

; 806  :     scan_tree(s, (ct_data *)s->dyn_dtree, s->d_desc.max_code);

  0001c	44 8b 81 60 0b
	00 00		 mov	 r8d, DWORD PTR [rcx+2912]
  00023	48 8d 91 b0 09
	00 00		 lea	 rdx, QWORD PTR [rcx+2480]
  0002a	e8 00 00 00 00	 call	 scan_tree

; 807  : 
; 808  :     /* Build the bit length tree: */
; 809  :     build_tree(s, (tree_desc *)(&(s->bl_desc)));

  0002f	48 8d 91 70 0b
	00 00		 lea	 rdx, QWORD PTR [rcx+2928]
  00036	e8 00 00 00 00	 call	 build_tree

; 810  :     /* opt_len now includes the length of the tree representations, except
; 811  :      * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
; 812  :      */
; 813  : 
; 814  :     /* Determine the number of bit length codes to send. The pkzip format
; 815  :      * requires that at least 4 bit length codes be sent. (appnote.txt says
; 816  :      * 3 but the actual value used is 4.)
; 817  :      */
; 818  :     for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {

  0003b	ba 12 00 00 00	 mov	 edx, 18
  00040	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:bl_order
  00047	8b c2		 mov	 eax, edx
  00049	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@build_bl_t:

; 819  :         if (s->bl_tree[bl_order[max_blindex]].Len != 0) break;

  00050	42 0f b6 0c 00	 movzx	 ecx, BYTE PTR [rax+r8]
  00055	66 83 bc 8b a6
	0a 00 00 00	 cmp	 WORD PTR [rbx+rcx*4+2726], 0
  0005e	75 4e		 jne	 SHORT $LN14@build_bl_t
  00060	42 0f b6 4c 00
	ff		 movzx	 ecx, BYTE PTR [rax+r8-1]
  00066	66 83 bc 8b a6
	0a 00 00 00	 cmp	 WORD PTR [rbx+rcx*4+2726], 0
  0006f	75 3b		 jne	 SHORT $LN11@build_bl_t
  00071	42 0f b6 4c 00
	fe		 movzx	 ecx, BYTE PTR [rax+r8-2]
  00077	66 83 bc 8b a6
	0a 00 00 00	 cmp	 WORD PTR [rbx+rcx*4+2726], 0
  00080	75 25		 jne	 SHORT $LN12@build_bl_t
  00082	42 0f b6 4c 00
	fd		 movzx	 ecx, BYTE PTR [rax+r8-3]
  00088	66 83 bc 8b a6
	0a 00 00 00	 cmp	 WORD PTR [rbx+rcx*4+2726], 0
  00091	75 0f		 jne	 SHORT $LN13@build_bl_t

; 810  :     /* opt_len now includes the length of the tree representations, except
; 811  :      * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
; 812  :      */
; 813  : 
; 814  :     /* Determine the number of bit length codes to send. The pkzip format
; 815  :      * requires that at least 4 bit length codes be sent. (appnote.txt says
; 816  :      * 3 but the actual value used is 4.)
; 817  :      */
; 818  :     for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {

  00093	48 83 e8 04	 sub	 rax, 4
  00097	83 ea 04	 sub	 edx, 4
  0009a	48 83 f8 03	 cmp	 rax, 3
  0009e	7d b0		 jge	 SHORT $LL4@build_bl_t
  000a0	eb 0c		 jmp	 SHORT $LN14@build_bl_t
$LN13@build_bl_t:

; 819  :         if (s->bl_tree[bl_order[max_blindex]].Len != 0) break;

  000a2	83 ea 03	 sub	 edx, 3
  000a5	eb 07		 jmp	 SHORT $LN14@build_bl_t
$LN12@build_bl_t:
  000a7	83 ea 02	 sub	 edx, 2
  000aa	eb 02		 jmp	 SHORT $LN14@build_bl_t
$LN11@build_bl_t:
  000ac	ff ca		 dec	 edx
$LN14@build_bl_t:

; 820  :     }
; 821  :     /* Update opt_len to include the bit length tree and counts */
; 822  :     s->opt_len += 3*((ulg)max_blindex+1) + 5+5+4;

  000ae	8d 0c 55 11 00
	00 00		 lea	 ecx, DWORD PTR [rdx*2+17]

; 823  :     Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
; 824  :             s->opt_len, s->static_len));
; 825  : 
; 826  :     return max_blindex;

  000b5	8b c2		 mov	 eax, edx
  000b7	03 ca		 add	 ecx, edx
  000b9	01 8b 00 17 00
	00		 add	 DWORD PTR [rbx+5888], ecx

; 827  : }

  000bf	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c3	5b		 pop	 rbx
  000c4	c3		 ret	 0
build_bl_tree ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\daten\projekte\simulationplatform\third_party_libraries\zlib\zlib-1.2.11\trees.c
;	COMDAT send_all_trees
_TEXT	SEGMENT
s$ = 48
lcodes$ = 56
dcodes$ = 64
blcodes$ = 72
send_all_trees PROC					; COMDAT

; 837  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b d9	 mov	 rbx, rcx
  00012	45 8b d9	 mov	 r11d, r9d

; 838  :     int rank;                    /* index in bl_order */
; 839  : 
; 840  :     Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
; 841  :     Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
; 842  :             "too many codes");
; 843  :     Tracev((stderr, "\nbl counts: "));
; 844  :     send_bits(s, lcodes-257, 5); /* not +255 as stated in appnote.txt */

  00015	8b 89 14 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5908]
  0001b	8b f2		 mov	 esi, edx
  0001d	41 8b f8	 mov	 edi, r8d
  00020	44 0f b7 c6	 movzx	 r8d, si
  00024	4c 8d 93 10 17
	00 00		 lea	 r10, QWORD PTR [rbx+5904]
  0002b	45 0f b7 0a	 movzx	 r9d, WORD PTR [r10]
  0002f	83 f9 0b	 cmp	 ecx, 11
  00032	7e 52		 jle	 SHORT $LN5@send_all_t
  00034	b8 01 01 00 00	 mov	 eax, 257		; 00000101H
  00039	66 44 2b c0	 sub	 r8w, ax
  0003d	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  00041	41 0f b7 d0	 movzx	 edx, r8w
  00045	66 d3 e2	 shl	 dx, cl
  00048	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]
  0004b	66 41 0b d1	 or	 dx, r9w
  0004f	66 41 89 12	 mov	 WORD PTR [r10], dx
  00053	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00056	ff 43 28	 inc	 DWORD PTR [rbx+40]
  00059	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]
  0005c	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  00060	41 0f b6 42 01	 movzx	 eax, BYTE PTR [r10+1]
  00065	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00068	b9 10 00 00 00	 mov	 ecx, 16
  0006d	0f b7 83 14 17
	00 00		 movzx	 eax, WORD PTR [rbx+5908]
  00074	ff 43 28	 inc	 DWORD PTR [rbx+40]
  00077	2a c8		 sub	 cl, al
  00079	83 83 14 17 00
	00 f5		 add	 DWORD PTR [rbx+5908], -11
  00080	66 41 d3 e8	 shr	 r8w, cl
  00084	eb 1a		 jmp	 SHORT $LN6@send_all_t
$LN5@send_all_t:
  00086	8d 41 05	 lea	 eax, DWORD PTR [rcx+5]
  00089	89 83 14 17 00
	00		 mov	 DWORD PTR [rbx+5908], eax
  0008f	b8 01 01 00 00	 mov	 eax, 257		; 00000101H
  00094	66 44 2b c0	 sub	 r8w, ax
  00098	66 41 d3 e0	 shl	 r8w, cl
  0009c	66 45 0b c1	 or	 r8w, r9w
$LN6@send_all_t:

; 845  :     send_bits(s, dcodes-1,   5);

  000a0	66 45 89 02	 mov	 WORD PTR [r10], r8w
  000a4	45 0f b7 c8	 movzx	 r9d, r8w
  000a8	8b 8b 14 17 00
	00		 mov	 ecx, DWORD PTR [rbx+5908]
  000ae	44 8d 47 ff	 lea	 r8d, DWORD PTR [rdi-1]
  000b2	83 f9 0b	 cmp	 ecx, 11
  000b5	7e 49		 jle	 SHORT $LN7@send_all_t
  000b7	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  000bb	41 0f b7 d0	 movzx	 edx, r8w
  000bf	66 d3 e2	 shl	 dx, cl
  000c2	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]
  000c5	66 41 0b d1	 or	 dx, r9w
  000c9	66 41 89 12	 mov	 WORD PTR [r10], dx
  000cd	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  000d0	ff 43 28	 inc	 DWORD PTR [rbx+40]
  000d3	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]
  000d6	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  000da	41 0f b6 42 01	 movzx	 eax, BYTE PTR [r10+1]
  000df	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  000e2	b9 10 00 00 00	 mov	 ecx, 16
  000e7	0f b7 83 14 17
	00 00		 movzx	 eax, WORD PTR [rbx+5908]
  000ee	ff 43 28	 inc	 DWORD PTR [rbx+40]
  000f1	2a c8		 sub	 cl, al
  000f3	83 83 14 17 00
	00 f5		 add	 DWORD PTR [rbx+5908], -11
  000fa	66 41 d3 e8	 shr	 r8w, cl
  000fe	eb 11		 jmp	 SHORT $LN8@send_all_t
$LN7@send_all_t:
  00100	8d 41 05	 lea	 eax, DWORD PTR [rcx+5]
  00103	66 41 d3 e0	 shl	 r8w, cl
  00107	89 83 14 17 00
	00		 mov	 DWORD PTR [rbx+5908], eax
  0010d	66 45 0b c1	 or	 r8w, r9w
$LN8@send_all_t:

; 846  :     send_bits(s, blcodes-4,  4); /* not -3 as stated in appnote.txt */

  00111	66 45 89 02	 mov	 WORD PTR [r10], r8w
  00115	45 0f b7 c8	 movzx	 r9d, r8w
  00119	8b 8b 14 17 00
	00		 mov	 ecx, DWORD PTR [rbx+5908]
  0011f	45 8d 43 fc	 lea	 r8d, DWORD PTR [r11-4]
  00123	83 f9 0c	 cmp	 ecx, 12
  00126	7e 49		 jle	 SHORT $LN9@send_all_t
  00128	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  0012c	41 0f b7 d0	 movzx	 edx, r8w
  00130	66 d3 e2	 shl	 dx, cl
  00133	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]
  00136	66 41 0b d1	 or	 dx, r9w
  0013a	66 41 89 12	 mov	 WORD PTR [r10], dx
  0013e	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00141	ff 43 28	 inc	 DWORD PTR [rbx+40]
  00144	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]
  00147	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  0014b	41 0f b6 42 01	 movzx	 eax, BYTE PTR [r10+1]
  00150	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00153	b9 10 00 00 00	 mov	 ecx, 16
  00158	0f b7 83 14 17
	00 00		 movzx	 eax, WORD PTR [rbx+5908]
  0015f	ff 43 28	 inc	 DWORD PTR [rbx+40]
  00162	2a c8		 sub	 cl, al
  00164	83 83 14 17 00
	00 f4		 add	 DWORD PTR [rbx+5908], -12
  0016b	66 41 d3 e8	 shr	 r8w, cl
  0016f	eb 11		 jmp	 SHORT $LN10@send_all_t
$LN9@send_all_t:
  00171	8d 41 04	 lea	 eax, DWORD PTR [rcx+4]
  00174	66 41 d3 e0	 shl	 r8w, cl
  00178	89 83 14 17 00
	00		 mov	 DWORD PTR [rbx+5908], eax
  0017e	66 45 0b c1	 or	 r8w, r9w
$LN10@send_all_t:

; 847  :     for (rank = 0; rank < blcodes; rank++) {

  00182	66 45 89 02	 mov	 WORD PTR [r10], r8w
  00186	45 85 db	 test	 r11d, r11d
  00189	0f 8e 9f 00 00
	00		 jle	 $LN3@send_all_t
  0018f	8b 8b 14 17 00
	00		 mov	 ecx, DWORD PTR [rbx+5908]
  00195	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:bl_order
  0019c	0f 1f 40 00	 npad	 4
$LL4@send_all_t:

; 848  :         Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
; 849  :         send_bits(s, s->bl_tree[bl_order[rank]].Len, 3);

  001a0	41 0f b6 01	 movzx	 eax, BYTE PTR [r9]
  001a4	44 0f b7 84 83
	a6 0a 00 00	 movzx	 r8d, WORD PTR [rbx+rax*4+2726]
  001ad	41 0f b7 02	 movzx	 eax, WORD PTR [r10]
  001b1	83 f9 0d	 cmp	 ecx, 13
  001b4	7e 51		 jle	 SHORT $LN11@send_all_t
  001b6	41 0f b7 d0	 movzx	 edx, r8w
  001ba	66 d3 e2	 shl	 dx, cl
  001bd	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]
  001c0	66 0b d0	 or	 dx, ax
  001c3	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  001c7	66 41 89 12	 mov	 WORD PTR [r10], dx
  001cb	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  001ce	ff 43 28	 inc	 DWORD PTR [rbx+40]
  001d1	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]
  001d4	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  001d8	41 0f b6 42 01	 movzx	 eax, BYTE PTR [r10+1]
  001dd	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  001e0	b8 10 00 00 00	 mov	 eax, 16
  001e5	0f b7 8b 14 17
	00 00		 movzx	 ecx, WORD PTR [rbx+5908]
  001ec	83 83 14 17 00
	00 f3		 add	 DWORD PTR [rbx+5908], -13
  001f3	2a c1		 sub	 al, cl
  001f5	ff 43 28	 inc	 DWORD PTR [rbx+40]
  001f8	0f b6 c8	 movzx	 ecx, al
  001fb	8b 93 14 17 00
	00		 mov	 edx, DWORD PTR [rbx+5908]
  00201	66 41 d3 e8	 shr	 r8w, cl
  00205	eb 11		 jmp	 SHORT $LN18@send_all_t
$LN11@send_all_t:
  00207	8d 51 03	 lea	 edx, DWORD PTR [rcx+3]
  0020a	66 41 d3 e0	 shl	 r8w, cl
  0020e	89 93 14 17 00
	00		 mov	 DWORD PTR [rbx+5908], edx
  00214	66 44 0b c0	 or	 r8w, ax
$LN18@send_all_t:

; 847  :     for (rank = 0; rank < blcodes; rank++) {

  00218	49 8b c2	 mov	 rax, r10
  0021b	49 ff c1	 inc	 r9
  0021e	8b ca		 mov	 ecx, edx
  00220	66 44 89 00	 mov	 WORD PTR [rax], r8w
  00224	49 83 eb 01	 sub	 r11, 1
  00228	0f 85 72 ff ff
	ff		 jne	 $LL4@send_all_t
$LN3@send_all_t:

; 850  :     }
; 851  :     Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));
; 852  : 
; 853  :     send_tree(s, (ct_data *)s->dyn_ltree, lcodes-1); /* literal tree */

  0022e	44 8d 46 ff	 lea	 r8d, DWORD PTR [rsi-1]
  00232	48 8b cb	 mov	 rcx, rbx
  00235	48 8d 93 bc 00
	00 00		 lea	 rdx, QWORD PTR [rbx+188]
  0023c	e8 00 00 00 00	 call	 send_tree

; 854  :     Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));
; 855  : 
; 856  :     send_tree(s, (ct_data *)s->dyn_dtree, dcodes-1); /* distance tree */

  00241	44 8d 47 ff	 lea	 r8d, DWORD PTR [rdi-1]
  00245	48 8b cb	 mov	 rcx, rbx
  00248	48 8d 93 b0 09
	00 00		 lea	 rdx, QWORD PTR [rbx+2480]

; 857  :     Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
; 858  : }

  0024f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00254	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00259	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0025d	5f		 pop	 rdi

; 854  :     Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));
; 855  : 
; 856  :     send_tree(s, (ct_data *)s->dyn_dtree, dcodes-1); /* distance tree */

  0025e	e9 00 00 00 00	 jmp	 send_tree
send_all_trees ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\daten\projekte\simulationplatform\third_party_libraries\zlib\zlib-1.2.11\trees.c
;	COMDAT compress_block
_TEXT	SEGMENT
s$ = 48
ltree$ = 56
dtree$ = 64
compress_block PROC					; COMDAT

; 1068 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	4c 89 64 24 18	 mov	 QWORD PTR [rsp+24], r12
  0000b	48 8b c1	 mov	 rax, rcx
  0000e	4c 89 74 24 08	 mov	 QWORD PTR [rsp+8], r14
  00013	4d 8b e0	 mov	 r12, r8

; 1069 :     unsigned dist;      /* distance of matched string */
; 1070 :     int lc;             /* match length or unmatched char (if dist == 0) */
; 1071 :     unsigned lx = 0;    /* running index in l_buf */

  00016	45 33 f6	 xor	 r14d, r14d
  00019	4c 89 3c 24	 mov	 QWORD PTR [rsp], r15
  0001d	4c 8b fa	 mov	 r15, rdx

; 1072 :     unsigned code;      /* the code to send */
; 1073 :     int extra;          /* number of extra bits to send */
; 1074 : 
; 1075 :     if (s->last_lit != 0) do {

  00020	45 8d 5e 10	 lea	 r11d, QWORD PTR [r14+16]
  00024	44 39 b1 f4 16
	00 00		 cmp	 DWORD PTR [rcx+5876], r14d
  0002b	0f 84 7e 03 00
	00		 je	 $LN3@compress_b
  00031	4c 89 6c 24 10	 mov	 QWORD PTR [rsp+16], r13
  00036	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:__ImageBase
  0003d	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  00042	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
  00047	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  0004c	0f 1f 40 00	 npad	 4
$LL4@compress_b:

; 1076 :         dist = s->d_buf[lx];

  00050	48 8b 88 f8 16
	00 00		 mov	 rcx, QWORD PTR [rax+5880]
  00057	46 0f b7 0c 71	 movzx	 r9d, WORD PTR [rcx+r14*2]

; 1077 :         lc = s->l_buf[lx++];

  0005c	48 8b 88 e8 16
	00 00		 mov	 rcx, QWORD PTR [rax+5864]
  00063	45 0f b6 14 0e	 movzx	 r10d, BYTE PTR [r14+rcx]
  00068	41 ff c6	 inc	 r14d

; 1078 :         if (dist == 0) {

  0006b	45 85 c9	 test	 r9d, r9d
  0006e	0f 85 a3 00 00
	00		 jne	 $LN6@compress_b

; 1079 :             send_code(s, lc, ltree); /* send a literal byte */

  00074	43 0f b7 5c 97
	02		 movzx	 ebx, WORD PTR [r15+r10*4+2]
  0007a	41 8b d3	 mov	 edx, r11d
  0007d	8b 88 14 17 00
	00		 mov	 ecx, DWORD PTR [rax+5908]
  00083	2b d3		 sub	 edx, ebx
  00085	47 0f b7 0c 97	 movzx	 r9d, WORD PTR [r15+r10*4]
  0008a	44 0f b7 90 10
	17 00 00	 movzx	 r10d, WORD PTR [rax+5904]
  00092	3b ca		 cmp	 ecx, edx
  00094	7e 63		 jle	 SHORT $LN8@compress_b
  00096	8b 50 28	 mov	 edx, DWORD PTR [rax+40]
  00099	45 0f b7 c1	 movzx	 r8d, r9w
  0009d	66 41 d3 e0	 shl	 r8w, cl
  000a1	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  000a5	66 45 0b c2	 or	 r8w, r10w
  000a9	66 44 89 80 10
	17 00 00	 mov	 WORD PTR [rax+5904], r8w
  000b1	44 88 04 0a	 mov	 BYTE PTR [rdx+rcx], r8b
  000b5	ff 40 28	 inc	 DWORD PTR [rax+40]
  000b8	44 8b 40 28	 mov	 r8d, DWORD PTR [rax+40]
  000bc	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  000c0	0f b6 88 11 17
	00 00		 movzx	 ecx, BYTE PTR [rax+5905]
  000c7	41 88 0c 10	 mov	 BYTE PTR [r8+rdx], cl
  000cb	41 8b cb	 mov	 ecx, r11d
  000ce	8b 90 14 17 00
	00		 mov	 edx, DWORD PTR [rax+5908]
  000d4	ff 40 28	 inc	 DWORD PTR [rax+40]
  000d7	83 c2 f0	 add	 edx, -16
  000da	2a 88 14 17 00
	00		 sub	 cl, BYTE PTR [rax+5908]
  000e0	03 d3		 add	 edx, ebx
  000e2	66 41 d3 e9	 shr	 r9w, cl

; 1080 :             Tracecv(isgraph(lc), (stderr," '%c' ", lc));
; 1081 :         } else {

  000e6	66 44 89 88 10
	17 00 00	 mov	 WORD PTR [rax+5904], r9w
  000ee	89 90 14 17 00
	00		 mov	 DWORD PTR [rax+5908], edx
  000f4	e9 95 02 00 00	 jmp	 $LN2@compress_b
$LN8@compress_b:

; 1079 :             send_code(s, lc, ltree); /* send a literal byte */

  000f9	66 41 d3 e1	 shl	 r9w, cl
  000fd	8d 14 19	 lea	 edx, DWORD PTR [rcx+rbx]
  00100	66 45 0b ca	 or	 r9w, r10w

; 1080 :             Tracecv(isgraph(lc), (stderr," '%c' ", lc));
; 1081 :         } else {

  00104	66 44 89 88 10
	17 00 00	 mov	 WORD PTR [rax+5904], r9w
  0010c	89 90 14 17 00
	00		 mov	 DWORD PTR [rax+5908], edx
  00112	e9 77 02 00 00	 jmp	 $LN2@compress_b
$LN6@compress_b:

; 1082 :             /* Here, lc is the match length - MIN_MATCH */
; 1083 :             code = _length_code[lc];
; 1084 :             send_code(s, code+LITERALS+1, ltree); /* send the length code */

  00117	8b b8 14 17 00
	00		 mov	 edi, DWORD PTR [rax+5908]
  0011d	43 0f b6 ac 2a
	00 00 00 00	 movzx	 ebp, BYTE PTR _length_code[r10+r13]
  00126	8d 8d 01 01 00
	00		 lea	 ecx, DWORD PTR [rbp+257]
  0012c	41 0f b7 1c 8f	 movzx	 ebx, WORD PTR [r15+rcx*4]
  00131	41 0f b7 74 8f
	02		 movzx	 esi, WORD PTR [r15+rcx*4+2]
  00137	44 0f b7 c3	 movzx	 r8d, bx
  0013b	8b cf		 mov	 ecx, edi
  0013d	66 41 d3 e0	 shl	 r8w, cl
  00141	41 8b cb	 mov	 ecx, r11d
  00144	66 44 0b 80 10
	17 00 00	 or	 r8w, WORD PTR [rax+5904]
  0014c	2b ce		 sub	 ecx, esi
  0014e	3b f9		 cmp	 edi, ecx
  00150	7e 45		 jle	 SHORT $LN10@compress_b
  00152	8b 50 28	 mov	 edx, DWORD PTR [rax+40]
  00155	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00159	66 44 89 80 10
	17 00 00	 mov	 WORD PTR [rax+5904], r8w
  00161	44 88 04 0a	 mov	 BYTE PTR [rdx+rcx], r8b
  00165	ff 40 28	 inc	 DWORD PTR [rax+40]
  00168	44 8b 40 28	 mov	 r8d, DWORD PTR [rax+40]
  0016c	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  00170	0f b6 88 11 17
	00 00		 movzx	 ecx, BYTE PTR [rax+5905]
  00177	41 88 0c 10	 mov	 BYTE PTR [r8+rdx], cl
  0017b	41 8b cb	 mov	 ecx, r11d
  0017e	2a 88 14 17 00
	00		 sub	 cl, BYTE PTR [rax+5908]
  00184	8b 90 14 17 00
	00		 mov	 edx, DWORD PTR [rax+5908]
  0018a	ff 40 28	 inc	 DWORD PTR [rax+40]
  0018d	83 c2 f0	 add	 edx, -16
  00190	66 d3 eb	 shr	 bx, cl
  00193	03 d6		 add	 edx, esi
  00195	eb 07		 jmp	 SHORT $LN11@compress_b
$LN10@compress_b:
  00197	41 0f b7 d8	 movzx	 ebx, r8w
  0019b	8d 14 37	 lea	 edx, DWORD PTR [rdi+rsi]
$LN11@compress_b:

; 1085 :             extra = extra_lbits[code];

  0019e	89 90 14 17 00
	00		 mov	 DWORD PTR [rax+5908], edx
  001a4	66 89 98 10 17
	00 00		 mov	 WORD PTR [rax+5904], bx
  001ab	41 8b 9c ad 00
	00 00 00	 mov	 ebx, DWORD PTR extra_lbits[r13+rbp*4]

; 1086 :             if (extra != 0) {

  001b3	85 db		 test	 ebx, ebx
  001b5	0f 84 82 00 00
	00		 je	 $LN14@compress_b

; 1087 :                 lc -= base_length[code];

  001bb	45 2b 94 ad 00
	00 00 00	 sub	 r10d, DWORD PTR base_length[r13+rbp*4]

; 1088 :                 send_bits(s, lc, extra);       /* send the extra length bits */

  001c3	8b ca		 mov	 ecx, edx
  001c5	0f b7 b8 10 17
	00 00		 movzx	 edi, WORD PTR [rax+5904]
  001cc	41 8b d3	 mov	 edx, r11d
  001cf	2b d3		 sub	 edx, ebx
  001d1	3b ca		 cmp	 ecx, edx
  001d3	7e 50		 jle	 SHORT $LN13@compress_b
  001d5	8b 50 28	 mov	 edx, DWORD PTR [rax+40]
  001d8	45 0f b7 c2	 movzx	 r8d, r10w
  001dc	66 41 d3 e0	 shl	 r8w, cl
  001e0	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  001e4	66 44 0b c7	 or	 r8w, di
  001e8	66 44 89 80 10
	17 00 00	 mov	 WORD PTR [rax+5904], r8w
  001f0	44 88 04 0a	 mov	 BYTE PTR [rdx+rcx], r8b
  001f4	ff 40 28	 inc	 DWORD PTR [rax+40]
  001f7	44 8b 40 28	 mov	 r8d, DWORD PTR [rax+40]
  001fb	0f b6 88 11 17
	00 00		 movzx	 ecx, BYTE PTR [rax+5905]
  00202	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  00206	41 88 0c 10	 mov	 BYTE PTR [r8+rdx], cl
  0020a	41 8b cb	 mov	 ecx, r11d
  0020d	2a 88 14 17 00
	00		 sub	 cl, BYTE PTR [rax+5908]
  00213	ff 40 28	 inc	 DWORD PTR [rax+40]
  00216	66 41 d3 ea	 shr	 r10w, cl
  0021a	8d 4b f0	 lea	 ecx, DWORD PTR [rbx-16]
  0021d	01 88 14 17 00
	00		 add	 DWORD PTR [rax+5908], ecx
  00223	eb 10		 jmp	 SHORT $LN28@compress_b
$LN13@compress_b:
  00225	66 41 d3 e2	 shl	 r10w, cl
  00229	66 44 0b d7	 or	 r10w, di
  0022d	03 cb		 add	 ecx, ebx
  0022f	89 88 14 17 00
	00		 mov	 DWORD PTR [rax+5908], ecx
$LN28@compress_b:

; 1089 :             }
; 1090 :             dist--; /* dist is now the match distance - 1 */

  00235	66 44 89 90 10
	17 00 00	 mov	 WORD PTR [rax+5904], r10w
$LN14@compress_b:
  0023d	41 ff c9	 dec	 r9d

; 1091 :             code = d_code(dist);

  00240	41 81 f9 00 01
	00 00		 cmp	 r9d, 256		; 00000100H
  00247	73 0b		 jae	 SHORT $LN23@compress_b
  00249	43 0f b6 94 29
	00 00 00 00	 movzx	 edx, BYTE PTR _dist_code[r9+r13]
  00252	eb 15		 jmp	 SHORT $LN24@compress_b
$LN23@compress_b:
  00254	41 8b c9	 mov	 ecx, r9d
  00257	c1 e9 07	 shr	 ecx, 7
  0025a	81 c1 00 01 00
	00		 add	 ecx, 256		; 00000100H
  00260	42 0f b6 94 29
	00 00 00 00	 movzx	 edx, BYTE PTR _dist_code[rcx+r13]
$LN24@compress_b:

; 1092 :             Assert (code < D_CODES, "bad d_code");
; 1093 : 
; 1094 :             send_code(s, code, dtree);       /* send the distance code */

  00269	0f b6 ca	 movzx	 ecx, dl
  0026c	8b 90 14 17 00
	00		 mov	 edx, DWORD PTR [rax+5908]
  00272	48 8d 1c 8d 00
	00 00 00	 lea	 rbx, QWORD PTR [rcx*4]
  0027a	8b ca		 mov	 ecx, edx
  0027c	46 0f b7 14 23	 movzx	 r10d, WORD PTR [rbx+r12]
  00281	42 0f b7 7c 23
	02		 movzx	 edi, WORD PTR [rbx+r12+2]
  00287	45 0f b7 c2	 movzx	 r8d, r10w
  0028b	66 41 d3 e0	 shl	 r8w, cl
  0028f	41 8b cb	 mov	 ecx, r11d
  00292	66 44 0b 80 10
	17 00 00	 or	 r8w, WORD PTR [rax+5904]
  0029a	2b cf		 sub	 ecx, edi
  0029c	3b d1		 cmp	 edx, ecx
  0029e	7e 44		 jle	 SHORT $LN15@compress_b
  002a0	8b 50 28	 mov	 edx, DWORD PTR [rax+40]
  002a3	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  002a7	66 44 89 80 10
	17 00 00	 mov	 WORD PTR [rax+5904], r8w
  002af	44 88 04 0a	 mov	 BYTE PTR [rdx+rcx], r8b
  002b3	ff 40 28	 inc	 DWORD PTR [rax+40]
  002b6	44 8b 40 28	 mov	 r8d, DWORD PTR [rax+40]
  002ba	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  002be	0f b6 88 11 17
	00 00		 movzx	 ecx, BYTE PTR [rax+5905]
  002c5	41 88 0c 10	 mov	 BYTE PTR [r8+rdx], cl
  002c9	41 8b cb	 mov	 ecx, r11d
  002cc	2a 88 14 17 00
	00		 sub	 cl, BYTE PTR [rax+5908]
  002d2	ff 40 28	 inc	 DWORD PTR [rax+40]
  002d5	8b 90 14 17 00
	00		 mov	 edx, DWORD PTR [rax+5908]
  002db	66 41 d3 ea	 shr	 r10w, cl
  002df	83 c2 f0	 add	 edx, -16
  002e2	eb 04		 jmp	 SHORT $LN29@compress_b
$LN15@compress_b:
  002e4	45 0f b7 d0	 movzx	 r10d, r8w
$LN29@compress_b:

; 1095 :             extra = extra_dbits[code];

  002e8	03 d7		 add	 edx, edi
  002ea	89 90 14 17 00
	00		 mov	 DWORD PTR [rax+5908], edx
  002f0	66 44 89 90 10
	17 00 00	 mov	 WORD PTR [rax+5904], r10w
  002f8	46 8b 94 2b 00
	00 00 00	 mov	 r10d, DWORD PTR extra_dbits[rbx+r13]

; 1096 :             if (extra != 0) {

  00300	45 85 d2	 test	 r10d, r10d
  00303	0f 84 85 00 00
	00		 je	 $LN2@compress_b

; 1097 :                 dist -= (unsigned)base_dist[code];

  00309	46 2b 8c 2b 00
	00 00 00	 sub	 r9d, DWORD PTR base_dist[rbx+r13]

; 1098 :                 send_bits(s, dist, extra);   /* send the extra distance bits */

  00311	8b ca		 mov	 ecx, edx
  00313	0f b7 98 10 17
	00 00		 movzx	 ebx, WORD PTR [rax+5904]
  0031a	41 8b d3	 mov	 edx, r11d
  0031d	41 2b d2	 sub	 edx, r10d
  00320	3b ca		 cmp	 ecx, edx
  00322	7e 51		 jle	 SHORT $LN18@compress_b
  00324	8b 50 28	 mov	 edx, DWORD PTR [rax+40]
  00327	45 0f b7 c1	 movzx	 r8d, r9w
  0032b	66 41 d3 e0	 shl	 r8w, cl
  0032f	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00333	66 44 0b c3	 or	 r8w, bx
  00337	66 44 89 80 10
	17 00 00	 mov	 WORD PTR [rax+5904], r8w
  0033f	44 88 04 0a	 mov	 BYTE PTR [rdx+rcx], r8b
  00343	ff 40 28	 inc	 DWORD PTR [rax+40]
  00346	44 8b 40 28	 mov	 r8d, DWORD PTR [rax+40]
  0034a	0f b6 88 11 17
	00 00		 movzx	 ecx, BYTE PTR [rax+5905]
  00351	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  00355	41 88 0c 10	 mov	 BYTE PTR [r8+rdx], cl
  00359	41 8b cb	 mov	 ecx, r11d
  0035c	2a 88 14 17 00
	00		 sub	 cl, BYTE PTR [rax+5908]
  00362	ff 40 28	 inc	 DWORD PTR [rax+40]
  00365	66 41 d3 e9	 shr	 r9w, cl
  00369	41 8d 4a f0	 lea	 ecx, DWORD PTR [r10-16]
  0036d	01 88 14 17 00
	00		 add	 DWORD PTR [rax+5908], ecx
  00373	eb 11		 jmp	 SHORT $LN30@compress_b
$LN18@compress_b:
  00375	66 41 d3 e1	 shl	 r9w, cl
  00379	66 44 0b cb	 or	 r9w, bx
  0037d	41 03 ca	 add	 ecx, r10d
  00380	89 88 14 17 00
	00		 mov	 DWORD PTR [rax+5908], ecx
$LN30@compress_b:

; 1099 :             }
; 1100 :         } /* literal or match pair ? */
; 1101 : 
; 1102 :         /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
; 1103 :         Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
; 1104 :                "pendingBuf overflow");
; 1105 : 
; 1106 :     } while (lx < s->last_lit);

  00386	66 44 89 88 10
	17 00 00	 mov	 WORD PTR [rax+5904], r9w
$LN2@compress_b:
  0038e	44 3b b0 f4 16
	00 00		 cmp	 r14d, DWORD PTR [rax+5876]
  00395	0f 82 b5 fc ff
	ff		 jb	 $LL4@compress_b
  0039b	4c 8b 6c 24 10	 mov	 r13, QWORD PTR [rsp+16]
  003a0	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  003a5	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  003aa	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
$LN3@compress_b:

; 1107 : 
; 1108 :     send_code(s, END_BLOCK, ltree);

  003af	45 0f b7 97 00
	04 00 00	 movzx	 r10d, WORD PTR [r15+1024]
  003b7	8b 90 14 17 00
	00		 mov	 edx, DWORD PTR [rax+5908]
  003bd	45 0f b7 ca	 movzx	 r9d, r10w
  003c1	41 0f b7 9f 02
	04 00 00	 movzx	 ebx, WORD PTR [r15+1026]
  003c9	8b ca		 mov	 ecx, edx
  003cb	4c 8b 3c 24	 mov	 r15, QWORD PTR [rsp]
  003cf	4c 8b 74 24 08	 mov	 r14, QWORD PTR [rsp+8]
  003d4	4c 8b 64 24 18	 mov	 r12, QWORD PTR [rsp+24]
  003d9	66 41 d3 e1	 shl	 r9w, cl
  003dd	41 8b cb	 mov	 ecx, r11d
  003e0	66 44 0b 88 10
	17 00 00	 or	 r9w, WORD PTR [rax+5904]
  003e8	2b cb		 sub	 ecx, ebx
  003ea	3b d1		 cmp	 edx, ecx
  003ec	7e 5b		 jle	 SHORT $LN20@compress_b
  003ee	44 8b 40 28	 mov	 r8d, DWORD PTR [rax+40]
  003f2	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  003f6	66 44 89 88 10
	17 00 00	 mov	 WORD PTR [rax+5904], r9w
  003fe	45 88 0c 10	 mov	 BYTE PTR [r8+rdx], r9b
  00402	ff 40 28	 inc	 DWORD PTR [rax+40]
  00405	44 8b 48 28	 mov	 r9d, DWORD PTR [rax+40]
  00409	0f b6 90 11 17
	00 00		 movzx	 edx, BYTE PTR [rax+5905]
  00410	4c 8b 40 10	 mov	 r8, QWORD PTR [rax+16]
  00414	43 88 14 01	 mov	 BYTE PTR [r9+r8], dl
  00418	44 2a 98 14 17
	00 00		 sub	 r11b, BYTE PTR [rax+5908]
  0041f	8b 90 14 17 00
	00		 mov	 edx, DWORD PTR [rax+5908]
  00425	41 0f b6 cb	 movzx	 ecx, r11b
  00429	ff 40 28	 inc	 DWORD PTR [rax+40]
  0042c	83 c2 f0	 add	 edx, -16
  0042f	66 41 d3 ea	 shr	 r10w, cl
  00433	03 d3		 add	 edx, ebx

; 1109 : }

  00435	89 90 14 17 00
	00		 mov	 DWORD PTR [rax+5908], edx
  0043b	66 44 89 90 10
	17 00 00	 mov	 WORD PTR [rax+5904], r10w
  00443	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00447	5b		 pop	 rbx
  00448	c3		 ret	 0
$LN20@compress_b:

; 1107 : 
; 1108 :     send_code(s, END_BLOCK, ltree);

  00449	8d 0c 1a	 lea	 ecx, DWORD PTR [rdx+rbx]

; 1109 : }

  0044c	89 88 14 17 00
	00		 mov	 DWORD PTR [rax+5908], ecx
  00452	66 44 89 88 10
	17 00 00	 mov	 WORD PTR [rax+5904], r9w
  0045a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0045e	5b		 pop	 rbx
  0045f	c3		 ret	 0
compress_block ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\daten\projekte\simulationplatform\third_party_libraries\zlib\zlib-1.2.11\trees.c
;	COMDAT detect_data_type
_TEXT	SEGMENT
s$ = 8
detect_data_type PROC					; COMDAT

; 1126 : {

  00000	4c 8b c9	 mov	 r9, rcx

; 1127 :     /* black_mask is the bit mask of black-listed bytes
; 1128 :      * set bits 0..6, 14..25, and 28..31
; 1129 :      * 0xf3ffc07f = binary 11110011111111111100000001111111
; 1130 :      */
; 1131 :     unsigned long black_mask = 0xf3ffc07fUL;

  00003	48 8d 81 bc 00
	00 00		 lea	 rax, QWORD PTR [rcx+188]
  0000a	33 d2		 xor	 edx, edx
  0000c	41 b8 7f c0 ff
	f3		 mov	 r8d, -201342849		; f3ffc07fH
$LL4@detect_dat:

; 1136 :         if ((black_mask & 1) && (s->dyn_ltree[n].Freq != 0))

  00012	41 f6 c0 01	 test	 r8b, 1
  00016	74 06		 je	 SHORT $LN2@detect_dat
  00018	66 83 38 00	 cmp	 WORD PTR [rax], 0
  0001c	75 50		 jne	 SHORT $LN15@detect_dat
$LN2@detect_dat:

; 1132 :     int n;
; 1133 : 
; 1134 :     /* Check for non-textual ("black-listed") bytes. */
; 1135 :     for (n = 0; n <= 31; n++, black_mask >>= 1)

  0001e	48 ff c2	 inc	 rdx
  00021	41 d1 e8	 shr	 r8d, 1
  00024	48 83 c0 04	 add	 rax, 4
  00028	48 83 fa 1f	 cmp	 rdx, 31
  0002c	7e e4		 jle	 SHORT $LL4@detect_dat

; 1137 :             return Z_BINARY;
; 1138 : 
; 1139 :     /* Check for textual ("white-listed") bytes. */
; 1140 :     if (s->dyn_ltree[9].Freq != 0 || s->dyn_ltree[10].Freq != 0
; 1141 :             || s->dyn_ltree[13].Freq != 0)

  0002e	66 83 b9 e0 00
	00 00 00	 cmp	 WORD PTR [rcx+224], 0
  00036	75 39		 jne	 SHORT $LN10@detect_dat
  00038	66 83 b9 e4 00
	00 00 00	 cmp	 WORD PTR [rcx+228], 0
  00040	75 2f		 jne	 SHORT $LN10@detect_dat
  00042	66 83 b9 f0 00
	00 00 00	 cmp	 WORD PTR [rcx+240], 0
  0004a	75 25		 jne	 SHORT $LN10@detect_dat
  0004c	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00051	49 8d 81 3c 01
	00 00		 lea	 rax, QWORD PTR [r9+316]
$LL7@detect_dat:

; 1144 :         if (s->dyn_ltree[n].Freq != 0)

  00058	66 83 38 00	 cmp	 WORD PTR [rax], 0
  0005c	75 13		 jne	 SHORT $LN10@detect_dat

; 1143 :     for (n = 32; n < LITERALS; n++)

  0005e	48 ff c1	 inc	 rcx
  00061	48 83 c0 04	 add	 rax, 4
  00065	48 81 f9 00 01
	00 00		 cmp	 rcx, 256		; 00000100H
  0006c	7c ea		 jl	 SHORT $LL7@detect_dat
$LN15@detect_dat:

; 1145 :             return Z_TEXT;
; 1146 : 
; 1147 :     /* There are no "black-listed" or "white-listed" bytes:
; 1148 :      * this stream either is empty or has tolerated ("gray-listed") bytes only.
; 1149 :      */
; 1150 :     return Z_BINARY;
; 1151 : }

  0006e	33 c0		 xor	 eax, eax
  00070	c3		 ret	 0
$LN10@detect_dat:

; 1142 :         return Z_TEXT;

  00071	b8 01 00 00 00	 mov	 eax, 1

; 1145 :             return Z_TEXT;
; 1146 : 
; 1147 :     /* There are no "black-listed" or "white-listed" bytes:
; 1148 :      * this stream either is empty or has tolerated ("gray-listed") bytes only.
; 1149 :      */
; 1150 :     return Z_BINARY;
; 1151 : }

  00076	c3		 ret	 0
detect_data_type ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\daten\projekte\simulationplatform\third_party_libraries\zlib\zlib-1.2.11\trees.c
;	COMDAT bi_reverse
_TEXT	SEGMENT
code$ = 8
len$ = 16
bi_reverse PROC						; COMDAT

; 1162 :     register unsigned res = 0;

  00000	33 c0		 xor	 eax, eax
$LL4@bi_reverse:

; 1163 :     do {
; 1164 :         res |= code & 1;

  00002	44 8b c1	 mov	 r8d, ecx

; 1165 :         code >>= 1, res <<= 1;
; 1166 :     } while (--len > 0);

  00005	ff ca		 dec	 edx
  00007	41 83 e0 01	 and	 r8d, 1
  0000b	d1 e9		 shr	 ecx, 1
  0000d	41 0b c0	 or	 eax, r8d
  00010	03 c0		 add	 eax, eax
  00012	85 d2		 test	 edx, edx
  00014	7f ec		 jg	 SHORT $LL4@bi_reverse

; 1167 :     return res >> 1;

  00016	d1 e8		 shr	 eax, 1

; 1168 : }

  00018	c3		 ret	 0
bi_reverse ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\daten\projekte\simulationplatform\third_party_libraries\zlib\zlib-1.2.11\trees.c
;	COMDAT bi_flush
_TEXT	SEGMENT
s$ = 8
bi_flush PROC						; COMDAT

; 1176 :     if (s->bi_valid == 16) {

  00000	8b 81 14 17 00
	00		 mov	 eax, DWORD PTR [rcx+5908]
  00006	4c 8b c9	 mov	 r9, rcx
  00009	83 f8 10	 cmp	 eax, 16
  0000c	75 3e		 jne	 SHORT $LN2@bi_flush

; 1177 :         put_short(s, s->bi_buf);

  0000e	0f b6 81 10 17
	00 00		 movzx	 eax, BYTE PTR [rcx+5904]
  00015	44 8b 41 28	 mov	 r8d, DWORD PTR [rcx+40]
  00019	48 8b 51 10	 mov	 rdx, QWORD PTR [rcx+16]
  0001d	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al
  00021	ff 41 28	 inc	 DWORD PTR [rcx+40]
  00024	8b 51 28	 mov	 edx, DWORD PTR [rcx+40]
  00027	41 0f b6 81 11
	17 00 00	 movzx	 eax, BYTE PTR [r9+5905]
  0002f	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00033	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00036	41 ff 41 28	 inc	 DWORD PTR [r9+40]

; 1178 :         s->bi_buf = 0;

  0003a	33 c0		 xor	 eax, eax

; 1179 :         s->bi_valid = 0;

  0003c	41 89 81 14 17
	00 00		 mov	 DWORD PTR [r9+5908], eax

; 1184 :     }
; 1185 : }

  00043	66 41 89 81 10
	17 00 00	 mov	 WORD PTR [r9+5904], ax
  0004b	c3		 ret	 0
$LN2@bi_flush:

; 1180 :     } else if (s->bi_valid >= 8) {

  0004c	83 f8 08	 cmp	 eax, 8
  0004f	7c 2e		 jl	 SHORT $LN4@bi_flush

; 1181 :         put_byte(s, (Byte)s->bi_buf);

  00051	8b 51 28	 mov	 edx, DWORD PTR [rcx+40]
  00054	41 0f b6 81 10
	17 00 00	 movzx	 eax, BYTE PTR [r9+5904]
  0005c	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00060	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00063	41 ff 41 28	 inc	 DWORD PTR [r9+40]

; 1182 :         s->bi_buf >>= 8;

  00067	41 0f b6 81 11
	17 00 00	 movzx	 eax, BYTE PTR [r9+5905]

; 1183 :         s->bi_valid -= 8;

  0006f	41 83 81 14 17
	00 00 f8	 add	 DWORD PTR [r9+5908], -8

; 1184 :     }
; 1185 : }

  00077	66 41 89 81 10
	17 00 00	 mov	 WORD PTR [r9+5904], ax
$LN4@bi_flush:
  0007f	c3		 ret	 0
bi_flush ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\daten\projekte\simulationplatform\third_party_libraries\zlib\zlib-1.2.11\trees.c
;	COMDAT bi_windup
_TEXT	SEGMENT
s$ = 8
bi_windup PROC						; COMDAT

; 1193 :     if (s->bi_valid > 8) {

  00000	8b 81 14 17 00
	00		 mov	 eax, DWORD PTR [rcx+5908]
  00006	4c 8b c9	 mov	 r9, rcx
  00009	83 f8 08	 cmp	 eax, 8
  0000c	7e 1f		 jle	 SHORT $LN2@bi_windup

; 1194 :         put_short(s, s->bi_buf);

  0000e	44 8b 41 28	 mov	 r8d, DWORD PTR [rcx+40]
  00012	0f b6 81 10 17
	00 00		 movzx	 eax, BYTE PTR [rcx+5904]
  00019	48 8b 51 10	 mov	 rdx, QWORD PTR [rcx+16]
  0001d	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al
  00021	ff 41 28	 inc	 DWORD PTR [rcx+40]
  00024	0f b6 81 11 17
	00 00		 movzx	 eax, BYTE PTR [rcx+5905]
  0002b	eb 0c		 jmp	 SHORT $LN6@bi_windup
$LN2@bi_windup:

; 1195 :     } else if (s->bi_valid > 0) {

  0002d	85 c0		 test	 eax, eax
  0002f	7e 16		 jle	 SHORT $LN4@bi_windup

; 1196 :         put_byte(s, (Byte)s->bi_buf);

  00031	41 0f b6 81 10
	17 00 00	 movzx	 eax, BYTE PTR [r9+5904]
$LN6@bi_windup:

; 1197 :     }
; 1198 :     s->bi_buf = 0;

  00039	8b 51 28	 mov	 edx, DWORD PTR [rcx+40]
  0003c	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00040	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00043	41 ff 41 28	 inc	 DWORD PTR [r9+40]
$LN4@bi_windup:
  00047	33 c0		 xor	 eax, eax
  00049	66 41 89 81 10
	17 00 00	 mov	 WORD PTR [r9+5904], ax

; 1199 :     s->bi_valid = 0;

  00051	41 89 81 14 17
	00 00		 mov	 DWORD PTR [r9+5908], eax

; 1200 : #ifdef ZLIB_DEBUG
; 1201 :     s->bits_sent = (s->bits_sent+7) & ~7;
; 1202 : #endif
; 1203 : }

  00058	c3		 ret	 0
bi_windup ENDP
_TEXT	ENDS
END
