<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Open CASCADE Technology: Foundation Classes</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="occ_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Open CASCADE Technology
   &#160;<span id="projectnumber">7.5.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('occt_user_guides__foundation_classes.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Foundation Classes </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#occt_fcug_1">Introduction</a></li>
<li class="level1"><a href="#occt_fcug_2">Basics</a><ul><li class="level2"><a href="#occt_fcug_2_a">Library organization</a><ul><li class="level3"><a href="#occt_fcug_2_a_1">Modules and toolkits</a></li>
<li class="level3"><a href="#occt_fcug_2_a_2">Packages</a></li>
<li class="level3"><a href="#occt_fcug_2_a_3">Classes</a></li>
<li class="level3"><a href="#occt_fcug_2_a_5">Inheritance</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_fcug_2_1">Data Types</a><ul><li class="level3"><a href="#occt_fcug_2_1_1">Primitive Types</a></li>
<li class="level3"><a href="#occt_fcug_2_1_2">Types manipulated by value</a></li>
<li class="level3"><a href="#occt_fcug_2_1_3">Types manipulated by reference (handle)</a></li>
<li class="level3"><a href="#occt_fcug_2_1_4">When is it necessary to use a handle?</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_fcug_2_2">Programming with Handles</a><ul><li class="level3"><a href="#occt_fcug_2_2_1">Handle Definition</a></li>
<li class="level3"><a href="#occt_fcug_2_2_2">Type Management</a></li>
<li class="level3"><a href="#occt_fcug_2_2_3">Using Handles to Create Objects</a></li>
<li class="level3"><a href="#occt_fcug_2_2_4">Invoking Methods</a></li>
<li class="level3"><a href="#occt_fcug_2_2_5">Handle deallocation</a></li>
<li class="level3"><a href="#occt_fcug_2_2_6">Cycles</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_fcug_2_3">Memory Management</a><ul><li class="level3"><a href="#occt_fcug_2_3_1">Usage of Memory Manager</a></li>
<li class="level3"><a href="#occt_fcug_2_3_2">How to configure the Memory Manager</a></li>
<li class="level3"><a href="#occt_fcug_2_3_3">Optimization Techniques</a></li>
<li class="level3"><a href="#occt_fcug_2_3_4">Benefits and drawbacks</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_fcug_2_4">Exceptions</a><ul><li class="level3"><a href="#occt_fcug_2_4_1">Introduction</a></li>
<li class="level3"><a href="#occt_fcug_2_4_2">Raising an Exception</a></li>
<li class="level3"><a href="#occt_fcug_2_4_3">Handling an Exception</a></li>
<li class="level3"><a href="#occt_fcug_2_4_4">Implementation on various platforms</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_fcug_2_5">Plug-In Management</a><ul><li class="level3"><a href="#occt_fcug_2_5_1">Distribution by Plug-Ins</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#occt_fcug_3">Collections, Strings, Quantities and Unit Conversion</a><ul><li class="level2"><a href="#occt_fcug_3_1">Collections</a><ul><li class="level3"><a href="#occt_fcug_3_1_1">Overview</a></li>
<li class="level3"><a href="#occt_fcug_3_1_2">Arrays and sequences</a></li>
<li class="level3"><a href="#occt_fcug_3_1_3">Maps</a></li>
<li class="level3"><a href="#occt_fcug_3_1_4">Iterators</a></li>
<li class="level3"><a href="#occt_fcug_3_1_5">Allocators</a></li>
<li class="level3"><a href="#occt_fcug_3_1_6">Acceleration structures</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_fcug_3_2">Collections of Standard Objects</a></li>
<li class="level2"><a href="#occt_fcug_3_4">Strings</a></li>
<li class="level2"><a href="#occt_fcug_3_5">Quantities</a></li>
<li class="level2"><a href="#occt_fcug_3_6">Unit Conversion</a></li>
</ul>
</li>
<li class="level1"><a href="#occt_occt_fcug_4">Math Primitives and Algorithms</a><ul><li class="level2"><a href="#occt_occt_fcug_4_1">Overview</a></li>
<li class="level2"><a href="#occt_occt_fcug_4_2">Vectors and Matrices</a></li>
<li class="level2"><a href="#occt_occt_fcug_4_3">Primitive Geometric Types</a></li>
<li class="level2"><a href="#occt_occt_fcug_4_4">Collections of Primitive Geometric Types</a></li>
<li class="level2"><a href="#occt_occt_fcug_4_5">Basic Geometric Libraries</a></li>
<li class="level2"><a href="#occt_occt_fcug_4_6">Common Math Algorithms</a></li>
<li class="level2"><a href="#occt_occt_fcug_4_7">Precision</a><ul><li class="level3"><a href="#occt_occt_fcug_4_7_1">The Precision package</a></li>
<li class="level3"><a href="#occt_occt_fcug_4_7_2">Standard Precision values</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="occt_fcug_1"></a>
Introduction</h1>
<p>This manual explains how to use Open CASCADE Technology (<b>OCCT</b>) Foundation Classes. It provides basic documentation on foundation classes.</p>
<p>Foundation Classes provide a variety of general-purpose services such as automated dynamic memory management (manipulation of objects by handle), collections, exception handling, genericity by down-casting and plug-in creation.</p>
<p>Foundation Classes include the following:</p>
<h3>Root Classes</h3>
<p>Root classes are the basic data types and classes on which all the other classes are built. They provide:</p><ul>
<li>fundamental types such as Boolean, Character, Integer or Real,</li>
<li>safe handling of dynamically created objects, ensuring automatic deletion of unreferenced objects (see <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_standard___transient.html">Standard_Transient</a></em> class),</li>
<li>standard and custom memory allocators,</li>
<li>extended run-time type information (RTTI) mechanism facilitating the creation of complex programs,</li>
<li>management of exceptions,</li>
<li>encapsulation of C++ streams. Root classes are mainly implemented in <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_standard.html">Standard</a></em> package.</li>
</ul>
<h3>Strings</h3>
<p>Strings are classes that handle dynamically sized sequences of characters based on UTF-8 and UTF-16 encodings. Strings may also be manipulated by handles, and consequently be shared. Strings are implemented in the <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_t_collection.html">TCollection</a></em> package.</p>
<h3>Collections</h3>
<p>Collections are the classes that handle dynamically sized aggregates of data. Collection classes are <em>generic</em> and rely on C++ templates.</p>
<p>Collections include a wide range of generic classes such as run-time sized arrays, lists, stacks, queues, sets and hash maps. Collections are implemented in the <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_t_collection.html">TCollection</a></em> and <em>NCollection</em> packages.</p>
<h3>Collections of <a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_standard.html">Standard</a> Objects</h3>
<p>The <em>TColStd</em> package provides frequently used instantiations of generic classes from the <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_t_collection.html">TCollection</a></em> package with objects from the <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_standard.html">Standard</a></em> package or strings from the <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_t_collection.html">TCollection</a></em> package.</p>
<h3>Vectors and Matrices</h3>
<p>These classes provide commonly used mathematical algorithms and basic calculations (addition, multiplication, transposition, inversion, etc.) involving vectors and matrices.</p>
<h3>Primitive Geometric Types</h3>
<p>Open CASCADE Technology primitive geometric types are a STEP-compliant implementation of basic geometric and algebraic entities. They provide:</p><ul>
<li>Descriptions of elementary geometric shapes:<ul>
<li>Points,</li>
<li>Vectors,</li>
<li>Lines,</li>
<li>Circles and conics,</li>
<li>Planes and elementary surfaces,</li>
</ul>
</li>
<li>Positioning of these shapes in space or in a plane by means of an axis or a coordinate system,</li>
<li>Definition and application of geometric transformations to these shapes:<ul>
<li>Translations</li>
<li>Rotations</li>
<li>Symmetries</li>
<li>Scaling transformations</li>
<li>Composed transformations</li>
</ul>
</li>
<li>Tools (coordinates and matrices) for algebraic computation.</li>
</ul>
<h3>Common Math Algorithms</h3>
<p>Open CASCADE Technology common math algorithms provide a C++ implementation of the most frequently used mathematical algorithms. These include:</p><ul>
<li>Algorithms to solve a set of linear algebraic equations,</li>
<li>Algorithms to find the minimum of a function of one or more independent variables,</li>
<li>Algorithms to find roots of one, or of a set, of non-linear equations,</li>
<li>Algorithms to find the eigen-values and eigen-vectors of a square matrix.</li>
</ul>
<h3>Exceptions</h3>
<p>A hierarchy of commonly used exception classes is provided, all based on class <a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_standard___failure.html">Standard_Failure</a>, the root of exceptions. Exceptions describe exceptional situations, which can arise during the execution of a function. With the raising of an exception, the normal course of program execution is abandoned. The execution of actions in response to this situation is called the treatment of the exception.</p>
<h3>Quantities</h3>
<p>These are various classes supporting date and time information.</p>
<h3>Application services</h3>
<p>Foundation Classes also include implementation of several low-level services that facilitate the creation of customizable and user-friendly applications with Open CASCADE Technology. These include:</p><ul>
<li>Unit conversion tools, providing a uniform mechanism for dealing with quantities and associated physical units: check unit compatibility, perform conversions of values between different units and so on (see package <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_units_a_p_i.html">UnitsAPI</a></em>);</li>
<li>Basic interpreter of expressions that facilitates the creation of customized scripting tools, generic definition of expressions and so on (see package <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_expr_intrp.html">ExprIntrp</a></em>);</li>
<li>Tools for dealing with configuration resource files (see package <em>Resource</em>) and customizable message files (see package <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_message.html">Message</a></em>), making it easy to provide a multi-language support in applications;</li>
<li>Progress indication and user break interfaces, giving a possibility even for low-level algorithms to communicate with the user in a universal and convenient way.</li>
</ul>
<h1><a class="anchor" id="occt_fcug_2"></a>
Basics</h1>
<p>This chapter deals with basic services such as library organization, persistence, data types, memory management, programming with handles, exception handling, genericity by downcasting and plug-in creation.</p>
<h2><a class="anchor" id="occt_fcug_2_a"></a>
Library organization</h2>
<p>This chapter introduces some basic concepts, which are used not only in Foundation Classes, but throughout the whole OCCT library.</p>
<h3><a class="anchor" id="occt_fcug_2_a_1"></a>
Modules and toolkits</h3>
<p>The whole OCCT library is organized in a set of modules. The first module, providing most basic services and used by all other modules, is called Foundation Classes and described by this manual.</p>
<p>Every module consists primarily of one or several toolkits (though it can also contain executables, resource units etc.). Physically a toolkit is represented by a shared library (e.g. .so or .dll). The toolkit is built from one or several packages.</p>
<h3><a class="anchor" id="occt_fcug_2_a_2"></a>
Packages</h3>
<p>A <b>package</b> groups together a number of classes which have semantic links. For example, a geometry package would contain Point, Line, and Circle classes. A package can also contain enumerations, exceptions and package methods (functions). In practice, a class name is prefixed with the name of its package e.g. <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___circle.html">Geom_Circle</a></em>. Data types described in a package may include one or more of the following data types:</p><ul>
<li>Enumerations</li>
<li>Object classes</li>
<li>Exceptions</li>
<li>Pointers to other object classes Inside a package, two data types cannot bear the same name.</li>
</ul>
<div class="image">
<img src="foundation_classes_image003.png" alt="foundation_classes_image003.png"/>
<div class="caption">
Contents of a package</div></div>
<p> <b>Methods</b> are either <b>functions</b> or <b>procedures</b>. Functions return an object, whereas procedures only communicate by passing arguments. In both cases, when the transmitted object is an instance manipulated by a handle, its identifier is passed. There are three categories of methods:</p><ul>
<li><b>Object constructor</b> Creates an instance of the described class. A class will have one or more object constructors with various different arguments or none.</li>
<li><b>Instance method</b> Operates on the instance which owns it.</li>
<li><b>Class method</b> Does not work on individual instances, only on the class itself.</li>
</ul>
<h3><a class="anchor" id="occt_fcug_2_a_3"></a>
Classes</h3>
<p>The fundamental software component in object-oriented software development is the class. A class is the implementation of a <b>data type</b>. It defines its <b>behavior</b> (the services offered by its functions) and its <b>representation</b> (the data structure of the class &ndash; the fields, which store its data).</p>
<p>Classes fall into three categories:</p><ul>
<li>Ordinary classes.</li>
<li>Abstract classes. An <b>abstract class</b> cannot be instantiated. The purpose of having such classes is to have a given behavior shared by a hierarchy of classes and dependent on the implementation of the descendants. This is a way of guaranteeing a certain base of inherited behavior common to all the classes based on a particular deferred class.</li>
<li>Template classes. A <b>template class</b> offers a set of functional behaviors to manipulate other data types. Instantiation of a template class requires that a data type is given for its argument(s).</li>
</ul>
<h3><a class="anchor" id="occt_fcug_2_a_5"></a>
Inheritance</h3>
<p>The purpose of inheritance is to reduce the development workload. The inheritance mechanism allows a new class to be declared already containing the characteristics of an existing class. This new class can then be rapidly specialized for the task in hand. This avoids the necessity of developing each component "from scratch". For example, having already developed a class <em>BankAccount</em> you could quickly specialize new classes: <em>SavingsAccount, LongTermDepositAccount, MoneyMarketAccount, RevolvingCreditAccount</em>, etc....</p>
<p>The corollary of this is that when two or more classes inherit from a parent (or ancestor) class, all these classes guarantee as a minimum the behavior of their parent (or ancestor). For example, if the parent class BankAccount contains the method Print which tells it to print itself out, then all its descendant classes guarantee to offer the same service.</p>
<p>One way of ensuring the use of inheritance is to declare classes at the top of a hierarchy as being <b>abstract</b>. In such classes, the methods are not implemented. This forces the user to create a new class which redefines the methods. This is a way of guaranteeing a certain minimum of behavior among descendant classes.</p>
<h2><a class="anchor" id="occt_fcug_2_1"></a>
Data Types</h2>
<p>An object-oriented language structures a system around data types rather than around the actions carried out on this data. In this context, an <b>object</b> is an <b>instance</b> of a data type and its definition determines how it can be used. Each data type is implemented by one or more classes, which make up the basic elements of the system.</p>
<p>The data types in Open CASCADE Technology fall into two categories:</p><ul>
<li>Data types manipulated by handle (or reference)</li>
<li>Data types manipulated by value</li>
</ul>
<div class="image">
<img src="foundation_classes_image004.png" alt="foundation_classes_image004.png"/>
<div class="caption">
Manipulation of data types</div></div>
<p> A data type is implemented as a class. The class not only defines its data representation and the methods available on instances, but it also suggests how the instance will be manipulated.</p><ul>
<li>A variable of a type manipulated by value contains the instance itself.</li>
<li>A variable of a type manipulated by handle contains a reference to the instance. The first examples of types manipulated by values are the predefined <b>primitive types</b>: <em>Boolean, Character, Integer, Real</em>, etc.</li>
</ul>
<p>A variable of a type manipulated by handle which is not attached to an object is said to be <b>null</b>. To reference an object, we instantiate the class with one of its constructors. For example, in C++:</p>
<div class="fragment"><div class="line">Handle(MyClass) anObject = new MyClass();</div></div><!-- fragment --><p>In Open CASCADE Technology, the Handles are specific classes that are used to safely manipulate objects allocated in the dynamic memory by reference, providing reference counting mechanism and automatic destruction of the object when it is not referenced.</p>
<h3><a class="anchor" id="occt_fcug_2_1_1"></a>
Primitive Types</h3>
<p>The primitive types are predefined in the language and they are <b>manipulated by value</b>.</p>
<ul>
<li><b>Standard_Boolean</b> is used to represent logical data. It may have only two values: <em>Standard_True</em> and <em>Standard_False</em>.</li>
<li><b>Standard_Character</b> designates any ASCII character.</li>
<li><b>Standard_ExtCharacter</b> is an extended character.</li>
<li><b>Standard_Integer</b> is a whole number.</li>
<li><b>Standard_Real</b> denotes a real number (i.e. one with whole and a fractional part, either of which may be null).</li>
<li><b>Standard_ShortReal</b> is a real with a smaller choice of values and memory size.</li>
<li><b>Standard_CString</b> is used for literal constants.</li>
<li><b>Standard_ExtString</b> is an extended string.</li>
<li><b>Standard_Address</b> represents a byte address of undetermined size.</li>
</ul>
<p>The services offered by each of these types are described in the <b><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_standard.html">Standard</a></b> Package. The table below presents the equivalence existing between C++ fundamental types and OCCT primitive types.</p>
<p><b>Table 1: Equivalence between C++ Types and OCCT Primitive Types</b></p>
<table class="doxtable">
<tr>
<th align="left">C++ Types </th><th align="left">OCCT Types  </th></tr>
<tr>
<td align="left">int </td><td align="left">Standard_Integer </td></tr>
<tr>
<td align="left">double </td><td align="left">Standard_Real </td></tr>
<tr>
<td align="left">float </td><td align="left">Standard_ShortReal </td></tr>
<tr>
<td align="left">bool </td><td align="left">Standard_Boolean </td></tr>
<tr>
<td align="left">char </td><td align="left">Standard_Character </td></tr>
<tr>
<td align="left">char16_t </td><td align="left">Standard_Utf16Char </td></tr>
<tr>
<td align="left">char* </td><td align="left">Standard_CString </td></tr>
<tr>
<td align="left">void* </td><td align="left">Standard_Address </td></tr>
<tr>
<td align="left">char16_t* </td><td align="left">Standard_ExtString </td></tr>
</table>
<ul>
<li>The types with asterisk are pointers.</li>
</ul>
<p><b>Reminder of the classes listed above:</b></p>
<ul>
<li><b>Standard_Integer</b>: fundamental type representing 32-bit integers yielding negative, positive or null values. <em>Integer</em> is implemented as a <em>typedef</em> of the C++ <em>int</em> fundamental type. As such, the algebraic operations +, -, *, / as well as the ordering and equivalence relations &lt;, &lt;=, ==, !=, &gt;=, &gt; are defined on it.</li>
<li><b>Standard_Real</b>: fundamental type representing real numbers with finite precision and finite size. <b>Real</b> is implemented as a <em>typedef</em> of the C++ <em>double</em> (double precision) fundamental type. As such, the algebraic operations +, -, *, /, unary- and the ordering and equivalence relations &lt;, &lt;=, ==, !=, &gt;=, &gt; are defined on reals.</li>
<li><b>Standard_ShortReal</b>: fundamental type representing real numbers with finite precision and finite size. <em>ShortReal</em> is implemented as a <em>typedef</em> of the C++ <em>float</em> (single precision) fundamental type. As such, the algebraic operations +, -, *, /, unary- and the ordering and equivalence relations &lt;, &lt;=, ==, !=, &gt;=, &gt; are defined on reals.</li>
<li><b>Standard_Boolean</b>: fundamental type representing logical expressions. It has two values: <em>false</em> and <em>true</em>. <em>Boolean</em> is implemented as a <em>typedef</em> of the C++ <em>bool</em> fundamental type. As such, the algebraic operations <em>and, or, xor</em> and <em>not</em> as well as equivalence relations == and != are defined on Booleans.</li>
<li><b>Standard_Character</b>: fundamental type representing the UTF-8 character set. <em>Character</em> is implemented as a <em>typedef</em> of the C++ <em>char</em> fundamental type. As such, the ordering and equivalence relations &lt;, &lt;=, ==, !=, &gt;=, &gt; are defined on characters using the order of the ASCII chart (ex: A B).</li>
<li><b>Standard_ExtCharacter</b>: fundamental type representing the UTF-16 character set. It is a 16-bit character type. <em>ExtCharacter</em> is implemented as a <em>typedef</em> of the C++ <em>char16_t</em> fundamental type. As such, the ordering and equivalence relations &lt;, &lt;=, ==, !=, &gt;=, &gt; are defined on extended characters using the order of the UNICODE chart (ex: A B).</li>
<li><b>Standard_CString</b>: fundamental type representing string literals. A string literal is a sequence of UTF-8 (8 bits) code points enclosed in double quotes. <em>CString</em> is implemented as a <em>typedef</em> of the C++ <em>char</em> fundamental type.</li>
<li><b>Standard_Address</b>: fundamental type representing a generic pointer. <em>Address</em> is implemented as a <em>typedef</em> of the C++ <em>void</em> fundamental type.</li>
<li><b>Standard_ExtString</b>: fundamental type representing string literals as sequences of Unicode (16 bits) characters. <em>ExtString</em> is implemented as a <em>typedef</em> of the C++ <em>char16_t</em> fundamental type.</li>
</ul>
<h3><a class="anchor" id="occt_fcug_2_1_2"></a>
Types manipulated by value</h3>
<p>There are three categories of types which are manipulated by value:</p><ul>
<li>Primitive types</li>
<li>Enumerated types</li>
<li>Types defined by classes not inheriting from <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_standard___transient.html">Standard_Transient</a></em>, whether directly or not. Types which are manipulated by value behave in a more direct fashion than those manipulated by handle and thus can be expected to perform operations faster, but they cannot be stored independently in a file.</li>
</ul>
<div class="image">
<img src="foundation_classes_image005.png" alt="foundation_classes_image005.png"/>
<div class="caption">
Manipulation of a data type by value</div></div>
 <h3><a class="anchor" id="occt_fcug_2_1_3"></a>
Types manipulated by reference (handle)</h3>
<p>These are types defined by classes inheriting from the <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_standard___transient.html">Standard_Transient</a></em> class.</p>
<div class="image">
<img src="foundation_classes_image006.png" alt="foundation_classes_image006.png"/>
<div class="caption">
Manipulation of a data type by reference</div></div>
 <h3><a class="anchor" id="occt_fcug_2_1_4"></a>
When is it necessary to use a handle?</h3>
<p>When you design an object, it can be difficult to choose how to manipulate that object: by value or by handle. The following ideas can help you to make up your mind:</p><ul>
<li>If your object may have a long lifetime within the application and you want to make multiple references to it, it would be preferable to manipulate this object with a handle. The memory for the object will be allocated on the heap. The handle which points to that memory is a light object which can be rapidly passed in argument. This avoids the penalty of copying a large object.</li>
<li>If your object will have a limited lifetime, for example, used within a single algorithm, it would be preferable to manipulate this object by value, non-regarding its size, because this object is allocated on the stack and the allocation and de-allocation of memory is extremely rapid, which avoids the implicit calls to <em>new</em> and <em>delete</em> occasioned by allocation on the heap.</li>
<li>Finally, if an object will be created only once during, but will exist throughout the lifetime of the application, the best choice may be a class manipulated by handle or a value declared as a global variable.</li>
</ul>
<h2><a class="anchor" id="occt_fcug_2_2"></a>
Programming with Handles</h2>
<h3><a class="anchor" id="occt_fcug_2_2_1"></a>
Handle Definition</h3>
<p>A handle is OCCT implementation of a smart pointer. Several handles can reference the same object. Also, a single handle may reference several objects, but only one at a time. To have access to the object it refers to, the handle must be de-referenced just as with a C++ pointer.</p>
<h4>Organization of Classes</h4>
<p>Class <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_standard___transient.html">Standard_Transient</a></em> is a root of a big hierarchy of OCCT classes that are said to be operable by handles. It provides a reference counter field, inherited by all its descendant classes, that is used by associated <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle()</a></em> classes to track a number of handles pointing to this instance of the object.</p>
<p>Objects of classes derived (directly or indirectly) from <em>Transient</em>, are normally allocated in dynamic memory using operator <b>new</b>, and manipulated by handle. Handle is defined as template class <em>opencascade::handle&lt;&gt;</em>. Open CASCADE Technology provides preprocessor macro <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle()</a></em> that is historically used throughout OCCT code to name a handle: </p><div class="fragment"><div class="line"><a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle</a>(<a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___line.html">Geom_Line</a>) aLine; <span class="comment">// &quot;Handle(Geom_Line)&quot; is expanded to &quot;opencascade::handle&lt;Geom_Line&gt;&quot;</span></div></div><!-- fragment --><p>In addition, for most OCCT classes additional <em>typedef</em> is defined for a handle, as the name of a class prefixed by <em>Handle_</em>. For instance, the above example can be also coded as: </p><div class="fragment"><div class="line">Handle_Geom_Line aLine; <span class="comment">// &quot;Handle_Geom_Line&quot; is typedef to &quot;opencascade::handle&lt;Geom_Line&gt;&quot;</span></div></div><!-- fragment --><h4>Using a Handle</h4>
<p>A handle is characterized by the object it references.</p>
<p>Before performing any operation on a transient object, you must declare the handle. For example, if Point and Line are two transient classes from the Geom package, you would write: </p><div class="fragment"><div class="line">Handle(Geom_Point) p1, p2;</div></div><!-- fragment --><p> Declaring a handle creates a null handle that does not refer to any object. The handle may be checked to be null by its method <em>IsNull()</em>. To nullify a handle, use method <em>Nullify()</em>.</p>
<p>To initialize a handle, either a new object should be created or the value of another handle can be assigned to it, on condition that their types are compatible.</p>
<p><b>Note</b> that handles should only be used for object sharing. For all local operations, it is advisable to use classes manipulated by values.</p>
<h3><a class="anchor" id="occt_fcug_2_2_2"></a>
Type Management</h3>
<p>Open CASCADE Technology provides a means to describe the hierarchy of data types in a generic way, with a possibility to check the exact type of the given object at run-time (similarly to C++ RTTI).</p>
<p>To enable this feature, a class declaration should include the declaration of OCCT RTTI. Header <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_8hxx.html">Standard_Type.hxx</a></em> provides two variants of preprocessor macros facilitating this:</p>
<ul>
<li>Inline variant, which declares and defines RTTI methods by a single line of code: <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_geom___surface_8hxx.html">Geom_Surface.hxx</a>&gt;</span></div><div class="line"><span class="keyword">class </span>Appli_ExtSurface : <span class="keyword">public</span> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___surface.html">Geom_Surface</a></div><div class="line">{</div><div class="line">. . .</div><div class="line">public:</div><div class="line">  <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_8hxx.html#a2c2c6b8f398d48a75e5f704b3e8b0b12">DEFINE_STANDARD_RTTIEXT</a>(Appli_ExtSurface,<a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___surface.html">Geom_Surface</a>)</div><div class="line">};</div></div><!-- fragment --></li>
<li><p class="startli">Out-of line variant, which uses one macro in the declaration (normally in the header file), and another in the implementation (in C++ source):</p>
<p class="startli">In <em>Appli_ExtSurface.hxx</em> file: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_geom___surface_8hxx.html">Geom_Surface.hxx</a>&gt;</span></div><div class="line"><span class="keyword">class </span>Appli_ExtSurface : <span class="keyword">public</span> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___surface.html">Geom_Surface</a></div><div class="line">{</div><div class="line">. . .</div><div class="line">public:</div><div class="line">  <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_8hxx.html#a2c2c6b8f398d48a75e5f704b3e8b0b12">DEFINE_STANDARD_RTTIEXT</a>(Appli_ExtSurface,<a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___surface.html">Geom_Surface</a>)</div><div class="line">};</div></div><!-- fragment --><p class="startli">In <em>Appli_ExtSurface.cxx</em> file: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Appli_ExtSurface.hxx&gt;</span></div><div class="line"><a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_8hxx.html#a112dcb0824701ad4f454c45b065671f5">IMPLEMENT_STANDARD_RTTIEXT</a>(Appli_ExtSurface,<a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___surface.html">Geom_Surface</a>)</div></div><!-- fragment --></li>
</ul>
<p>These macros define method <em>DynamicType()</em> that returns a type descriptor - handle to singleton instance of the class <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_standard___type.html">Standard_Type</a></em> describing the class. The type descriptor stores the name of the class and the descriptor of its parent class.</p>
<p>Note that while inline version is easier to use, for widely used classes this method may lead to bloating of binary code of dependent libraries, due to multiple instantiations of inline method.</p>
<p>To get the type descriptor for a given class type, use macro <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_8hxx.html#aea8b57a4fa80060017fe460aab588ed8">STANDARD_TYPE()</a></em> with the name of the class as argument.</p>
<p>Example of usage: </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (aCurve-&gt;IsKind(<a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_8hxx.html#aea8b57a4fa80060017fe460aab588ed8">STANDARD_TYPE</a>(<a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___line.html">Geom_Line</a>))) <span class="comment">// equivalent to &quot;if (dynamic_cast&lt;Geom_Line&gt;(aCurve.get()) != 0)&quot;</span></div><div class="line">{</div><div class="line">...</div><div class="line">}</div></div><!-- fragment --><h4>Type Conformity</h4>
<p>The type used in the declaration of a handle is the static type of the object, the type seen by the compiler. A handle can reference an object instantiated from a subclass of its static type. Thus, the dynamic type of an object (also called the actual type of an object) can be a descendant of the type which appears in the handle declaration through which it is manipulated.</p>
<p>Consider the class <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___cartesian_point.html">Geom_CartesianPoint</a></em>, a sub-class of <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___point.html">Geom_Point</a></em>; the rule of type conformity can be illustrated as follows:</p>
<div class="fragment"><div class="line">Handle(Geom_Point) aPnt1;</div><div class="line">Handle(Geom_CartesianPoint) aPnt2;</div><div class="line">aPnt2 = new Geom_CartesianPoint();</div><div class="line">aPnt1 = aPnt2;  // OK, the types are compatible</div></div><!-- fragment --><p>The compiler sees <em>aPnt1</em> as a handle to <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___point.html">Geom_Point</a></em> though the actual object referenced by <em>aPnt1</em> is of the <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___cartesian_point.html">Geom_CartesianPoint</a></em> type.</p>
<h4>Explicit Type Conversion</h4>
<p>According to the rule of type conformity, it is always possible to go up the class hierarchy through successive assignments of handles. On the other hand, assignment does not authorize you to go down the hierarchy. Consequently, an explicit type conversion of handles is required.</p>
<p>A handle can be converted explicitly into one of its sub-types if the actual type of the referenced object is a descendant of the object used to cast the handle. If this is not the case, the handle is nullified (explicit type conversion is sometimes called a "safe cast"). Consider the example below.</p>
<div class="fragment"><div class="line">Handle(Geom_Point) aPnt1;</div><div class="line">Handle(Geom_CartesianPoint) aPnt2, aPnt3;</div><div class="line">aPnt2 = new Geom_CartesianPoint();</div><div class="line">aPnt1 = aPnt2; // OK, standard assignment</div><div class="line">aPnt3 = Handle(Geom_CartesianPoint)::DownCast (aPnt1);</div><div class="line">// OK, the actual type of aPnt1 is Geom_CartesianPoint, although the static type of the handle is Geom_Point</div></div><!-- fragment --><p>If conversion is not compatible with the actual type of the referenced object, the handle which was "cast" becomes null (and no exception is raised). So, if you require reliable services defined in a sub-class of the type seen by the handle (static type), write as follows:</p>
<div class="fragment"><div class="line">void MyFunction (const Handle(A) &amp; a)</div><div class="line">{</div><div class="line">  Handle(B) b =  Handle(B)::DownCast(a);</div><div class="line">  if (! b.IsNull()) {</div><div class="line">    // we can use “b” if class B inherits from A</div><div class="line">  }</div><div class="line">  else {</div><div class="line">    // the types are incompatible</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p> Downcasting is used particularly with collections of objects of different types; however, these objects should inherit from the same root class.</p>
<p>For example, with a sequence of transient objects <em>TColStd_SequenceOfTransient</em> and two classes A and B that both inherit from <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_standard___transient.html">Standard_Transient</a></em>, you get the following syntax:</p>
<div class="fragment"><div class="line">Handle(A) a;</div><div class="line">Handle(B) b;</div><div class="line">Handle(Standard_Transient) t;</div><div class="line">TColStd_SequenceOfTransient aSeq;</div><div class="line">a = new A();</div><div class="line">aSeq.Append (a);</div><div class="line">b = new B();</div><div class="line">aSeq.Append (b);</div><div class="line">t = aSeq.Value (1);</div><div class="line">// here, you cannot write:</div><div class="line">// a = t; // ERROR !</div><div class="line">// so you downcast:</div><div class="line">a = Handle (A)::Downcast (t)</div><div class="line">if (!a.IsNull())</div><div class="line">{</div><div class="line">  // types are compatible, you can use a</div><div class="line">}</div><div class="line">else</div><div class="line">{</div><div class="line">  // the types are incompatible</div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="occt_fcug_2_2_3"></a>
Using Handles to Create Objects</h3>
<p>To create an object which is manipulated by handle, declare the handle and initialize it with the standard C++ <b>new</b> operator, immediately followed by a call to the constructor. The constructor can be any of those specified in the source of the class from which the object is instanced.</p>
<div class="fragment"><div class="line">Handle(Geom_CartesianPoint) aPnt;</div><div class="line">aPnt = new Geom_CartesianPoint (0, 0, 0);</div></div><!-- fragment --><p>Unlike for a pointer, the <b>delete</b> operator does not work on a handle; the referenced object is automatically destroyed when no longer in use.</p>
<h3><a class="anchor" id="occt_fcug_2_2_4"></a>
Invoking Methods</h3>
<p>Once you have a handle to an object, you can use it like a pointer in C++. To invoke a method which acts on the referenced object, you translate this method by the standard <em>arrow</em> operator, or alternatively, by function call syntax when this is available.</p>
<p>To test or to modify the state of the handle, the method is translated by the <em>dot</em> operator. The example below illustrates how to access the coordinates of an (optionally initialized) point object:</p>
<div class="fragment"><div class="line">Handle(Geom_CartesianPoint) aCentre;</div><div class="line">Standard_Real x, y, z;</div><div class="line">if (aCentre.IsNull())</div><div class="line">{</div><div class="line">  aCentre = new PGeom_CartesianPoint (0, 0, 0);</div><div class="line">}</div><div class="line">aCentre-&gt;Coord (x, y, z);</div></div><!-- fragment --><p>The example below illustrates how to access the type object of a Cartesian point:</p>
<div class="fragment"><div class="line">Handle(Standard_Transient) aPnt = new Geom_CartesianPoint (0., 0., 0.);</div><div class="line">if (aPnt-&gt;DynamicType() == STANDARD_TYPE(Geom_CartesianPoint))</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; &quot;Type check OK\n&quot;;</div><div class="line">}</div><div class="line">else</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; &quot;Type check FAILED\n&quot;;</div><div class="line">}</div></div><!-- fragment --><p><em>Standard_NullObject</em> exception will be raised if a field or a method of an object is accessed via a <em>Null</em> handle.</p>
<h4>Invoking Class Methods</h4>
<p>A class method is called like a static C++ function, i.e. it is called by the name of the class of which it is a member, followed by the “::” operator and the name of the method.</p>
<p>For example, we can find the maximum degree of a Bezier curve:</p>
<div class="fragment"><div class="line">Standard_Integer aDegree = Geom_BezierCurve::MaxDegree();</div></div><!-- fragment --><h3><a class="anchor" id="occt_fcug_2_2_5"></a>
Handle deallocation</h3>
<p>Before you delete an object, you must ensure it is no longer referenced. To reduce the programming load related to this management of object life, the delete function in Open CASCADE Technology is secured by a <b>reference counter</b> of classes manipulated by handle. A handle automatically deletes an object when it is no longer referenced. Normally you never call the delete operator explicitly on instances of subclasses of <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_standard___transient.html">Standard_Transient</a></em>.</p>
<p>When a new handle to the same object is created, the reference counter is incremented. When the handle is destroyed, nullified, or reassigned to another object, that counter is decremented. The object is automatically deleted by the handle when reference counter becomes 0.</p>
<p>The principle of allocation can be seen in the example below.</p>
<div class="fragment"><div class="line">...</div><div class="line">{</div><div class="line">  Handle(TColStd_HSequenceOfInteger) H1 = new TColStd_HSequenceOfInteger();</div><div class="line">  // H1 has one reference and corresponds to 48 bytes of  memory</div><div class="line">  {</div><div class="line">    Handle(TColStd_HSequenceOfInteger) H2;</div><div class="line">    H2 = H1; // H1 has two references</div><div class="line">    if (argc == 3)</div><div class="line">    {</div><div class="line">      Handle(TColStd_HSequenceOfInteger) H3;</div><div class="line">      H3 = H1;</div><div class="line">      // Here, H1 has three references</div><div class="line">      ...</div><div class="line">    }</div><div class="line">    // Here, H1 has two references</div><div class="line">  }</div><div class="line">  // Here, H1 has 1 reference</div><div class="line">}</div><div class="line">// Here, H1 has no reference and the referred TColStd_HSequenceOfInteger object is deleted.</div></div><!-- fragment --><p>You can easily cast a reference to the handle object to <em> void* </em> by defining the following:</p>
<div class="fragment"><div class="line">void* aPointer;</div><div class="line">Handle(Some_Class) aHandle;</div><div class="line">// Here only a pointer will be copied</div><div class="line">aPointer = &amp;aHandle;</div><div class="line">// Here the Handle object will be copied</div><div class="line">aHandle = *(Handle(Some_Class)*)aPointer;</div></div><!-- fragment --><h3><a class="anchor" id="occt_fcug_2_2_6"></a>
Cycles</h3>
<p>Cycles appear if two or more objects reference each other by handles (stored as fields). In this condition automatic destruction will not work.</p>
<p>Consider for example a graph, whose objects (primitives) have to know the graph object to which they belong, i.e. a primitive must have a reference to complete graph object. If both primitives and the graph are manipulated by handle and they refer to each other by keeping a handle as a field, the cycle appears.</p>
<p>The graph object will not be deleted when the last handle to it is destructed in the application, since there are handles to it stored inside its own data structure (primitives).</p>
<p>There are two approaches how to avoid such situation:</p><ul>
<li>Use C++ pointer for one kind of references, e.g. from a primitive to the graph</li>
<li>Nullify one set of handles (e.g. handles to a graph in primitives) when a graph object needs to be destroyed</li>
</ul>
<h2><a class="anchor" id="occt_fcug_2_3"></a>
Memory Management</h2>
<p>In a work session, geometric modeling applications create and delete a considerable number of C++ objects allocated in the dynamic memory (heap). In this context, performance of standard functions for allocating and deallocating memory may be not sufficient. For this reason, Open CASCADE Technology employs a specialized memory manager implemented in the <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_standard.html">Standard</a></em> package.</p>
<p>The Memory Manager is based on the following principles:</p>
<ul>
<li>small memory arrays are grouped into clusters and then recycled (clusters are never released to the system),</li>
<li>large arrays are allocated and de-allocated through the standard functions of the system (the arrays are released to system when they are no longer used).</li>
</ul>
<p>As a general rule, it is advisable to allocate memory through significant blocks. In this way, the user can work with blocks of contiguous data and it facilitates memory page manager processing.</p>
<h3><a class="anchor" id="occt_fcug_2_3_1"></a>
Usage of Memory Manager</h3>
<p>To allocate memory in a C code with Open CASCADE Technology memory manager, simply use method <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_standard.html#aaaaa204e9cefcae7bafb6da8b941b46a">Standard::Allocate()</a></em> instead of <em>malloc()</em> and method <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_standard.html#a6ef68946681e34cafcf847e1695bd600">Standard::Free()</a></em> instead of <em>free()</em>. In addition, method <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_standard.html#ac647821c881c743e711d48df9e826bd0">Standard::Reallocate()</a></em> is provided to replace C function <em>realloc()</em>.</p>
<p>In C++, operators <em>new()</em> and <em>delete()</em> for a class may be defined so as to allocate memory using <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_standard.html#aaaaa204e9cefcae7bafb6da8b941b46a">Standard::Allocate()</a></em> and free it using <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_standard.html#a6ef68946681e34cafcf847e1695bd600">Standard::Free()</a></em>. In that case all objects of that class and all inherited classes will be allocated using the OCCT memory manager.</p>
<p>Preprocessor macro <em>DEFINE_STANDARD_ALLOC</em> provided by header <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___define_alloc_8hxx.html">Standard_DefineAlloc.hxx</a></em> defines <em>new()</em> and <em>delete()</em> in this way. It is used for all OCCT classes (apart from a few exceptions) which thus are allocated using the OCCT memory manager. Since operators <em>new()</em> and <em>delete()</em> are inherited, this is also true for any class derived from an OCCT class, for instance, for all classes derived from <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_standard___transient.html">Standard_Transient</a></em>.</p>
<p><b>Note</b> that it is possible (though not recommended unless really unavoidable) to redefine <em>new()</em> and <em>delete()</em> functions for a class inheriting <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_standard___transient.html">Standard_Transient</a></em>. If that is done, the method <em>Delete()</em> should be also redefined to apply operator <em>delete</em> to this pointer. This will ensure that appropriate <em>delete()</em> function will be called, even if the object is manipulated by a handle to a base class.</p>
<h3><a class="anchor" id="occt_fcug_2_3_2"></a>
How to configure the Memory Manager</h3>
<p>The OCCT memory manager may be configured to apply different optimization techniques to different memory blocks (depending on their size), or even to avoid any optimization and use C functions <em>malloc()</em> and <em>free()</em> directly. The configuration is defined by numeric values of the following environment variables:</p><ul>
<li><em>MMGT_OPT</em>:<ul>
<li>if set to 0 (default) every memory block is allocated in C memory heap directly (via <em>malloc()</em> and <em>free()</em> functions). In this case, all other options except for <em>MMGT_CLEAR</em> are ignored;</li>
<li>if set to 1 the memory manager performs optimizations as described below;</li>
<li>if set to 2, Intel ® TBB optimized memory manager is used.</li>
</ul>
</li>
<li><em>MMGT_CLEAR</em>: if set to 1 (default), every allocated memory block is cleared by zeros; if set to 0, memory block is returned as it is.</li>
<li><em>MMGT_CELLSIZE</em>: defines the maximal size of blocks allocated in large pools of memory. Default is 200.</li>
<li><em>MMGT_NBPAGES</em>: defines the size of memory chunks allocated for small blocks in pages (operating-system dependent). Default is 1000.</li>
<li><em>MMGT_THRESHOLD</em>: defines the maximal size of blocks that are recycled internally instead of being returned to the heap. Default is 40000.</li>
<li><em>MMGT_MMAP</em>: when set to 1 (default), large memory blocks are allocated using memory mapping functions of the operating system; if set to 0, they will be allocated in the C heap by <em>malloc()</em>.</li>
</ul>
<h3><a class="anchor" id="occt_fcug_2_3_3"></a>
Optimization Techniques</h3>
<p>When <em>MMGT_OPT</em> is set to 1, the following optimization techniques are used:</p><ul>
<li>Small blocks with a size less than <em>MMGT_CELLSIZE</em>, are not allocated separately. Instead, a large pools of memory are allocated (the size of each pool is <em>MMGT_NBPAGES</em> pages). Every new memory block is arranged in a spare place of the current pool. When the current memory pool is completely occupied, the next one is allocated, and so on.</li>
</ul>
<p>In the current version memory pools are never returned to the system (until the process finishes). However, memory blocks that are released by the method <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_standard.html#a6ef68946681e34cafcf847e1695bd600">Standard::Free()</a></em> are remembered in the free lists and later reused when the next block of the same size is allocated (recycling).</p>
<ul>
<li>Medium-sized blocks, with a size greater than <em>MMGT_CELLSIZE</em> but less than <em>MMGT_THRESHOLD</em>, are allocated directly in the C heap (using <em>malloc()</em> and <em>free()</em>). When such blocks are released by the method <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_standard.html#a6ef68946681e34cafcf847e1695bd600">Standard::Free()</a></em> they are recycled just like small blocks.</li>
</ul>
<p>However, unlike small blocks, the recycled medium blocks contained in the free lists (i.e. released by the program but held by the memory manager) can be returned to the heap by method <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_standard.html#a43397890a8833b0bdd98d0f888ae0cf1">Standard::Purge()</a></em>.</p>
<ul>
<li>Large blocks with a size greater than <em>MMGT_THRESHOLD</em>, including memory pools used for small blocks, are allocated depending on the value of <em>MMGT_MMAP</em>: if it is 0, these blocks are allocated in the C heap; otherwise they are allocated using operating-system specific functions managing memory mapped files. Large blocks are returned to the system immediately when <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_standard.html#a6ef68946681e34cafcf847e1695bd600">Standard::Free()</a></em> is called.</li>
</ul>
<h3><a class="anchor" id="occt_fcug_2_3_4"></a>
Benefits and drawbacks</h3>
<p>The major benefit of the OCCT memory manager is explained by its recycling of small and medium blocks that makes an application work much faster when it constantly allocates and frees multiple memory blocks of similar sizes. In practical situations, the real gain on the application performance may be up to 50%.</p>
<p>The associated drawback is that recycled memory is not returned to the operating system during program execution. This may lead to considerable memory consumption and even be misinterpreted as a memory leak. To minimize this effect it is necessary to call the method <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_standard.html#a43397890a8833b0bdd98d0f888ae0cf1">Standard::Purge</a></em> after the completion of memory-intensive operations.</p>
<p>The overhead expenses induced by the OCCT memory manager are:</p><ul>
<li>size of every allocated memory block is rounded up to 8 bytes (when <em>MMGT_OPT</em> is 0 (default), the rounding is defined by the CRT; the typical value for 32-bit platforms is 4 bytes)</li>
<li>additional 4 bytes (or 8 on 64-bit platforms) are allocated in the beginning of every memory block to hold its size (or address of the next free memory block when recycled in free list) only when <em>MMGT_OPT</em> is 1.</li>
</ul>
<p>Note that these overheads may be greater or less than overheads induced by the C heap memory manager, so overall memory consumption may be greater in either optimized or standard modes, depending on circumstances.</p>
<p>As a general rule, it is advisable to allocate memory through significant blocks. In this way, you can work with blocks of contiguous data, and processing is facilitated for the memory page manager.</p>
<p>OCCT memory manager uses mutex to lock access to free lists, therefore it may have less performance than non-optimized mode in situations when different threads often make simultaneous calls to the memory manager. The reason is that modern implementations of <em>malloc()</em> and <em>free()</em> employ several allocation arenas and thus avoid delays waiting mutex release, which are possible in such situations.</p>
<h2><a class="anchor" id="occt_fcug_2_4"></a>
Exceptions</h2>
<h3><a class="anchor" id="occt_fcug_2_4_1"></a>
Introduction</h3>
<p>The behavior of any object is implemented by the methods, which were defined in its class declaration. The definition of these methods includes not only their signature (their programming interface) but also their domain of validity.</p>
<p>This domain is expressed by <b>exceptions</b>. Exceptions are raised under various error conditions to protect software quality.</p>
<p>Exception handling provides a means of transferring control from a given point in a program being executed to an <b>exception handler</b> associated with another point previously executed.</p>
<p>A method may raise an exception which interrupts its normal execution and transfers control to the handler catching this exception.</p>
<p>A hierarchy of commonly used exception classes is provided. The root class is <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_standard___failure.html">Standard_Failure</a></em> from the <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_standard.html">Standard</a></em> package. So each exception inherits from <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_standard___failure.html">Standard_Failure</a></em> either directly or by inheriting from another exception. Exception classes list all exceptions, which can be raised by any OCCT function.</p>
<p>Open CASCADE Technology also provides support for converting system signals (such as access violation or division by zero) to exceptions, so that such situations can be safely handled with the same uniform approach.</p>
<p>However, in order to support this functionality on various platforms, some special methods and workarounds are used. Though the implementation details are hidden and handling of OCCT exceptions is done basically in the same way as with C++, some peculiarities of this approach shall be taken into account and some rules must be respected.</p>
<p>The following paragraphs describe recommended approaches for using exceptions when working with Open CASCADE Technology.</p>
<h3><a class="anchor" id="occt_fcug_2_4_2"></a>
Raising an Exception</h3>
<h4>"C++ like" Syntax</h4>
<p>The following example: </p><div class="fragment"><div class="line">throw Standard_DomainError (&quot;Cannot cope with this condition&quot;);</div></div><!-- fragment --><p> raises an exception of <em>Standard_DomainError</em> type with the associated message "Cannot cope with this condition", the message being optional. This exception may be caught by a handler of a <em>Standard_DomainError</em> type as follows: </p><div class="fragment"><div class="line">try</div><div class="line">{</div><div class="line">  OCC_CATCH_SIGNALS</div><div class="line">  // try block</div><div class="line">}</div><div class="line">catch (const Standard_DomainError&amp; )</div><div class="line">{</div><div class="line">  // handle Standard_DomainError exceptions here</div><div class="line">}</div></div><!-- fragment --><h4>Regular usage</h4>
<p>Exceptions should not be used as a programming technique, to replace a "goto" statement for example, but as a way to protect methods against misuse. The caller must make sure its condition is such that the method can cope with it.</p>
<p>Thus,</p><ul>
<li>No exception should be raised during normal execution of an application.</li>
<li>A method which may raise an exception should be protected by other methods allowing the caller to check on the validity of the call.</li>
</ul>
<p>For example, if you consider the <em>TCollection_Array1</em> class used with:</p><ul>
<li><em>Value</em> function to extract an element;</li>
<li><em>Lower</em> function to extract the lower bound of the array;</li>
<li><em>Upper</em> function to extract the upper bound of the array.</li>
</ul>
<p>then, the <em>Value</em> function may be implemented as follows:</p>
<div class="fragment"><div class="line">Item TCollection_Array1::Value (Standard_Integer theIndex) const</div><div class="line">{</div><div class="line">  // where myR1 and myR2 are the lower and upper bounds of the array</div><div class="line">  if (theIndex &lt; myR1 || theIndex &gt; myR2)</div><div class="line">  {</div><div class="line">    throw Standard_OutOfRange (&quot;Index out of range in TCollection_Array1::Value&quot;);</div><div class="line">  }</div><div class="line">  return myContents[theIndex];</div><div class="line">}</div></div><!-- fragment --><p>Here validity of the index is first verified using the Lower and Upper functions in order to protect the call. Normally the caller ensures the index being in the valid range before calling <em>Value()</em>. In this case the above implementation of <em>Value</em> is not optimal since the test done in <em>Value</em> is time-consuming and redundant.</p>
<p>It is a widely used practice to include that kind of protections in a debug build of the program and exclude in release (optimized) build. To support this practice, the macros <em>Raise_if()</em> are provided for every OCCT exception class: </p><div class="fragment"><div class="line">&lt;ErrorTypeName&gt;_Raise_if(condition, &quot;Error message&quot;);</div></div><!-- fragment --><p> where <em>ErrorTypeName</em> is the exception type, <em>condition</em> is the logical expression leading to the raise of the exception, and <em>Error message</em> is the associated message.</p>
<p>The entire call may be removed by defining one of the preprocessor symbols <em>No_Exception</em> or <em>No_&lt;ErrorTypeName&gt;</em> at compile-time:</p>
<div class="fragment"><div class="line">#define No_Exception // remove all raises</div></div><!-- fragment --><p>Using this syntax, the <em>Value</em> function becomes:</p>
<div class="fragment"><div class="line">Item TCollection_Array1::Value (Standard_Integer theIndex) const</div><div class="line">{</div><div class="line">  Standard_OutOfRange_Raise_if(theIndex &lt; myR1 || theIndex &gt; myR2, &quot;index out of range in TCollection_Array1::Value&quot;);</div><div class="line">  return myContents[theIndex];</div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="occt_fcug_2_4_3"></a>
Handling an Exception</h3>
<p>When an exception is raised, control is transferred to the nearest handler of a given type in the call stack, that is:</p><ul>
<li>the handler whose try block was most recently entered and not yet exited,</li>
<li>the handler whose type matches the raise expression.</li>
</ul>
<p>A handler of T exception type is a match for a raise expression with an exception type of E if:</p><ul>
<li>T and E are of the same type, or</li>
<li>T is a supertype of E.</li>
</ul>
<p>In order to handle system signals as exceptions, make sure to insert macro <em>OCC_CATCH_SIGNALS</em> somewhere in the beginning of the relevant code. The recommended location for it is first statement after opening brace of <em>try {}</em> block.</p>
<p>As an example, consider the exceptions of type <em>Standard_NumericError, Standard_Overflow, Standard_Underflow</em> and <em>Standard_DivideByZero</em>, where <em>Standard_NumericError</em> is the parent type of the three others.</p>
<div class="fragment"><div class="line">void f(1)</div><div class="line">{</div><div class="line">  try</div><div class="line">  {</div><div class="line">    OCC_CATCH_SIGNALS</div><div class="line">    // try block</div><div class="line">  }</div><div class="line">  catch (const Standard_Overflow&amp; ) // first handler</div><div class="line">  {</div><div class="line">    // ...</div><div class="line">  }</div><div class="line">  catch (const Standard_NumericError&amp; ) // second handler</div><div class="line">  {</div><div class="line">    // ...</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>Here, the first handler will catch exceptions of <em>Standard_Overflow</em> type and the second one &ndash; exceptions of <em>Standard_NumericError</em> type and all exceptions derived from it, including <em>Standard_Underflow</em> and <em>Standard_DivideByZero</em>.</p>
<p>The handlers are checked in order of appearance, from the nearest to the try block to the most distant from it, until one matches the raise expression. For a try block, it would be a mistake to place a handler for a base exception type ahead of a handler for its derived type since that would ensure that the handler for the derived exception would never be invoked.</p>
<div class="fragment"><div class="line">void f(1)</div><div class="line">{</div><div class="line">  int i = 0;</div><div class="line">  {</div><div class="line">    try</div><div class="line">    {</div><div class="line">      OCC_CATCH_SIGNALS</div><div class="line">      g(i);// i is accessible</div><div class="line">    }</div><div class="line">    // statement here will produce compile-time errors !</div><div class="line">    catch (const Standard_NumericError&amp; )</div><div class="line">    {</div><div class="line">      // fix up with possible reuse of i</div><div class="line">    }</div><div class="line">    // statement here may produce unexpected side effect </div><div class="line">  }</div><div class="line">  . . .</div><div class="line">}</div></div><!-- fragment --><p>The exceptions form a hierarchy tree completely separated from other user defined classes. One exception of type <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_standard___failure.html">Standard_Failure</a></em> is the root of the entire exception hierarchy. Thus, using a handler with <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_standard___failure.html">Standard_Failure</a></em> type catches any OCCT exception. It is recommended to set up such a handler in the main routine.</p>
<p>The main routine of a program would look like this:</p>
<div class="fragment"><div class="line">#include &lt;Standard_ErrorHandler.hxx&gt;</div><div class="line">#include &lt;Standard_Failure.hxx&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">int main (int argc, char* argv[])</div><div class="line">{</div><div class="line">  try</div><div class="line">  {</div><div class="line">    OCC_CATCH_SIGNALS</div><div class="line">    // main block</div><div class="line">    return 0;</div><div class="line">  }</div><div class="line">  catch (const Standard_Failure&amp; theFailure)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; &quot;Error &quot; + theFailure.DynamicType()-&gt;Name() &lt;&lt; &quot; [&quot; &lt;&lt; theFailure.GetMessageString() &lt;&lt; &quot;]\n&quot;;</div><div class="line">  }</div><div class="line">  return 1;</div><div class="line">}</div></div><!-- fragment --><p>Though standard C++ scoping rules and syntax apply to try block and handlers, note that on some platforms Open CASCADE Technology may be compiled in compatibility mode when exceptions are emulated by long jumps (see below). In this mode it is required that no statement precedes or follows any handler. Thus it is highly recommended to always include a try block into additional {} braces. Also this mode requires that header file <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___error_handler_8hxx.html">Standard_ErrorHandler.hxx</a></em> be included in your program before a try block, otherwise it may fail to handle Open CASCADE Technology exceptions.</p>
<h4>Catching signals</h4>
<p>In order for the application to be able to catch system signals (access violation, division by zero, etc.) in the same way as other exceptions, the appropriate signal handler shall be installed in the runtime by the method <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_o_s_d.html#ad924a0263c05b6e8f5f80a45ccf6bdc5">OSD::SetSignal()</a></em>.</p>
<p>Normally this method is called in the beginning of the main() function. It installs a handler that will convert system signals into OCCT exceptions.</p>
<p>In order to actually convert signals to exceptions, macro <em>OCC_CATCH_SIGNALS</em> needs to be inserted in the source code. The typical place where this macro is put is beginning of the <em>try{}</em> block which catches such exceptions.</p>
<h3><a class="anchor" id="occt_fcug_2_4_4"></a>
Implementation on various platforms</h3>
<p>The exception handling mechanism in Open CASCADE Technology is implemented in different ways depending on the preprocessor macro <em>OCC_CONVERT_SIGNALS</em>, which shall be consistently defined by compilation procedures for both Open CASCADE Technology and user applications:</p>
<ol type="1">
<li>On Windows, these macros are not defined by default, and normal C++ exceptions are used in all cases, including throwing from signal handler. Thus the behavior is as expected in C++.</li>
<li><p class="startli">On Linux, macro <em>OCC_CONVERT_SIGNALS</em> is defined by default. The C++ exception mechanism is used for catching exceptions and for throwing them from normal code. Since it is not possible to throw C++ exception from system signal handler function, that function makes a long jump to the nearest (in the execution stack) invocation of macro <em>OCC_CATCH_SIGNALS</em>, and only there the C++ exception gets actually thrown. The macro <em>OCC_CATCH_SIGNALS</em> is defined in the file <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___error_handler_8hxx.html">Standard_ErrorHandler.hxx</a></em>. Therefore, including this file is necessary for successful compilation of a code containing this macro.</p>
<p class="startli">This mode differs from standard C++ exception handling only for signals:</p><ul>
<li>macro <em>OCC_CATCH_SIGNALS</em> is necessary (besides call to <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_o_s_d.html#ad924a0263c05b6e8f5f80a45ccf6bdc5">OSD::SetSignal()</a></em> described above) for conversion of signals into exceptions;</li>
<li>the destructors for automatic C++ objects created in the code after that macro and till the place where signal is raised will not be called in case of signal, since no C++ stack unwinding is performed by long jump.</li>
</ul>
</li>
</ol>
<p>In general, for writing platform-independent code it is recommended to insert macros <em>OCC_CATCH_SIGNALS</em> in try {} blocks or other code where signals may happen.</p>
<h2><a class="anchor" id="occt_fcug_2_5"></a>
Plug-In Management</h2>
<h3><a class="anchor" id="occt_fcug_2_5_1"></a>
Distribution by Plug-Ins</h3>
<p>A plug-in is a component that can be loaded dynamically into a client application, not requiring to be directly linked to it. The plug-in is not bound to its client, i.e. the plug-in knows only how its connection mechanism is defined and how to call the corresponding services.</p>
<p>A plug-in can be used to:</p><ul>
<li>implement the mechanism of a <em>driver</em>, i.e dynamically changing a driver implementation according to the current transactions (for example, retrieving a document stored in another version of an application),</li>
<li>restrict processing resources to the minimum required (for example, it does not load any application services at run-time as long as the user does not need them),</li>
<li>facilitate modular development (an application can be delivered with base functions while some advanced capabilities will be added as plug-ins when they are available).</li>
</ul>
<p>The plug-in is identified with the help of the global universal identifier (<a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/struct_g_u_i_d.html">GUID</a>). The <a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/struct_g_u_i_d.html">GUID</a> includes lower case characters and cannot end with a blank space.</p>
<p>Once it has been loaded, the call to the services provided by the plug-in is direct (the client is implemented in the same language as the plug-in).</p>
<h4>C++ Plug-In Implementation</h4>
<p>The C++ plug-in implements a service as an object with functions defined in an abstract class (this abstract class and its parent classes with the <a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/struct_g_u_i_d.html">GUID</a> are the only information about the plug-in implemented in the client application). The plug-in consists of a sharable library including a method named Factory which creates the C++ object (the client cannot instantiate this object because the plug-in implementation is not visible). Foundation classes provide in the package <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_plugin.html">Plugin</a></em> a method named <em>Load()</em>, which enables the client to access the required service through a library.</p>
<p>That method reads the information regarding available plug-ins and their locations from the resource file <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_plugin.html">Plugin</a></em> found by environment variable <em>CSF_PluginDefaults</em>:</p>
<div class="fragment"><div class="line">$CSF_PluginDefaults/Plugin</div></div><!-- fragment --><p>The <em>Load</em> method looks for the library name in the resource file or registry through its <a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/struct_g_u_i_d.html">GUID</a>, for example, on UNIX: </p><div class="fragment"><div class="line">! METADATADRIVER whose value must be OS or DM.</div><div class="line"></div><div class="line">! FW</div><div class="line">a148e300-5740-11d1-a904-080036aaa103.Location: libFWOSPlugin.so</div></div><!-- fragment --><p>Then the <em>Load</em> method loads the library according to the rules of the operating system of the host machine (for example, by using environment variables such as <em>LD_LIBRARY_PATH</em> with Unix and <em>PATH</em> with Windows). After that it invokes the <em>PLUGINFACTORY</em> method to return the object, which supports the required service. The client may then call the functions supported by this object.</p>
<h4>C++ Client Plug-In Implementation</h4>
<p>To invoke one of the services provided by the plug-in, you may call the <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_plugin.html#ae85c78950c2f5dc22616967d75951b00">Plugin::Load()</a></em> global function with the <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_standard___g_u_i_d.html">Standard_GUID</a></em> of the requested service as follows:</p>
<div class="fragment"><div class="line"><a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle</a>(FADriver_PartStorer)::DownCast(PlugIn::Load (yourStandardGUID));</div></div><!-- fragment --><p>Let us take <em>FAFactory.hxx</em> and <em>FAFactory.cxx</em> as an example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___macro_8hxx.html">Standard_Macro.hxx</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___g_u_i_d_8hxx.html">Standard_GUID.hxx</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___transient_8hxx.html">Standard_Transient.hxx</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>FAFactory</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Standard_EXPORT <span class="keyword">static</span> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle</a>(<a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_standard___transient.html">Standard_Transient</a>) Factory (<span class="keyword">const</span> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_standard___g_u_i_d.html">Standard_GUID</a>&amp; theGUID);</div><div class="line">};</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;FAFactory.hxx&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;FADriver_PartRetriever.hxx&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;FADriver_PartStorer.hxx&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;FirstAppSchema.hxx&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___failure_8hxx.html">Standard_Failure.hxx</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;FACDM_Application.hxx&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_plugin___macro_8hxx.html">Plugin_Macro.hxx</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_standard___g_u_i_d.html">Standard_GUID</a> StorageDriver  (<span class="stringliteral">&quot;45b3c690-22f3-11d2-b09e-0000f8791463&quot;</span>);</div><div class="line"><span class="keyword">static</span> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_standard___g_u_i_d.html">Standard_GUID</a> RetrievalDriver(<span class="stringliteral">&quot;45b3c69c-22f3-11d2-b09e-0000f8791463&quot;</span>);</div><div class="line"><span class="keyword">static</span> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_standard___g_u_i_d.html">Standard_GUID</a> Schema         (<span class="stringliteral">&quot;45b3c6a2-22f3-11d2-b09e-0000f8791463&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">//======================================================</span></div><div class="line"><span class="comment">// function : Factory</span></div><div class="line"><span class="comment">// purpose :</span></div><div class="line"><span class="comment">//======================================================</span></div><div class="line"><a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle</a>(<a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_standard___transient.html">Standard_Transient</a>) FAFactory::Factory (<span class="keyword">const</span> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_standard___g_u_i_d.html">Standard_GUID</a>&amp; theGUID)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (theGUID == StorageDriver)</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;FAFactory : Create store driver\n&quot;</span>;</div><div class="line">    <span class="keyword">static</span> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle</a>(FADriver_PartStorer) sd = <span class="keyword">new</span> FADriver_PartStorer();</div><div class="line">    <span class="keywordflow">return</span> sd;</div><div class="line">  }</div><div class="line">  <span class="keywordflow">if</span> (theGUID == RetrievalDriver)</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;FAFactory : Create retrieve driver\n&quot;</span>;</div><div class="line">    <span class="keyword">static</span> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle</a>(FADriver_PartRetriever) rd = <span class="keyword">new</span> FADriver_PartRetriever();</div><div class="line">    <span class="keywordflow">return</span> rd;</div><div class="line">  }</div><div class="line">  <span class="keywordflow">if</span> (theGUID == Schema)</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;FAFactory : Create schema\n&quot;</span>;</div><div class="line">    <span class="keyword">static</span> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle</a>(FirstAppSchema) s = <span class="keyword">new</span> FirstAppSchema();</div><div class="line">    <span class="keywordflow">return</span> s;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">throw</span> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_standard___failure.html">Standard_Failure</a> (<span class="stringliteral">&quot;FAFactory: unknown GUID&quot;</span>);</div><div class="line">  <span class="keywordflow">return</span> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle</a>(<a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_standard___transient.html">Standard_Transient</a>)();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// export plugin function &quot;PLUGINFACTORY&quot;</span></div><div class="line"><a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_plugin___macro_8hxx.html#ae2d16989d3f44ab9c8fe07cb71fad8ac">PLUGIN</a>(FAFactory)</div></div><!-- fragment --><p>Application might also instantiate a factory by linking to the library and calling <em>FAFactory::Factory()</em> directly.</p>
<h1><a class="anchor" id="occt_fcug_3"></a>
Collections, Strings, Quantities and Unit Conversion</h1>
<h2><a class="anchor" id="occt_fcug_3_1"></a>
Collections</h2>
<h3><a class="anchor" id="occt_fcug_3_1_1"></a>
Overview</h3>
<p>The <b>Collections</b> component contains the classes that handle dynamically sized aggregates of data. They include a wide range of collections such as arrays, lists and maps.</p>
<p>Some OCCT collections have close friends in modern STL (standard templates collection), but define a little bit different properties or behavior. OCCT gives user a wider choice, but it is up to user to decide which particular OCCT or STL collection is most suitable for specific algorithm (including performance and usage convenience). OCCT itself highly relies on its own collections for historical reasons - many features implemented by OCCT were unavailable in earlier versions of STL.</p>
<p>Collections classes are <em>generic</em> (C++ templates), that is, they define a structure and algorithms allowing to hold a variety of objects which do not necessarily inherit from a unique root class.</p>
<p>Note that:</p><ul>
<li>Each collection directly used as an argument in OCCT public syntax is instantiated in an OCCT component.</li>
<li>The <em>TColStd</em> package (<b>Collections of <a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_standard.html">Standard</a> Objects</b> component) provides numerous instantiations of these generic collections with objects from the <b><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_standard.html">Standard</a></b> package or from the <b>Strings</b> component.</li>
</ul>
<p>The <b>Collections</b> component provides a wide range of generic collections:</p><ul>
<li><b>Arrays</b> are generally used for a quick access to the item, however an array is a fixed sized aggregate.</li>
<li><b>Sequences</b> are variable-sized structures, they avoid the use of large and quasi-empty arrays. A sequence item is longer to access than an array item: only an exploration in sequence is effective (but sequences are not adapted for numerous explorations). Arrays and sequences are commonly used as data structures for more complex objects.</li>
<li><b>Maps</b> are dynamic structures, where the size is constantly adapted to the number of inserted items and access to an item is the fastest. Maps structures are commonly used in cases of numerous explorations: they are typically internal data structures for complex algorithms.</li>
<li><b>Lists</b> are similar to sequences but have different algorithms to explore them.</li>
<li><b>Acceleration structures</b> are trees or other structures optimized for fast traverse based on locality criteria (like picking objects by ray in 3D).</li>
</ul>
<p>Macro definitions of these classes are stored in <em>NCollection_Define*.hxx</em> files. These definitions are now obsolete though still can be used, particularly for compatibility with the existing code.</p>
<p>Let see an example of NCollection template class instantiation for a sequence of points in the header file <em>MyPackage_SequenceOfPnt.hxx</em> (analogue of <em>TColgp_SequenceOfPnt</em>):</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_n_collection___sequence_8hxx.html">NCollection_Sequence.hxx</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/gp___pnt_8hxx.html">gp_Pnt.hxx</a>&gt;</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___sequence.html">NCollection_Sequence&lt;gp_Pnt&gt;</a> MyPackage_SequenceOfPnt;</div></div><!-- fragment --><p>For the case, when sequence itself should be managed by handle, auxiliary macros <em>DEFINE_HSEQUENCE</em> can be used: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_n_collection___sequence_8hxx.html">NCollection_Sequence.hxx</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_n_collection___define_h_sequence_8hxx.html">NCollection_DefineHSequence.hxx</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/gp___pnt_8hxx.html">gp_Pnt.hxx</a>&gt;</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___sequence.html">NCollection_Sequence&lt;gp_Pnt&gt;</a> MyPackage_SequenceOfPnt;</div><div class="line"><a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_n_collection___define_h_sequence_8hxx.html#aa57ed827fd7a1d74225bfb772aebd1c8">DEFINE_HSEQUENCE</a>(MyPackage_HSequenceOfPnt, MyPackage_SequenceOfPnt)</div><div class="line">...</div><div class="line">Handle(MyPackage_HSequenceOfPnt) aSeq = <span class="keyword">new</span> MyPackage_HSequenceOfPnt();</div></div><!-- fragment --><p>See more details about available collections in following sections.</p>
<h3><a class="anchor" id="occt_fcug_3_1_2"></a>
Arrays and sequences</h3>
<p><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_standard.html">Standard</a> collections provided by OCCT are:</p><ul>
<li><em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___array1.html">NCollection_Array1</a></em> &ndash; fixed-size (at initialization) one-dimensional array; note that the index can start at any value, usually 1;</li>
<li><em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___array2.html">NCollection_Array2</a></em> &ndash; fixed-size (at initialization) two-dimensional array; note that the index can start at any value, usually 1;</li>
<li><em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___list.html">NCollection_List</a></em> &ndash; plain list;</li>
<li><em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___sequence.html">NCollection_Sequence</a></em> &ndash; double-connected list with access by index; note that the index starts at 1;</li>
<li><em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___vector.html">NCollection_Vector</a></em> &ndash; two-step indexed array, expandable in size, but not shrinkable;</li>
<li><em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___sparse_array.html">NCollection_SparseArray</a></em> &ndash; array-alike structure with sparse memory allocation for sequences with discontinuities.</li>
</ul>
<p>These classes provide STL-style iterators (methods begin() and <a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/namespaceopencascade.html#ac9b2829789c77dd61258795f73d3b383">end()</a>) and thus can be used in STL algorithms.</p>
<h5><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___array1.html">NCollection_Array1</a></h5>
<p>These are unidimensional arrays similar to C arrays, i.e. of fixed size but dynamically dimensioned at construction time. As with a C array, the access time for an <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___array1.html">NCollection_Array1</a></em> indexed item is constant and is independent of the array size. Arrays are commonly used as elementary data structures for more complex objects.</p>
<p>This template class depends on <em>Item</em>, the type of element in the array. Array indexation starts and ends at a position given to class constructor. Thus, when accessing an item, you must base the index on the lower and upper bounds of the array.</p>
<h5><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___array2.html">NCollection_Array2</a></h5>
<p>These are bi-dimensional arrays of fixed size but dynamically dimensioned at construction time.</p>
<p>As with a C array, the access time for an <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___array2.html">NCollection_Array2</a></em> indexed item is constant and is independent of the array size. Arrays are commonly used as elementary data structures for more complex objects.</p>
<p>This template class depends on <em>Item</em>, the type of element in the array. Array indexation starts and ends at a position given to class constructor. Thus, when accessing an item, you must base the index on the lower and upper bounds of the array.</p>
<h5><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___list.html">NCollection_List</a></h5>
<p>These are ordered lists of non-unique objects which can be accessed sequentially using an <a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___list.html#a27a68414a287e391d121762a54a97f14">NCollection_List::Iterator</a>. Item insertion in a list is very fast at any position. But searching for items by value may be slow if the list is long, because it requires a sequential search.</p>
<p>This template class depends on <em>Item</em>, the type of element in the structure. A sequence is a better structure when searching for items by value. Queues and stacks are other kinds of list with a different access to data.</p>
<h5><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___sequence.html">NCollection_Sequence</a></h5>
<p>This is a sequence of items indexed by an integer. Sequences have about the same goal as unidimensional arrays (<em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___array1.html">NCollection_Array1</a></em>): they are commonly used as elementary data structures for more complex objects. But a sequence is a structure of <em>variable size</em>: sequences avoid the use of large and quasi-empty arrays. Exploring a sequence data structure is effective when the exploration is done <em>in sequence</em>; elsewhere a sequence item is longer to read than an array item. Note also that sequences are not effective when they have to support numerous algorithmic explorations: a map is better for that.</p>
<p>This template class depends on <em>Item</em>, the type of element in the sequence. The first element in sequence has index equal to 1.</p>
<h5><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___vector.html">NCollection_Vector</a></h5>
<p>Class <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___vector.html">NCollection_Vector</a></em> is implemented internally as a list of arrays of the same size. Its properties:</p><ul>
<li>Direct (constant-time) access to members like in <a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___array1.html">NCollection_Array1</a> type. Data are allocated in compact blocks, this provides faster iteration.</li>
<li>Can grow without limits, like <a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___list.html">NCollection_List</a> or <a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___sequence.html">NCollection_Sequence</a> types.</li>
<li>Once having the size LEN, it cannot be reduced to any size less than LEN &ndash; there is no operation of removal of items.</li>
</ul>
<p>Insertion in a Vector-type class is made by two methods:</p><ul>
<li><em>SetValue(ind, theValue)</em> &ndash; array-type insertion, where ind is the index of the inserted item, can be any non-negative number. If it is greater than or equal to Length(), then the vector is enlarged (its Length() grows).</li>
<li><em>Append(theValue)</em> &ndash; list-type insertion equivalent to <em>myVec.SetValue(myVec.Length(), theValue)</em>, incrementing the size of the collection.</li>
</ul>
<p>Other essential properties coming from <a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___list.html">NCollection_List</a> and <a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___array1.html">NCollection_Array1</a> type collections:</p><ul>
<li>Like in <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___list.html">NCollection_List</a></em>, the method <em>Clear()</em> destroys all contained objects and releases the allocated memory.</li>
<li>Like in <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___array1.html">NCollection_Array1</a></em>, the methods <em>Value()</em> and <em>ChangeValue()</em> return a contained object by index. Also, these methods have the form of overloaded operator().</li>
</ul>
<p>The first element in vector has index equal to 0.</p>
<h5><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___sparse_array.html">NCollection_SparseArray</a></h5>
<p>Class <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___sparse_array.html">NCollection_SparseArray</a></em> has almost the same features as <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___vector.html">NCollection_Vector</a></em>, but it allows to store items having scattered indices. In <a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___vector.html">NCollection_Vector</a>, if you set an item with index 1000000, the container will allocate memory for all items with indices in the range 0-1000000. In <a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___sparse_array.html">NCollection_SparseArray</a>, only one small block of items will be reserved that contains the item with index 1000000.</p>
<p>This class can be also seen as equivalence of <em>NCollection_DataMap&lt;int,TheItemType&gt;</em> with the only one practical difference: it can be much less memory-expensive if items are small (e.g. Integer or Handle).</p>
<p>This type has both interfaces of <a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___data_map.html">NCollection_DataMap</a> and <a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___vector.html">NCollection_Vector</a> to access items.</p>
<h3><a class="anchor" id="occt_fcug_3_1_3"></a>
Maps</h3>
<p>OCCT provides several classes for storage of objects by value, providing fast search due to use of hash:</p><ul>
<li><em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___map.html">NCollection_Map</a></em> &ndash; hash set;</li>
<li><em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___indexed_map.html">NCollection_IndexedMap</a></em> &ndash; set with a prefixed order of elements, allowing fast access by index or by value (hash-based);</li>
<li><em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___data_map.html">NCollection_DataMap</a></em> &ndash; hash map;</li>
<li><em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___indexed_data_map.html">NCollection_IndexedDataMap</a></em> &ndash; map with a prefixed order of elements, allowing fast access by index or by value (hash-based);</li>
<li><em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___double_map.html">NCollection_DoubleMap</a></em> &ndash; two-side hash map (with two keys).</li>
</ul>
<p>Maps are dynamically extended data structures where data is quickly accessed with a <em>key</em>. Once inserted in the map, a map item is referenced as an <em>entry</em> of the map. Maps avoid the use of large and quasi-empty arrays.</p>
<p>Each entry of the map is addressed by a key. Two different keys address two different entries of the map. The position of an entry in the map is called a <em>bucket</em>.</p>
<p>A map is dimensioned by its number of buckets, i.e. the maximum number of entries in the map. The <em>hashing function</em> transforms a key into a bucket index. The number of values that can be computed by the hashing function is equal to the number of buckets of the map.</p>
<p>Both the hashing function and the equality test between two keys are provided by a <em>hasher</em> object.</p>
<p>The access time for a map item is much better than the one for a sequence, list, queue or stack item. It is comparable with the access time for an array item. It depends on the size of the map (number of buckets) and on the quality of the user redefinable <em>hashing function</em>.</p>
<p><em>Keys, items</em> and <em>hashers</em> are parameters of these OCCT map templates. <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___default_hasher.html">NCollection_DefaultHasher</a></em> class describes the functions required by any <em>hasher</em>, which is to be used with a map instantiated from the <b>NCollection</b> component.</p>
<p>A map may be explored by a <em>map iterator</em>. This exploration provides only inserted entries in the map (i.e. non empty buckets).</p>
<h5><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___data_map.html">NCollection_DataMap</a></h5>
<p>This is a map used to store keys with associated items. An entry of <b><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___data_map.html">NCollection_DataMap</a></b> is composed of both the key and the item. The <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___data_map.html">NCollection_DataMap</a></em> can be seen as an extended array where the keys are the indexes.</p>
<p><em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___data_map.html">NCollection_DataMap</a></em> is a template class which depends on three parameters:</p><ul>
<li><em>Key</em> is the type of key for an entry in the map,</li>
<li><em>Item</em> is the type of element associated with a key in the map,</li>
<li><em>Hasher</em> is the type of hasher on keys.</li>
</ul>
<p>Use a <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___data_map_1_1_iterator.html">NCollection_DataMap::Iterator</a></em> to explore a <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___data_map.html">NCollection_DataMap</a></em> map. <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___default_hasher.html">NCollection_DefaultHasher</a></em> class describes the functions required for a <em>Hasher</em> object.</p>
<h5><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___double_map.html">NCollection_DoubleMap</a></h5>
<p>This is a map used to bind pairs of keys (Key1,Key2) and retrieve them in linear time.</p>
<p><em>Key1</em> is referenced as the first key of the <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___double_map.html">NCollection_DoubleMap</a></em> and <em>Key2</em> as the second key.</p>
<p>An entry of a <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___double_map.html">NCollection_DoubleMap</a></em> is composed of a pair of two keys: the first key and the second key.</p>
<p><em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___double_map.html">NCollection_DoubleMap</a></em> is a teamplate class which depends on four parameters:</p><ul>
<li><em>Key1</em> is the type of the first key for an entry in the map,</li>
<li><em>Key2</em> is the type of the second key for an entry in the map,</li>
<li><em>Hasher1</em> is the type of hasher on first keys,</li>
<li><em>Hasher2</em> is the type of hasher on second keys.</li>
</ul>
<p>Use <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___double_map_1_1_iterator.html">NCollection_DoubleMap::Iterator</a></em> to explore a <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___double_map.html">NCollection_DoubleMap</a></em> map. <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___default_hasher.html">NCollection_DefaultHasher</a></em> class describes the functions required for a <em>Hasher1</em> or a <em>Hasher2</em> object.</p>
<h5><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___indexed_data_map.html">NCollection_IndexedDataMap</a></h5>
<p>This is map to store keys with associated items and to bind an index to them.</p>
<p>Each new key stored in the map is assigned an index. Indexes are incremented as keys (and items) stored in the map. A key can be found by the index, and an index can be found by the key. No key but the last can be removed, so the indexes are in the range 1...Upper, where <em>Upper</em> is the number of keys stored in the map. An item is stored with each key.</p>
<p>An entry of an <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___indexed_data_map.html">NCollection_IndexedDataMap</a></em> is composed of both the key, the item and the index. An <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___indexed_data_map.html">NCollection_IndexedDataMap</a></em> is an ordered map, which allows a linear iteration on its contents. It combines the interest:</p><ul>
<li>of an array because data may be accessed with an index,</li>
<li>and of a map because data may also be accessed with a key.</li>
</ul>
<p><em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___indexed_data_map.html">NCollection_IndexedDataMap</a></em> is a template class which depends on three parameters:</p><ul>
<li><em>Key</em> is the type of key for an entry in the map,</li>
<li><em>Item</em> is the type of element associated with a key in the map,</li>
<li><em>Hasher</em> is the type of hasher on keys.</li>
</ul>
<h5><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___indexed_map.html">NCollection_IndexedMap</a></h5>
<p>This is map used to store keys and to bind an index to them.</p>
<p>Each new key stored in the map is assigned an index. Indexes are incremented as keys stored in the map. A key can be found by the index, and an index by the key. No key but the last can be removed, so the indexes are in the range 1...Upper where Upper is the number of keys stored in the map.</p>
<p>An entry of an <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___indexed_map.html">NCollection_IndexedMap</a></em> is composed of both the key and the index. An <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___indexed_map.html">NCollection_IndexedMap</a></em> is an ordered map, which allows a linear iteration on its contents. But no data is attached to the key. An <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___indexed_map.html">NCollection_IndexedMap</a></em> is typically used by an algorithm to know if some action is still performed on components of a complex data structure.</p>
<p><em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___indexed_map.html">NCollection_IndexedMap</a></em> is a template class which depends on two parameters:</p><ul>
<li><em>Key</em> is the type of key for an entry in the map,</li>
<li><em>Hasher</em> is the type of hasher on keys.</li>
</ul>
<h5><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___map.html">NCollection_Map</a></h5>
<p>This is a basic hashed map, used to store and retrieve keys in linear time.</p>
<p>An entry of a <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___map.html">NCollection_Map</a></em> is composed of the key only. No data is attached to the key. An <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___map.html">NCollection_Map</a></em> is typically used by an algorithm to know if some action is still performed on components of a complex data structure.</p>
<p><em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___map.html">NCollection_Map</a></em> is a generic class which depends on two parameters:</p><ul>
<li><em>Key</em> is the type of key in the map,</li>
<li><em>Hasher</em> is the type of hasher on keys.</li>
</ul>
<p>Use a <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___map_1_1_iterator.html">NCollection_Map::Iterator</a></em> to explore a <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___map.html">NCollection_Map</a></em> map.</p>
<h5><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___default_hasher.html">NCollection_DefaultHasher</a></h5>
<p>This is a default hasher on the <em>keys</em> of a map instantiated from the <em>NCollection</em> component.</p>
<p>A hasher provides two functions:</p><ul>
<li><em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_vrml_data___node_8hxx.html#ad12984a74773c837740302d31ce70c31">HashCode()</a></em> function transforms a key into a bucket index in the map. The number of values that can be computed by the hashing function is equal to the number of buckets in the map.</li>
<li><em>IsEqual</em> is the equality test between two keys.</li>
</ul>
<p>Hashers are used as parameters in template maps provided by the <b>NCollection</b> component.</p>
<p><em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___default_hasher.html">NCollection_DefaultHasher</a></em> is a template class which depends on the type of keys, providing that <em>Key</em> is a type from the <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_standard.html">Standard</a></em> package. In such cases <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___default_hasher.html">NCollection_DefaultHasher</a></em> may be directly instantiated with <em>Key</em>. Note that the package <em>TColStd</em> provides some of these instantiations.</p>
<p>Elsewhere, if <em>Key</em> is not a type from the <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_standard.html">Standard</a></em> package you must consider <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___default_hasher.html">NCollection_DefaultHasher</a></em> as a template and build a class which includes its functions, in order to use it as a hasher in a map instantiated from the <em>NCollection</em> component.</p>
<p>Note that <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_t_collection___ascii_string.html">TCollection_AsciiString</a></em> and <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_t_collection___extended_string.html">TCollection_ExtendedString</a></em> classes correspond to these specifications, in consequence they may be used as hashers: when <em>Key</em> is one of these two types you may just define the hasher as the same type at the time of instantiation of your map.</p>
<h3><a class="anchor" id="occt_fcug_3_1_4"></a>
Iterators</h3>
<p>Every collection defines its <em>Iterator</em> class capable of iterating the members in some predefined order. Every Iterator is defined as a subtype of the particular collection type (e.g., MyPackage_StackOfPnt::Iterator). The order of iteration is defined by a particular collection type.</p>
<p>The common methods of Iterator are:</p>
<table class="doxtable">
<tr>
<th align="left">Name </th><th align="left">Method </th><th align="left">Description  </th></tr>
<tr>
<td align="left"><b>Init()</b> </td><td align="left"><em>void Init (MyCollection&amp; )</em> </td><td align="left">Initializes the iterator on the collection object </td></tr>
<tr>
<td align="left"><b>More()</b> </td><td align="left"><em>bool More()</em> </td><td align="left">Makes a query if there is another non-iterated member </td></tr>
<tr>
<td align="left"><b>Next()</b> </td><td align="left"><em>void Next()</em> </td><td align="left">Increments the iterator </td></tr>
<tr>
<td align="left"><b>Value()</b> </td><td align="left"><em>const ItemType&amp; Value()</em> </td><td align="left">Returns the current member </td></tr>
<tr>
<td align="left"><b>ChangeValue()</b> </td><td align="left"><em>ItemType&amp; ChangeValue()</em> </td><td align="left">Returns the mutable current member </td></tr>
</table>
<p>Usage sample:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> Ncollection_Sequence&lt;gp_Pnt&gt; MyPackage_SequenceOfPnt;</div><div class="line"><span class="keywordtype">void</span> Perform (<span class="keyword">const</span> MyPackage_SequenceOfPnt&amp; theSequence)</div><div class="line">{</div><div class="line">  <span class="keywordflow">for</span> (MyPackage_SequenceOfPnt::Iterator anIter (theSequence); anIter.More(); anIter.Next())</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___pnt.html">gp_Pnt</a> aPnt&amp; = anIter.Value();</div><div class="line">    ...</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="occt_fcug_3_1_5"></a>
Allocators</h3>
<p>All constructors of <em>NCollection</em> classes receive the <em>Allocator</em> object as the last parameter. This is an object of a type managed by Handle, inheriting <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___base_allocator.html">NCollection_BaseAllocator</a></em>, with the following (mandatory) methods redefined:</p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span>* Allocate (<span class="keyword">const</span> <span class="keywordtype">size_t</span> theSize) <span class="keyword">override</span>;</div><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span>  Free (<span class="keywordtype">void</span>* theAddress) <span class="keyword">override</span>;</div></div><!-- fragment --><p>It is used internally every time when the collection allocates memory for its item(s) and releases this memory. The default value of this parameter (empty <em>Handle</em>) designates the use of <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___base_allocator.html">NCollection_BaseAllocator</a></em>, where the functions <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_standard.html#aaaaa204e9cefcae7bafb6da8b941b46a">Standard::Allocate</a></em> and <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_standard.html#a6ef68946681e34cafcf847e1695bd600">Standard::Free</a></em> are called. Therefore if the user of <em>NCollection</em> does not specify any allocator as a parameter to the constructor of his collection, the memory management will be identical to other Open CASCADE Technology classes.</p>
<p>Nevertheless, it is possible to define a custom <em>Allocator</em> type to manage the memory in the most optimal or convenient way for this algorithm.</p>
<p>As one possible choice, the class <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___inc_allocator.html">NCollection_IncAllocator</a></em> is included. Unlike <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___base_allocator.html">NCollection_BaseAllocator</a></em>, the memory is allocated in big blocks (about 20kB) and the allocator keeps track of the amount of occupied memory. The method <em>Allocate</em> just increments the pointer to non-occupied memory and returns its previous value. Memory is only released in the destructor of <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___inc_allocator.html">NCollection_IncAllocator</a></em>, the method <em>Free</em> is empty. If used properly, this Allocator can greatly improve the performance of specific algorithms.</p>
<h3><a class="anchor" id="occt_fcug_3_1_6"></a>
Acceleration structures</h3>
<p>OCCT provides several data structures for optimized traverse of large collection of objects based on their locality (in 3D space).</p><ul>
<li><em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___u_b_tree.html">NCollection_UBTree</a></em> &ndash; Unbalanced Binary Tree;</li>
<li><em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___cell_filter.html">NCollection_CellFilter</a></em> &ndash; array of 2D/3D cells;</li>
<li><em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_v_h___tree.html">BVH_Tree</a></em> &ndash; boundary volume hierarchy.</li>
</ul>
<h5><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___u_b_tree.html">NCollection_UBTree</a></h5>
<p>The class name <a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___u_b_tree.html">NCollection_UBTree</a> stands for "Unbalanced Binary Tree". It stores the members in a binary tree of overlapped bounding objects (boxes or else). Once the tree of boxes of geometric objects is constructed, the algorithm is capable of fast geometric selection of objects. The tree can be easily updated by adding to it a new object with bounding box. The time of adding to the tree of one object is O(log(N)), where N is the total number of objects, so the time of building a tree of N objects is O(N(log(N)). The search time of one object is O(log(N)).</p>
<p>Defining various classes inheriting <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___u_b_tree_1_1_selector.html">NCollection_UBTree::Selector</a></em> we can perform various kinds of selection over the same b-tree object.</p>
<p>The object may be of any type allowing copying. Among the best suitable solutions there can be a pointer to an object, handled object or integer index of object inside some collection.</p>
<p>The bounding object may have any dimension and geometry. The minimal interface of <em>TheBndType</em> (besides public empty and copy constructor and operator=) used in <a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___u_b_tree.html">NCollection_UBTree</a> algorithm as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyBndType</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:<span class="comment"></span></div><div class="line"><span class="comment">  //! Updates me with other bounding type instance</span></div><div class="line"><span class="comment"></span>  <span class="keywordtype">void</span> Add (<span class="keyword">const</span> MyBndType&amp; theOther);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  //! Classifies other bounding type instance relatively me</span></div><div class="line"><span class="comment"></span>  <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a> IsOut (<span class="keyword">const</span> MyBndType&amp; theOther) <span class="keyword">const</span>;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  //! Computes the squared maximal linear extent of me (for a box it is the squared diagonal of the box).</span></div><div class="line"><span class="comment"></span>  <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> SquareExtent() <span class="keyword">const</span>;</div><div class="line">};</div></div><!-- fragment --><p>This interface is implemented in types of Bnd package: <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_bnd___box.html">Bnd_Box</a>, <a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_bnd___box2d.html">Bnd_Box2d</a>, Bnd_B2x, Bnd_B3x</em>.</p>
<p>To select objects you need to define a class derived from <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___u_b_tree_1_1_selector.html">NCollection_UBTree::Selector</a></em> that should redefine the necessary virtual methods to maintain the selection condition. Usually this class instance is also used to retrieve selected objects after search. The class <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___u_b_tree_filler.html">NCollection_UBTreeFiller</a></em> is used to randomly populate a <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___u_b_tree.html">NCollection_UBTree</a></em> instance. The quality of a tree is better (considering the speed of searches) if objects are added to it in a random order trying to avoid the addition of a chain of nearby objects one following another. Instantiation of <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___u_b_tree_filler.html">NCollection_UBTreeFiller</a></em> collects objects to be added, and then adds them at once to the given <a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___u_b_tree.html">NCollection_UBTree</a> instance in a random order using the Fisher-Yates algorithm. Below is the sample code that creates an instance of <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___u_b_tree.html">NCollection_UBTree</a></em> indexed by 2D boxes (<a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_bnd___b2f.html">Bnd_B2f</a>), then a selection is performed returning the objects whose bounding boxes contain the given 2D point.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___u_b_tree.html">NCollection_UBTree&lt;MyData, Bnd_B2f&gt;</a> UBTree;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___list.html">NCollection_List&lt;MyData&gt;</a> ListOfSelected;<span class="comment"></span></div><div class="line"><span class="comment">//! Tree Selector type</span></div><div class="line"><span class="comment"></span><span class="keyword">class </span>MyTreeSelector : <span class="keyword">public</span> UBTree::Selector</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:<span class="comment"></span></div><div class="line"><span class="comment">  //! This constructor initializes the selection criterion (e.g., a point)</span></div><div class="line"><span class="comment"></span>  MyTreeSelector (<span class="keyword">const</span> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___x_y.html">gp_XY</a>&amp; thePnt) : myPnt(thePnt) {}</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  //! Get the list of selected objects</span></div><div class="line"><span class="comment"></span>  <span class="keyword">const</span> ListOfSelected&amp; ListAccepted()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> myList; }</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  //! Bounding box rejection - definition of virtual method.</span></div><div class="line"><span class="comment">  //! @return True if theBox is outside the selection criterion.</span></div><div class="line"><span class="comment"></span>  <span class="keyword">virtual</span> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a> Reject (<span class="keyword">const</span> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_bnd___b2f.html">Bnd_B2f</a>&amp; theBox)<span class="keyword"> const override </span>{ <span class="keywordflow">return</span> theBox.<a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_bnd___b2f.html#afbd359622d4dbc106ce2f43426cab918">IsOut</a> (myPnt); }</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  //! Redefined from the base class.</span></div><div class="line"><span class="comment">  //! Called when the bounding of theData conforms to the selection criterion.</span></div><div class="line"><span class="comment">  //! This method updates myList.</span></div><div class="line"><span class="comment"></span>  <span class="keyword">virtual</span> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a> Accept (<span class="keyword">const</span> MyData&amp; theData)<span class="keyword"> override </span>{ myList.Append (theData); }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___x_y.html">gp_XY</a>          myPnt;</div><div class="line">  ListOfSelected myList;</div><div class="line">};</div><div class="line">. . .</div><div class="line"><span class="comment">// Create a UBTree instance and fill it with data, each data item having the corresponding 2D box.</span></div><div class="line">UBTree aTree;</div><div class="line"><a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___u_b_tree_filler.html">NCollection_UBTreeFiller &lt;MyData, Bnd_B2f&gt;</a> aTreeFiller (aTree);</div><div class="line"><span class="keywordflow">for</span>(;;)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> MyData&amp; aData = ...;</div><div class="line">  <span class="keyword">const</span> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_bnd___b2d.html">Bnd_B2d</a>&amp; aBox = aData.GetBox();</div><div class="line">  aTreeFiller.<a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_bnd___b2d.html#a91663930f48d03f1a980450cbc56250f">Add</a> (aData, aBox);</div><div class="line">}</div><div class="line">aTreeFiller.Fill();</div><div class="line">. . .</div><div class="line"><span class="comment">// Perform selection based on &quot;aPoint2d&quot;</span></div><div class="line">MyTreeSelector aSel (aPoint2d);</div><div class="line">aTree.Select (aSel);</div><div class="line"><span class="keyword">const</span> ListOfSelected&amp; aSelected = aSel.ListAccepted();</div></div><!-- fragment --><h5><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___cell_filter.html">NCollection_CellFilter</a></h5>
<p>Class <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___cell_filter.html">NCollection_CellFilter</a></em> represents a data structure for sorting geometric objects in n-dimensional space into cells, with associated algorithm for fast checking of coincidence (overlapping, intersection, etc.) with other objects. It can be considered as a functional alternative to <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___u_b_tree.html">NCollection_UBTree</a></em>, as in the best case it provides the direct access to an object like in an n-dimensional array, while search with <a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___u_b_tree.html">NCollection_UBTree</a> provides logarithmic law access time.</p>
<h2><a class="anchor" id="occt_fcug_3_2"></a>
Collections of Standard Objects</h2>
<p>Packages <em>TShort</em>, <em>TColGeom</em>, <em>TColGeom2d</em>, <em>TColStd</em>, <em>TColgp</em> provide template instantiations (typedefs) of <em>NCollection</em> templates to standard OCCT types. Classes with <em>H</em> prefix in name are handle-based variants and inherit <a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_standard___transient.html">Standard_Transient</a>. </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___array1.html">NCollection_Array1&lt;gp_Vec&gt;</a>                  <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___array1.html">TColgp_Array1OfVec</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___array1.html">NCollection_Array1&lt;TCollection_AsciiString&gt;</a> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___array1.html">TColStd_Array1OfAsciiString</a>;</div></div><!-- fragment --><p>Packages like <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_top_tools.html">TopTools</a></em> also include definitions of collections and hash functions for complex types like shapes &ndash; <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_top_tools___shape_map_hasher.html">TopTools_ShapeMapHasher</a></em>, <em>TopTools_MapOfShape</em>.</p>
<p>Apart from that class <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_t_col_std___packed_map_of_integer.html">TColStd_PackedMapOfInteger</a></em> provides an alternative implementation of map of integer numbers, optimized for both performance and memory usage (it uses bit flags to encode integers, which results in spending only 24 bytes per 32 integers stored in optimal case). This class also provides Boolean operations with maps as sets of integers (union, intersection, subtraction, difference, checks for equality and containment).</p>
<h2><a class="anchor" id="occt_fcug_3_4"></a>
Strings</h2>
<p><em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_t_collection___ascii_string.html">TCollection_AsciiString</a></em> defines a variable-length sequence of UTF-8 code points (normal 8-bit character type), while <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_t_collection___extended_string.html">TCollection_ExtendedString</a></em> stores UTF-16/UCS-2 code points (16-bit character type). Both follow value semantics - that is, they are the actual strings, not handles to strings, and are copied through assignment. <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_t_collection___h_ascii_string.html">TCollection_HAsciiString</a></em> / <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_t_collection___h_extended_string.html">TCollection_HExtendedString</a></em> are handle wrappers over <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_t_collection___ascii_string.html">TCollection_AsciiString</a></em> / <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_t_collection___extended_string.html">TCollection_ExtendedString</a></em>.</p>
<p>String classes provide the following services to manipulate character strings:</p><ul>
<li>Editing operations on string objects, using a built-in string manager</li>
<li>Handling of dynamically-sized sequences of characters</li>
<li>Conversion from/to ASCII and UTF-8 strings.</li>
</ul>
<p><em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_t_collection___ascii_string.html">TCollection_AsciiString</a></em> and <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_t_collection___extended_string.html">TCollection_ExtendedString</a></em> provide UTF-8 &lt;-&gt; UTF-16 conversion constructors, making these string classes interchangeable. <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_resource___unicode.html">Resource_Unicode</a></em> provides functions to convert strings given in ANSI, EUC, GB or SJIS format, to a Unicode string and vice versa. <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_n_collection___utf_iterator.html">NCollection_UtfIterator</a></em> class implements an iterator over multibyte UTF-8/UTF-16 strings as a sequence of UTF-32 Unicode symbols.</p>
<h2><a class="anchor" id="occt_fcug_3_5"></a>
Quantities</h2>
<p>Quantities are various classes supporting date and time information and color.</p>
<p>Quantity classes provide the following services:</p><ul>
<li>Unit conversion tools providing a uniform mechanism for dealing with quantities and associated physical units: check unit compatibility, perform conversions of values between different units, etc. (see package <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_units_a_p_i.html">UnitsAPI</a></em>)</li>
<li>Resources to manage time information such as dates and time periods</li>
<li>Resources to manage color definition</li>
</ul>
<p>A mathematical quantity is characterized by the name and the value (real).</p>
<p>A physical quantity is characterized by the name, the value (real) and the unit. The unit may be either an international unit complying with the International Unit System (SI) or a user defined unit. The unit is managed by the physical quantity user.</p>
<h2><a class="anchor" id="occt_fcug_3_6"></a>
Unit Conversion</h2>
<p>The <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_units_a_p_i.html">UnitsAPI</a></em> global functions are used to convert a value from any unit into another unit. Conversion is executed among three unit systems:</p><ul>
<li>the <b>SI System</b>,</li>
<li>the user's <b>Local System</b>,</li>
<li>the user's <b>Current System</b>.</li>
</ul>
<p>The <b>SI System</b> is the standard international unit system. It is indicated by <em>SI</em> in the signatures of the <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_units_a_p_i.html">UnitsAPI</a></em> functions.</p>
<p>The OCCT (former MDTV) System corresponds to the SI international standard but the length unit and all its derivatives use the millimeter instead of the meter.</p>
<p>Both systems are proposed by Open CASCADE Technology; the SI System is the standard option. By selecting one of these two systems, you define your <b>Local System</b> through the <em>SetLocalSystem</em> function. The <b>Local System</b> is indicated by <em>LS</em> in the signatures of the <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_units_a_p_i.html">UnitsAPI</a></em> functions. The Local System units can be modified in the working environment. You define your <b>Current System</b> by modifying its units through the <em>SetCurrentUnit</em> function. The Current System is indicated by <em>Current</em> in the signatures of the <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_units_a_p_i.html">UnitsAPI</a></em> functions. A physical quantity is defined by a string (example: LENGTH).</p>
<h1><a class="anchor" id="occt_occt_fcug_4"></a>
Math Primitives and Algorithms</h1>
<h2><a class="anchor" id="occt_occt_fcug_4_1"></a>
Overview</h2>
<p>Math primitives and algorithms available in Open CASCADE Technology include:</p><ul>
<li>Vectors and matrices</li>
<li>Geometric primitives</li>
<li>Math algorithms</li>
</ul>
<h2><a class="anchor" id="occt_occt_fcug_4_2"></a>
Vectors and Matrices</h2>
<p>The Vectors and Matrices component provides a C++ implementation of the fundamental types <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classmath___vector.html">math_Vector</a></em> and <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classmath___matrix.html">math_Matrix</a></em>, which are regularly used to define more complex data structures.</p>
<p>The <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classmath___vector.html">math_Vector</a></em> and <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classmath___matrix.html">math_Matrix</a></em> classes provide commonly used mathematical algorithms which include:</p>
<ul>
<li>Basic calculations involving vectors and matrices;</li>
<li>Computation of eigenvalues and eigenvectors of a square matrix;</li>
<li>Solvers for a set of linear algebraic equations;</li>
<li>Algorithms to find the roots of a set of non-linear equations;</li>
<li>Algorithms to find the minimum function of one or more independent variables.</li>
</ul>
<p>These classes also provide a data structure to represent any expression, relation, or function used in mathematics, including the assignment of variables.</p>
<p>Vectors and matrices have arbitrary ranges which must be defined at declaration time and cannot be changed after declaration.</p>
<div class="fragment"><div class="line"><a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classmath___vector.html">math_Vector</a> aVec (1, 3);</div><div class="line"><span class="comment">// a vector of dimension 3 with range (1..3)</span></div><div class="line"><a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classmath___matrix.html">math_Matrix</a> aMat (0, 2, 0, 2);</div><div class="line"><span class="comment">// a matrix of dimension 3x3 with range (0..2, 0..2)</span></div><div class="line"><a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classmath___vector.html">math_Vector</a> aVec (N1, N2);</div><div class="line"><span class="comment">// a vector of dimension N2-N1+1 with range (N1..N2)</span></div></div><!-- fragment --><p>Vector and Matrix objects use value semantics. In other words, they cannot be shared and are copied through assignment.</p>
<div class="fragment"><div class="line"><a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classmath___vector.html">math_Vector</a> aVec1 (1, 3), aVec2 (0, 2);</div><div class="line">aVec2 = aVec1;</div><div class="line"><span class="comment">// aVec1 is copied into aVec2; a modification of aVec1 does not affect aVec2</span></div></div><!-- fragment --><p>Vector and Matrix values may be initialized and obtained using indexes which must lie within the range definition of the vector or the matrix.</p>
<div class="fragment"><div class="line"><a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classmath___vector.html">math_Vector</a> aVec (1, 3);</div><div class="line"><a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classmath___matrix.html">math_Matrix</a> aMat (1, 3, 1, 3);</div><div class="line"><a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> aValue;</div><div class="line"></div><div class="line">aVec (2) = 1.0;</div><div class="line">aValue = aVec(1);</div><div class="line">aMat (1, 3) = 1.0;</div><div class="line">aValue = aMat (2, 2);</div></div><!-- fragment --><p>Some operations on Vector and Matrix objects may not be legal. In this case an exception is raised. Two standard exceptions are used:</p><ul>
<li><em>Standard_DimensionError</em> exception is raised when two matrices or vectors involved in an operation are of incompatible dimensions.</li>
<li><em>Standard_RangeError</em> exception is raised if an access outside the range definition of a vector or of a matrix is attempted.</li>
</ul>
<div class="fragment"><div class="line"><a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classmath___vector.html">math_Vector</a> aVec1 (1, 3), aVec2 (1, 2), aVec3 (0, 2);</div><div class="line">aVec1 = aVec2;   <span class="comment">// error: Standard_DimensionError is raised</span></div><div class="line">aVec1 = aVec3;   <span class="comment">// OK: ranges are not equal but dimensions are compatible</span></div><div class="line">aVec1 (0) = 2.0; <span class="comment">// error: Standard_RangeError is raised</span></div></div><!-- fragment --><h2><a class="anchor" id="occt_occt_fcug_4_3"></a>
Primitive Geometric Types</h2>
<p>Open CASCADE Technology primitive geometric types are a STEP-compliant implementation of basic geometric and algebraic entities. They provide:</p><ul>
<li>Descriptions of primitive geometric shapes, such as:<ul>
<li>Points;</li>
<li>Vectors;</li>
<li>Lines;</li>
<li>Circles and conics;</li>
<li>Planes and elementary surfaces;</li>
</ul>
</li>
<li>Positioning of these shapes in space or in a plane by means of an axis or a coordinate system;</li>
<li>Definition and application of geometric transformations to these shapes:<ul>
<li>Translations;</li>
<li>Rotations;</li>
<li>Symmetries;</li>
<li>Scaling transformations;</li>
<li>Composed transformations;</li>
</ul>
</li>
<li>Tools (coordinates and matrices) for algebraic computation.</li>
</ul>
<p>All these functions are provided by geometric processor package <em>gp</em>. Its classes for 2d and 3d objects are handled by value rather than by reference. When this sort of object is copied, it is copied entirely. Changes in one instance will not be reflected in another.</p>
<p>The <em>gp</em> package defines the basic geometric entities used for algebraic calculation and basic analytical geometry in 2d &amp; 3d space. It also provides basic transformations such as identity, rotation, translation, mirroring, scale transformations, combinations of transformations, etc. Entities are handled by value.</p>
<p>Note that <em>gp</em> curves and surfaces are analytic: there is no parameterization and no orientation on <em>gp</em> entities, i.e. these entities do not provide functions which work with these properties.</p>
<p>If you need, you may use more evolved data structures provided by <em>Geom</em> (in 3D space) and <em>Geom2d</em> (in the plane). However, the definition of <em>gp</em> entities is identical to the one of equivalent <em>Geom</em> and <em>Geom2d</em> entities, and they are located in the plane or in space with the same kind of positioning systems. They implicitly contain the orientation, which they express on the <em>Geom </em> and <em>Geom2d</em> entities, and they induce the definition of their parameterization.</p>
<p>Therefore, it is easy to give an implicit parameterization to <em>gp</em> curves and surfaces, which is the parametrization of the equivalent <em>Geom</em> or <em>Geom2d</em> entity. This property is particularly useful when computing projections or intersections, or for operations involving complex algorithms where it is particularly important to manipulate the simplest data structures, i.e. those of <em>gp</em>. Thus, <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_el_c_lib.html">ElCLib</a></em> and <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_el_s_lib.html">ElSLib</a></em> packages provide functions to compute:</p><ul>
<li>the point of parameter u on a 2D or 3D gp curve,</li>
<li>the point of parameter (u,v) on a gp elementary surface, and</li>
<li>any derivative vector at this point.</li>
</ul>
<p>Note: the <em>gp</em> entities cannot be shared when they are inside more complex data structures.</p>
<h2><a class="anchor" id="occt_occt_fcug_4_4"></a>
Collections of Primitive Geometric Types</h2>
<p>Before creating a geometric object, you must decide whether you are in a 2d or in a 3d context and how you want to handle the object. If you do not need a single instance of a geometric primitive but a set of them then the package which deals with collections of this sort of object, <em>TColgp</em>, will provide the necessary functionality. In particular, this package provides standard and frequently used instantiations of generic classes with geometric objects, i.e. <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___x_y.html">gp_XY</a></em>, <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___x_y_z.html">gp_XYZ</a></em>, <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___pnt.html">gp_Pnt</a></em>, <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___pnt2d.html">gp_Pnt2d</a></em>, <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___vec.html">gp_Vec</a></em>, <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___vec2d.html">gp_Vec2d</a></em>, <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___lin.html">gp_Lin</a></em>, <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___lin2d.html">gp_Lin2d</a></em>, <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___circ.html">gp_Circ</a></em>, <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___circ2d.html">gp_Circ2d</a></em>.</p>
<h2><a class="anchor" id="occt_occt_fcug_4_5"></a>
Basic Geometric Libraries</h2>
<p>There are various library packages available which offer a range of basic computations on curves and surfaces. If you are dealing with objects created from the <em>gp</em> package, the useful algorithms are in the elementary curves and surfaces libraries &ndash; the <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_el_c_lib.html">ElCLib</a></em> and <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_el_s_lib.html">ElSLib</a></em> packages.</p><ul>
<li><em>EICLib</em> provides methods for analytic curves. This is a library of simple computations on curves from the <em>gp</em> package (Lines, Circles and Conics). It is possible to compute points with a given parameter or to compute the parameter for a point.</li>
<li><em>EISLib</em> provides methods for analytic surfaces. This is a library of simple computations on surfaces from the package <em>gp</em> (Planes, Cylinders, Spheres, Cones, Tori). It is possible to compute points with a given pair of parameters or to compute the parameter for a point. There is a library for calculating normals on curves and surfaces.</li>
</ul>
<p>Additionally, <em>Bnd</em> package provides a set of classes and tools to operate with bounding boxes of geometric objects in 2d and 3d space.</p>
<h2><a class="anchor" id="occt_occt_fcug_4_6"></a>
Common Math Algorithms</h2>
<p>The common math algorithms library provides a C++ implementation of the most frequently used mathematical algorithms. These include:</p><ul>
<li>Algorithms to solve a set of linear algebraic equations,</li>
<li>Algorithms to find the minimum of a function of one or more independent variables,</li>
<li>Algorithms to find roots of one, or of a set, of non-linear equations,</li>
<li>An algorithm to find the eigenvalues and eigenvectors of a square matrix.</li>
</ul>
<p>All mathematical algorithms are implemented using the same principles. They contain:</p><ul>
<li>A constructor performing all, or most of, the calculation, given the appropriate arguments. All relevant information is stored inside the resulting object, so that all subsequent calculations or interrogations will be solved in the most efficient way.</li>
<li>A function <em>IsDone</em> returning the boolean true if the calculation was successful.</li>
<li>A set of functions, specific to each algorithm, enabling all the various results to be obtained. Calling these functions is legal only if the function <em>IsDone</em> answers <b>true</b>, otherwise the exception <em>StdFail_NotDone</em> is raised.</li>
</ul>
<p>The example below demonstrates the use of the <a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classmath___gauss.html">math_Gauss</a> class, which implements the Gauss solution for a set of linear equations. The following definition is an extract from the header file of the class <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classmath___gauss.html">math_Gauss</a></em>:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span><a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classmath___gauss.html">math_Gauss</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classmath___gauss.html#a4ca8247b56f06a8e32e01f6f5776903b">math_Gauss</a> (<span class="keyword">const</span> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classmath___matrix.html">math_Matrix</a>&amp; A);</div><div class="line">  <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classmath___gauss.html#a66f73d056f902e1627eed1a2be2fa72e">IsDone</a>() <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">void</span> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classmath___gauss.html#a6b8a2444954d871eed586e909f2babde">Solve</a> (<span class="keyword">const</span> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classmath___vector.html">math_Vector</a>&amp; B, <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classmath___vector.html">math_Vector</a>&amp; X) <span class="keyword">const</span>;</div><div class="line">};</div></div><!-- fragment --><p>Now the main program uses the <a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classmath___gauss.html">math_Gauss</a> class to solve the equations <em>a*x1=b1</em> and <em>a*x2=b2</em>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/math___vector_8hxx.html">math_Vector.hxx</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/math___matrix_8hxx.html">math_Matrix.hxx</a>&gt;</span></div><div class="line">main()</div><div class="line">{</div><div class="line">  <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classmath___vector.html">math_Vector</a> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/namespaceopencascade.html#a8bfaa44f937da5cb5aea81e82f918d0a">a</a>(1, 3, 1, 3);</div><div class="line">  <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classmath___vector.html">math_Vector</a> b1(1, 3), b2(1, 3);</div><div class="line">  <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classmath___vector.html">math_Vector</a> x1(1, 3), x2(1, 3);</div><div class="line">  <span class="comment">// a, b1 and b2 are set here to the appropriate values</span></div><div class="line">  ...</div><div class="line"></div><div class="line">  <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classmath___gauss.html">math_Gauss</a> aSol(<a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/namespaceopencascade.html#a8bfaa44f937da5cb5aea81e82f918d0a">a</a>);        <span class="comment">// computation of the LU decomposition of A</span></div><div class="line">  <span class="keywordflow">if</span> (aSol.IsDone())         <span class="comment">// is it OK ?</span></div><div class="line">  {</div><div class="line">    aSol.Solve(b1, x1);      <span class="comment">// yes, so compute x1</span></div><div class="line">    aSol.Solve(b2, x2);      <span class="comment">// then x2</span></div><div class="line">    ...</div><div class="line">  }</div><div class="line">  <span class="keywordflow">else</span>                       <span class="comment">// it is not OK:</span></div><div class="line">  {</div><div class="line">    <span class="comment">// fix up</span></div><div class="line">    aSol.Solve(b1, x1);      <span class="comment">// error:</span></div><div class="line">    <span class="comment">// StdFail_NotDone is raised</span></div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>The next example demonstrates the use of the <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classmath___bissec_newton.html">math_BissecNewton</a></em> class, which implements a combination of the Newton and Bissection algorithms to find the root of a function known to lie between two bounds. The definition is an extract from the header file of the class <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classmath___bissec_newton.html">math_BissecNewton</a></em>:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span><a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classmath___bissec_newton.html">math_BissecNewton</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classmath___bissec_newton.html#a8c19e6f5f601fb47ef89dd16218a90ff">math_BissecNewton</a> (<a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classmath___function_with_derivative.html">math_FunctionWithDerivative</a>&amp; <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classmath___bissec_newton.html#ab7c1f39eacb92ee307afcc7fab132d75">f</a>,</div><div class="line">                     <span class="keyword">const</span> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> bound1,</div><div class="line">                     <span class="keyword">const</span> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> bound2,</div><div class="line">                     <span class="keyword">const</span> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> tolx);</div><div class="line">  <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classmath___bissec_newton.html#a244b864f72ff11b3019c4dd4fe0239dc">IsDone</a>() <span class="keyword">const</span>;</div><div class="line">  <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classmath___bissec_newton.html#aa5c24eb5a4b086f60023a5b5cc51efc2">Root</a>();</div><div class="line">}; </div></div><!-- fragment --><p>The abstract class <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classmath___function_with_derivative.html">math_FunctionWithDerivative</a></em> describes the services which have to be implemented for the function <em>f</em> which is to be used by a <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classmath___bissec_newton.html">math_BissecNewton</a></em> algorithm. The following definition corresponds to the header file of the abstract class <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classmath___function_with_derivative.html">math_FunctionWithDerivative</a></em>:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span><a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classmath___function_with_derivative.html">math_FunctionWithDerivative</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classmath___function_with_derivative.html#a54edefe39d7900e71294475f5c985faa">Value</a> (<span class="keyword">const</span> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/namespaceopencascade.html#a5ca01742b10640986e9f619449215b72">x</a>, <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&amp; f) = 0;</div><div class="line">  <span class="keyword">virtual</span> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classmath___function_with_derivative.html#a46442f2fe16f792dc61fa2adbbed3dad">Derivative</a> (<span class="keyword">const</span> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/namespaceopencascade.html#a5ca01742b10640986e9f619449215b72">x</a>, <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&amp; d) = 0;</div><div class="line">  <span class="keyword">virtual</span> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classmath___function_with_derivative.html#af8356eaa4afc8a1715a477143f479a3b">Values</a> (<span class="keyword">const</span> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/namespaceopencascade.html#a5ca01742b10640986e9f619449215b72">x</a>, <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&amp; f, <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&amp; d) = 0;</div><div class="line">};</div></div><!-- fragment --><p>Now the test sample uses the <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classmath___bissec_newton.html">math_BissecNewton</a></em> class to find the root of the equation <em>f(x)=x**2-4</em> in the interval [1.5, 2.5]. The function to solve is implemented in the class <em>myFunction</em> which inherits from the class <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classmath___function_with_derivative.html">math_FunctionWithDerivative</a></em>, then the main program finds the required root.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/math___bissec_newton_8hxx.html">math_BissecNewton.hxx</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/math___function_with_derivative_8hxx.html">math_FunctionWithDerivative.hxx</a>&gt;</span></div><div class="line"><span class="keyword">class </span>myFunction : <span class="keyword">public</span> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classmath___function_with_derivative.html">math_FunctionWithDerivative</a></div><div class="line">{</div><div class="line">  <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> myCoefA, myCoefB, myCoefC;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">  myFunction (<span class="keyword">const</span> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> theA, <span class="keyword">const</span> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> theB, <span class="keyword">const</span> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> theC)</div><div class="line">  : myCoefA(<a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/namespaceopencascade.html#a8bfaa44f937da5cb5aea81e82f918d0a">a</a>), myCoefB(<a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/namespaceopencascade.html#a5bb39a61f24f11176540a2c890f722bb">b</a>), myCoefC(c) {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classmath___function_with_derivative.html#a54edefe39d7900e71294475f5c985faa">Value</a> (<span class="keyword">const</span> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/namespaceopencascade.html#a5ca01742b10640986e9f619449215b72">x</a>, <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&amp; f)<span class="keyword"> override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    f = myCoefA * x * x + myCoefB * x + myCoefC;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classmath___function_with_derivative.html#a46442f2fe16f792dc61fa2adbbed3dad">Derivative</a> (<span class="keyword">const</span> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/namespaceopencascade.html#a5ca01742b10640986e9f619449215b72">x</a>, <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&amp; d)<span class="keyword"> override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    d = myCoefA * x * 2.0 + myCoefB;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classmath___function_with_derivative.html#af8356eaa4afc8a1715a477143f479a3b">Values</a> (<span class="keyword">const</span> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/namespaceopencascade.html#a5ca01742b10640986e9f619449215b72">x</a>, <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&amp; f, <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&amp; d)<span class="keyword"> override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    f = myCoefA * x * x + myCoefB * x + myCoefC;</div><div class="line">    d = myCoefA * x *  2.0 + myCoefB;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line">main()</div><div class="line">{</div><div class="line">  myFunction aFunc (1.0, 0.0, 4.0);</div><div class="line">  <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classmath___bissec_newton.html">math_BissecNewton</a> aSol (aFunc, 1.5, 2.5, 0.000001);</div><div class="line">  <span class="keywordflow">if</span> (aSol.IsDone()) <span class="comment">// is it OK ?</span></div><div class="line">  {</div><div class="line">    <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/namespaceopencascade.html#a5ca01742b10640986e9f619449215b72">x</a> = aSol.Root(); <span class="comment">// yes</span></div><div class="line">  }</div><div class="line">  <span class="keywordflow">else</span> <span class="comment">// no</span></div><div class="line">  {</div><div class="line">  }</div></div><!-- fragment --><h2><a class="anchor" id="occt_occt_fcug_4_7"></a>
Precision</h2>
<p>On the OCCT platform, each object stored in the database should carry its own precision value. This is important when dealing with systems where objects are imported from other systems as well as with various associated precision values.</p>
<p>The <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_precision.html">Precision</a></em> package addresses the daily problem of the geometric algorithm developer: what precision setting to use to compare two numbers. Real number equivalence is clearly a poor choice. The difference between the numbers should be compared to a given precision setting.</p>
<p>Do not write <em>if (X1 == X2)</em>, instead write <em>if (Abs(X1-X2) &lt; <a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_precision.html">Precision</a>)</em>.</p>
<p>Also, to order real numbers, keep in mind that <em>if (X1 &lt; X2 - <a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_precision.html">Precision</a>)</em> is incorrect. <em>if (X2 - X1 &gt; <a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_precision.html">Precision</a>)</em> is far better when <em>X1</em> and <em>X2</em> are high numbers.</p>
<p>This package proposes a set of methods providing precision settings for the most commonly encountered situations.</p>
<p>In Open CASCADE Technology, precision is usually not implicit; low-level geometric algorithms accept precision settings as arguments. Usually these should not refer directly to this package.</p>
<p>High-level modeling algorithms have to provide a precision setting to the low level geometric algorithms they call. One way is to use the settings provided by this package. The high-level modeling algorithms can also have their own strategy for managing precision. As an example the Topology Data Structure stores precision values which are later used by algorithms. When a new topology is created, it takes the stored value.</p>
<p>Different precision settings offered by this package cover the most common needs of geometric algorithms such as <em>Intersection</em> and <em>Approximation</em>. The choice of a precision value depends both on the algorithm and on the geometric space. The geometric space may be either:</p><ul>
<li>a real space, 3d or 2d where the lengths are measured in meters, micron, inches, etc.</li>
<li>a parametric space, 1d on a curve or 2d on a surface where numbers have no dimension.</li>
</ul>
<p>The choice of precision value for parametric space depends not only on the accuracy of the machine, but also on the dimensions of the curve or the surface. This is because it is desirable to link parametric precision and real precision. If you are on a curve defined by the equation <em>P(t)</em>, you would want to have equivalence between the following:</p>
<div class="fragment"><div class="line">Abs (t1 - t2) &lt; ParametricPrecision</div><div class="line">Distance (P(t1), P(t2)) &lt; RealPrecision</div></div><!-- fragment --><h3><a class="anchor" id="occt_occt_fcug_4_7_1"></a>
The Precision package</h3>
<p>The <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_precision.html">Precision</a></em> package offers a number of package methods and default precisions for use in dealing with angles, distances, intersections, approximations, and parametric space. It provides values to use in comparisons to test for real number equalities.</p><ul>
<li><b>Angular</b> precision compares angles.</li>
<li><b>Confusion</b> precision compares distances.</li>
<li><b>Intersection</b> precision is used by intersection algorithms.</li>
<li><b>Approximation</b> precision is used by approximation algorithms.</li>
<li><b>Parametric</b> precision gets a parametric space precision from a 3D precision.</li>
<li><b>Infinite</b> returns a high number that can be considered to be infinite. Use <em>-Infinite</em> for a high negative number.</li>
</ul>
<h3><a class="anchor" id="occt_occt_fcug_4_7_2"></a>
Standard Precision values</h3>
<p>This package provides a set of real space precision values for algorithms. The real space precisions are designed for precision to <em>0.1</em> nanometers (in case if model is defined in millimeters).</p>
<p>The parametric precisions are derived from the real precisions by the <em>Parametric</em> function. This applies a scaling factor which is the length of a tangent to the curve or the surface. You, the user, provide this length. There is a default value for a curve with <em>[0,1]</em> parameter space and a length less than 100 meters.</p>
<p>The geometric packages provide Parametric precisions for the different types of curves. The <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_precision.html">Precision</a></em> package provides methods to test whether a real number can be considered to be infinite.</p>
<h4><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_precision.html#a873857668aabfc6c21da9bdc78464a3f">Precision::Angular</a></h4>
<p>This method is used to compare two angles. Its current value is <em>Epsilon(2 *  PI)</em> i.e. the smallest number <em>x</em> such that <em>2*PI + x</em> is different of <em>2*PI</em>.</p>
<p>It can be used to check confusion of two angles as follows: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> areEqualAngles (<span class="keywordtype">double</span> theAngle1, <span class="keywordtype">double</span> theAngle2)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___integer_8hxx.html#a976308ebd92254ccd6c6b703f7192518">Abs</a>(theAngle1  - theAngle2) &lt; <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_precision.html#a873857668aabfc6c21da9bdc78464a3f">Precision::Angular</a>();</div><div class="line">}</div></div><!-- fragment --><p>It is also possible to check parallelism of two vectors as follows: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> areParallelVectors (<span class="keyword">const</span> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___vec.html">gp_Vec</a>&amp; theVec1, <span class="keyword">const</span> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___vec.html">gp_Vec</a>&amp; theVec2)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> theVec1.<a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___vec.html#acb33143b21b626b22aebbcbebc65adf4">IsParallel</a> (theVec2, <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_precision.html#a873857668aabfc6c21da9bdc78464a3f">Precision::Angular</a>());</div><div class="line">}</div></div><!-- fragment --><p>Note that <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_precision.html#a873857668aabfc6c21da9bdc78464a3f">Precision::Angular()</a></em> can be used on both dot and cross products because for small angles the <em>Sine</em> and the <em>Angle</em> are equivalent. So to test if two directions of type <em><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___dir.html">gp_Dir</a></em> are perpendicular, it is legal to use the following code: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> arePerpendicular (<span class="keyword">const</span> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___dir.html">gp_Dir</a>&amp; theDir1, <span class="keyword">const</span> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___dir.html">gp_Dir</a>&amp; theDir2)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___integer_8hxx.html#a976308ebd92254ccd6c6b703f7192518">Abs</a>(theDir1 * theDir2) &lt; <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_precision.html#a873857668aabfc6c21da9bdc78464a3f">Precision::Angular</a>();</div><div class="line">}</div></div><!-- fragment --><h4><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_precision.html#a94f8d5777a3e8e1c61bd7bbfa8dfc0eb">Precision::Confusion</a></h4>
<p>This method is used to test 3D distances. The current value is <em>1.e-7</em>, in other words, 1/10 micron if the unit used is the millimeter.</p>
<p>It can be used to check confusion of two points as follows: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> areEqualPoints (<span class="keyword">const</span> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___pnt.html">gp_Pnt</a>&amp; thePnt1, <span class="keyword">const</span> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___pnt.html">gp_Pnt</a>&amp; thePnt2)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> thePnt1.<a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___pnt.html#a4f870af7ffe23dd8ccdaf02bbc2a25ab">IsEqual</a> (thePnt2, <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_precision.html#a94f8d5777a3e8e1c61bd7bbfa8dfc0eb">Precision::Confusion</a>());</div><div class="line">}</div></div><!-- fragment --><p>It is also possible to find a vector of null length: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> isNullVector (<span class="keyword">const</span> <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___vec.html">gp_Vec</a>&amp; theVec)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> theVec.<a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___vec.html#ab59692009b74592f142234a7795d1162">Magnitude</a>() &lt; <a class="codeRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_precision.html#a94f8d5777a3e8e1c61bd7bbfa8dfc0eb">Precision::Confusion</a>();</div><div class="line">}</div></div><!-- fragment --><h4><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_precision.html#a89f1ffc4997b51dbe5d3fa41e0110bd2">Precision::Intersection</a></h4>
<p>This is reasonable precision to pass to an Intersection process as a limit of refinement of Intersection Points. <em>Intersection</em> is high enough for the process to converge quickly. <em>Intersection</em> is lower than <em>Confusion</em> so that you still get a point on the intersected geometries. The current value is <em>Confusion() / 100</em>.</p>
<h4><a class="elRef" doxygen="E:/builds/OCCT-750_OCCT-750/OCCT_SRC/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_precision.html#ace65a7f280a4d6806ac286231c8c0691">Precision::Approximation</a></h4>
<p>This is a reasonable precision to pass to an approximation process as a limit of refinement of fitting. The approximation is greater than the other precisions because it is designed to be used when the time is at a premium. It has been provided as a reasonable compromise by the designers of the Approximation algorithm. The current value is <em>Confusion() * 10</em>. Note that Approximation is greater than Confusion, so care must be taken when using Confusion in an approximation process. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Nov 3 2020 16:33:57 for Open CASCADE Technology by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
