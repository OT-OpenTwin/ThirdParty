<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- tasktree.cpp -->
  <meta name="description" content="A class template used for declaring custom task items and defining their setup and done handlers.">
  <title>CustomTask Class | Extending Qt Creator Manual</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="index.html" translate="no">Extending Qt Creator Manual</a></li>
<li><a href="taskingsolution-module.html" translate="no">TaskingSolution</a></li>
<li>CustomTask</li>
<li id="buildversion"><a href="index.html" translate="no">Extending Qt Creator Manual 13.0&#x2e;0</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">CustomTask Class</h1>
<span class="small-subtitle" translate="no">template &lt;typename Adapter&gt; class <a href="tasking.html" translate="no">Tasking</a>::CustomTask</span>
<!-- $$$CustomTask-brief -->
<p>A class template used for declaring custom task items and defining their setup and done handlers. <a href="#details">More...</a></p>
<!-- @@@CustomTask -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;solutions/tasking/tasktree.h&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="tasking-executableitem.html" translate="no">Tasking::ExecutableItem</a></td></tr>
</table></div>
<ul>
<li><a href="tasking-customtask-members.html">List of all members, including inherited members</a></li>
</ul>
<p><b>Note:</b> All functions in this class are reentrant.</p>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="tasking-customtask.html#Deleter-typedef" translate="no">Deleter</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="tasking-customtask.html#Task-typedef" translate="no">Task</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="tasking-customtask.html#TaskDoneHandler-typedef" translate="no">TaskDoneHandler</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="tasking-customtask.html#TaskSetupHandler-typedef" translate="no">TaskSetupHandler</a></b></td></tr>
</table></div>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="tasking-customtask.html#CustomTask" translate="no">CustomTask</a></b>(SetupHandler &amp;&amp;<i>setup</i> = TaskSetupHandler(), DoneHandler &amp;&amp;<i>done</i> = TaskDoneHandler(), Tasking::CallDoneIf <i>callDoneIf</i> = CallDoneIf::SuccessOrError)</td></tr>
</table></div>
<!-- $$$CustomTask-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>Describes custom task items within task tree recipes.</p>
<p>Custom task names are aliased with unique names using the <code translate="no">CustomTask</code> template with a given <a href="tasking-taskadapter.html" translate="no">TaskAdapter</a> subclass as a template parameter. For example, <code translate="no">ConcurrentCallTask&lt;T&gt;</code> is an alias to the <code translate="no">CustomTask</code> that is defined to work with <code translate="no">ConcurrentCall&lt;T&gt;</code> as an associated task class. The following table contains example custom tasks and their associated task classes:</p>
<div class="table"><table class="generic">
 <thead><tr class="qt-style"><th >Aliased Task Name (Tasking Namespace)</th><th >Associated Task Class</th><th >Brief Description</th></tr></thead>
<tr valign="top" class="odd"><td >ConcurrentCallTask&lt;ReturnType&gt;</td><td >ConcurrentCall&lt;ReturnType&gt;</td><td >Starts an asynchronous task. Runs in a separate thread.</td></tr>
<tr valign="top" class="even"><td >NetworkQueryTask</td><td >NetworkQuery</td><td >Sends a network query.</td></tr>
<tr valign="top" class="odd"><td ><a href="tasking.html#TaskTreeTask-typedef" translate="no">TaskTreeTask</a></td><td ><a href="tasking-tasktree.html" translate="no">TaskTree</a></td><td >Starts a nested task tree.</td></tr>
<tr valign="top" class="even"><td ><a href="tasking.html#TimeoutTask-typedef" translate="no">TimeoutTask</a></td><td ><code translate="no">std::chrono::milliseconds</code></td><td >Starts a timer.</td></tr>
<tr valign="top" class="odd"><td >WaitForBarrierTask</td><td >MultiBarrier&lt;Limit&gt;</td><td >Starts an asynchronous task waiting for the barrier to pass.</td></tr>
</table></div>
</div>
<!-- @@@CustomTask -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$Deleter -->
<h3 class="fn" translate="no" id="Deleter-typedef"><code translate="no">[alias] </code>CustomTask::<span class="name">Deleter</span></h3>
<p>Type alias for the task's type deleter associated with the custom task's <code translate="no">Adapter</code>.</p>
<!-- @@@Deleter -->
<!-- $$$Task -->
<h3 class="fn" translate="no" id="Task-typedef"><code translate="no">[alias] </code>CustomTask::<span class="name">Task</span></h3>
<p>Type alias for the task type associated with the custom task's <code translate="no">Adapter</code>.</p>
<!-- @@@Task -->
<!-- $$$TaskDoneHandler -->
<h3 class="fn" translate="no" id="TaskDoneHandler-typedef"><code translate="no">[alias] </code>CustomTask::<span class="name">TaskDoneHandler</span></h3>
<p>Type alias for <code translate="no">std::function&lt;DoneResult(const Task &amp;, DoneWith)&gt;</code>.</p>
<p>The <code translate="no">TaskDoneHandler</code> is an optional argument of a custom task element's constructor. Any function with the above signature, when passed as a task done handler, will be called by the running task tree after the task execution finished and before the final result of the execution is reported back to the parent group.</p>
<p>Inside the body of the handler you may retrieve the final data from the finished task. The additional parameters, including storages, may be passed to the handler via the lambda capture. It is also possible to decide dynamically whether the task should finish with its return value, or the final result should be tweaked.</p>
<p>The <a href="tasking.html#DoneWith-enum" translate="no">DoneWith</a> argument is optional and your done handler may omit it. When provided, it holds the info about the final result of a task that will be reported to its parent.</p>
<p>If you do not plan to read any data from the finished task, you may omit the <code translate="no">const Task &amp;</code> argument.</p>
<p>The returned <a href="tasking.html#DoneResult-enum" translate="no">DoneResult</a> value is optional and your handler may return <code translate="no">void</code> instead. In this case, the final result of the task will be equal to the value indicated by the <a href="tasking.html#DoneWith-enum" translate="no">DoneWith</a> argument. When the handler returns the <a href="tasking.html#DoneResult-enum" translate="no">DoneResult</a> value, the task's final result may be tweaked inside the done handler's body by the returned value.</p>
<p><b>See also </b><a href="tasking-customtask.html#CustomTask" translate="no">CustomTask</a>(), <a href="tasking-customtask.html#TaskSetupHandler-typedef" translate="no">TaskSetupHandler</a>, and <a href="tasking-groupitem.html#GroupDoneHandler-typedef" translate="no">GroupDoneHandler</a>.</p>
<!-- @@@TaskDoneHandler -->
<!-- $$$TaskSetupHandler -->
<h3 class="fn" translate="no" id="TaskSetupHandler-typedef"><code translate="no">[alias] </code>CustomTask::<span class="name">TaskSetupHandler</span></h3>
<p>Type alias for <code translate="no">std::function&lt;SetupResult(Task &amp;)&gt;</code>.</p>
<p>The <code translate="no">TaskSetupHandler</code> is an optional argument of a custom task element's constructor. Any function with the above signature, when passed as a task setup handler, will be called by the running task tree after the task is created and before it is started.</p>
<p>Inside the body of the handler, you may configure the task according to your needs. The additional parameters, including storages, may be passed to the handler via the lambda capture. You can decide dynamically whether the task should be started or skipped with success or an error.</p>
<div class="admonition note">
<p><b>Note: </b>Do not start the task inside the start handler by yourself. Leave it for <a href="tasking-tasktree.html" translate="no">TaskTree</a>, otherwise the behavior is undefined.</p>
</div>
<p>The return value of the handler instructs the running task tree on how to proceed after the handler's invocation is finished. The return value of <a href="tasking.html#SetupResult-enum" translate="no">SetupResult::Continue</a> instructs the task tree to continue running, that is, to execute the associated <code translate="no">Task</code>. The return value of <a href="tasking.html#SetupResult-enum" translate="no">SetupResult::StopWithSuccess</a> or <a href="tasking.html#SetupResult-enum" translate="no">SetupResult::StopWithError</a> instructs the task tree to skip the task's execution and finish it immediately with success or an error, respectively.</p>
<p>When the return type is either <a href="tasking.html#SetupResult-enum" translate="no">SetupResult::StopWithSuccess</a> or <a href="tasking.html#SetupResult-enum" translate="no">SetupResult::StopWithError</a>, the task's done handler (if provided) isn't called afterwards.</p>
<p>The constructor of a custom task accepts also functions in the shortened form of <code translate="no">std::function&lt;void(Task &amp;)&gt;</code>, that is, the return value is <code translate="no">void</code>. In this case, it's assumed that the return value is <a href="tasking.html#SetupResult-enum" translate="no">SetupResult::Continue</a>.</p>
<p><b>See also </b><a href="tasking-customtask.html#CustomTask" translate="no">CustomTask</a>(), <a href="tasking-customtask.html#TaskDoneHandler-typedef" translate="no">TaskDoneHandler</a>, and <a href="tasking-groupitem.html#GroupSetupHandler-typedef" translate="no">GroupSetupHandler</a>.</p>
<!-- @@@TaskSetupHandler -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$CustomTask[overload1]$$$CustomTaskSetupHandler&&DoneHandler&&Tasking::CallDoneIf -->
<h3 class="fn" translate="no" id="CustomTask">template &lt;typename SetupHandler, typename DoneHandler&gt; CustomTask::<span class="name">CustomTask</span>(<span class="type">SetupHandler</span> &amp;&amp;<i>setup</i> = TaskSetupHandler(), <span class="type">DoneHandler</span> &amp;&amp;<i>done</i> = TaskDoneHandler(), <span class="type"><a href="tasking.html#CallDoneIf-enum" translate="no">Tasking::CallDoneIf</a></span> <i>callDoneIf</i> = CallDoneIf::SuccessOrError)</h3>
<p>Constructs a <code translate="no">CustomTask</code> instance and attaches the <i translate="no">setup</i> and <i translate="no">done</i> handlers to the task. When the running task tree is about to start the task, it instantiates the associated <a href="tasking-customtask.html#Task-typedef" translate="no">Task</a> object, invokes <i translate="no">setup</i> handler with a <i>reference</i> to the created task, and starts it. When the running task finishes, the task tree invokes a <i translate="no">done</i> handler, with a <code translate="no">const</code> <i>reference</i> to the created task.</p>
<p>The passed <i translate="no">setup</i> handler is of the <a href="tasking-customtask.html#TaskSetupHandler-typedef" translate="no">TaskSetupHandler</a> type. For example:</p>
<pre class="cpp" translate="no">
 <span class="keyword">static</span> <span class="type">void</span> parseAndLog(<span class="keyword">const</span> <span class="type">QString</span> <span class="operator">&amp;</span>input);

 <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>

 <span class="keyword">const</span> <span class="type">QString</span> input <span class="operator">=</span> <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>;

 <span class="keyword">const</span> <span class="keyword">auto</span> onFirstSetup <span class="operator">=</span> <span class="operator">[</span>input<span class="operator">]</span>(ConcurrentCall<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;</span> <span class="operator">&amp;</span>task) {
     <span class="keyword">if</span> (input <span class="operator">=</span><span class="operator">=</span> <span class="string">&quot;Skip&quot;</span>)
         <span class="keyword">return</span> SetupResult<span class="operator">::</span>StopWithSuccess; <span class="comment">// This task won't start, the next one will</span>
     <span class="keyword">if</span> (input <span class="operator">=</span><span class="operator">=</span> <span class="string">&quot;Error&quot;</span>)
         <span class="keyword">return</span> SetupResult<span class="operator">::</span>StopWithError; <span class="comment">// This task and the next one won't start</span>
     task<span class="operator">.</span>setConcurrentCallData(parseAndLog<span class="operator">,</span> input);
     <span class="comment">// This task will start, and the next one will start after this one finished with success</span>
     <span class="keyword">return</span> SetupResult<span class="operator">::</span>Continue;
 };

 <span class="keyword">const</span> <span class="keyword">auto</span> onSecondSetup <span class="operator">=</span> <span class="operator">[</span>input<span class="operator">]</span>(ConcurrentCall<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;</span> <span class="operator">&amp;</span>task) {
     task<span class="operator">.</span>setConcurrentCallData(parseAndLog<span class="operator">,</span> input);
 };

 <span class="keyword">const</span> Group group {
     ConcurrentCallTask<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;</span>(onFirstSetup)<span class="operator">,</span>
     ConcurrentCallTask<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;</span>(onSecondSetup)
 };
</pre>
<p>The <i translate="no">done</i> handler is of the <a href="tasking-customtask.html#TaskDoneHandler-typedef" translate="no">TaskDoneHandler</a> type. By default, the <i translate="no">done</i> handler is invoked whenever the task finishes. Pass a non-default value for the <i translate="no">callDoneIf</i> argument when you want the handler to be called only on a successful or failed execution.</p>
<p><b>See also </b><a href="tasking-customtask.html#TaskSetupHandler-typedef" translate="no">TaskSetupHandler</a> and <a href="tasking-customtask.html#TaskDoneHandler-typedef" translate="no">TaskDoneHandler</a>.</p>
<!-- @@@CustomTask -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2023 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/>    Qt and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of The Qt Company Ltd. in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
