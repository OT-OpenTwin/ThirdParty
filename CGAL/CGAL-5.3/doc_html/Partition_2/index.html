<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Partition_2/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=9" />
<meta name="generator" content="Doxygen 1.8.13" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CGAL 5.3 - 2D Polygon Partitioning: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
//&amp;lt;![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
          Ac: [ "{\\cal A}", 0],
          Sc: [ "{\\cal S}", 0],
      }
  }
}
);
//]]&amp;gt;
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 5.3 - 2D Polygon Partitioning
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_2D_Polygon_Partitioning"></a><a class="anchor" id="chappolygonpartition"></a> </p><div id="autotoc" class="toc"></div>  <dl class="section author"><dt>Author</dt><dd>Susan Hert</dd></dl>
<h1><a class="anchor" id="secpartition_2_intro"></a>
Introduction</h1>
<p>A <em>partition</em> of a polygon \( P\) is a set of polygons such that the interiors of the polygons do not intersect and the union of the polygons is equal to the interior of the original polygon \( P\). This chapter describes functions for partitioning planar polygons into two types of subpolygons - \( y\)-monotone polygons and convex polygons. The partitions are produced without introducing new (Steiner) vertices.</p>
<p>All the partitioning functions present the same interface to the user. That is, the user provides a pair of input iterators, <code>first</code> and <code>beyond</code>, an output iterator <code>result</code>, and a traits class <code>traits</code>. The points in the range [<code>first</code>, <code>beyond</code>) are assumed to define a simple polygon whose vertices are in counterclockwise order. The computed partition polygons, whose vertices are also oriented counterclockwise, are written to the sequence starting at position <code>result</code> and the past-the-end iterator for the resulting sequence of polygons is returned. The traits classes for the functions specify the types of the input points and output polygons as well as a few other types and function objects that are required by the various algorithms.</p>
<h1><a class="anchor" id="secpartition_2_monotone"></a>
Monotone Partitioning</h1>
<p>A <em> \( y\)-monotone polygon</em> is a polygon whose vertices \( v_1, \ldots, v_n\) can be divided into two chains \( v_1, \ldots, v_k\) and \( v_k, \ldots, v_n, v_1\), such that any horizontal line intersects either chain at most once. For producing a \( y\)-monotone partition of a given polygon, the sweep-line algorithm presented in <a class="el" href="citelist.html#CITEREF_bkos-cgaa-97">[1]</a> is implemented by the function <code><a class="el" href="group__PkgPartition2Ref.html#ga35cdd9f604522c2ce4ca97d928a41f38" title="computes a partition of the polygon defined by the points in the range [first, beyond) into -monotone...">y_monotone_partition_2()</a></code>. This algorithm runs in \( O(n \log n)\) time and requires \( O(n)\) space. This algorithm does not guarantee a bound on the number of polygons produced with respect to the optimal number.</p>
<p>For checking the validity of the partitions produced by <code><a class="el" href="group__PkgPartition2Ref.html#ga35cdd9f604522c2ce4ca97d928a41f38" title="computes a partition of the polygon defined by the points in the range [first, beyond) into -monotone...">y_monotone_partition_2()</a></code>, we provide a function <code><a class="el" href="group__PkgPartition2Ref.html#gae795b8beb8626322c448706e20a8ac9b" title="determines if the sequence of points in the range [first, beyond) defines a -monotone polygon or not...">is_y_monotone_2()</a></code>, which determines if a sequence of points in 2D defines a \( y\)-monotone polygon or not. For examples of the use of these functions, see the corresponding reference pages.</p>
<h1><a class="anchor" id="secpartition_2_convex"></a>
Convex Partitioning</h1>
<p>Three functions are provided for producing convex partitions of polygons. One produces a partition that is optimal in the number of pieces. The other two functions produce approximately optimal convex partitions. Both these functions produce convex decompositions by first decomposing the polygon into simpler polygons; the first uses a triangulation and the second a monotone partition. These two functions both guarantee that they will produce no more than four times the optimal number of convex pieces but they differ in their runtime complexities. Though the triangulation-based approximation algorithm often results in fewer convex pieces, this is not always the case.</p>
<p><a class="anchor" id="fig__P2_approxvsopti"></a></p><div class="image">
<img src="approximate_optimal_vs_optimal.png" alt="approximate_optimal_vs_optimal.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__P2_approxvsopti">Figure 19.1</a> Examples of an approximate optimal convex partition (left) and an optimal convex partition (right).  </div> <br /> 
<p>An optimal convex partition can be produced using the function <code><a class="el" href="group__PkgPartition2Ref.html#ga3ca9fb1f363f9f792bfbbeca65ad5cc5" title="computes a partition of the polygon defined by the points in the range [first, beyond) into convex po...">optimal_convex_partition_2()</a></code>.</p>
<p>This function provides an implementation of Greene's dynamic programming algorithm for optimal partitioning <a class="el" href="citelist.html#CITEREF_g-dpcp-83">[2]</a>. This algorithm requires \( O(n^4)\) time and \( O(n^3)\) space in the worst case.</p>
<p>The function <code><a class="el" href="group__PkgPartition2Ref.html#gab9cf8c2b097fd562da09dd23d0c74edf" title="computes a partition of the polygon defined by the points in the range [first, beyond) into convex po...">approx_convex_partition_2()</a></code> implements the simple approximation algorithm of Hertel and Mehlhorn <a class="el" href="citelist.html#CITEREF_hm-ftsp-83">[3]</a> that produces a convex partitioning of a polygon from a triangulation by throwing out unnecessary triangulation edges. The triangulation used in this function is one produced by the 2-dimensional constrained triangulation package of CGAL. For a given triangulation, this convex partitioning algorithm requires \( O(n)\) time and space to construct a decomposition into no more than four times the optimal number of convex pieces.</p>
<p>The sweep-line approximation algorithm of Greene <a class="el" href="citelist.html#CITEREF_g-dpcp-83">[2]</a>, which, given a monotone partition of a polygon, produces a convex partition in \( O(n \log n)\) time and \( O(n)\) space, is implemented by the function <code><a class="el" href="group__PkgPartition2Ref.html#ga68139e1ee98dffa8f72cb295881f4647" title="computes a partition of the polygon defined by the points in the range [first, beyond) into convex po...">greene_approx_convex_partition_2()</a></code>. The function <code><a class="el" href="group__PkgPartition2Ref.html#ga35cdd9f604522c2ce4ca97d928a41f38" title="computes a partition of the polygon defined by the points in the range [first, beyond) into -monotone...">y_monotone_partition_2()</a></code> described in Section <a class="el" href="index.html#secpartition_2_monotone">Monotone Partitioning</a> is used to produce the monotone partition. This algorithm provides the same worst-case approximation guarantee as the algorithm of Hertel and Mehlhorn implemented with <code><a class="el" href="group__PkgPartition2Ref.html#gab9cf8c2b097fd562da09dd23d0c74edf" title="computes a partition of the polygon defined by the points in the range [first, beyond) into convex po...">approx_convex_partition_2()</a></code> but can sometimes produce better results (i.e., convex partitions with fewer pieces).</p>
<h1><a class="anchor" id="secpartition_2_examples"></a>
Examples</h1>
<p>Examples of the uses of all of the above partition functions are provided with the corresponding reference pages.</p>
<p>In the following we illustrate how to use a property map to enable the trais class to deal with polygons where the vertices are not points. In the example the points are in a vector and the polygons are sequences of indices.</p>
<p>The class <code>Partition_2</code> has two template parameters, namely a geometric traits class, and a property map to obtain points, in the example by accessing <code>points[i]</code> for the polygon vertex <code>i</code>, and it then performs the predicates required by the concept <code><a class="el" href="classPartitionTraits__2.html" title="The polygon partitioning functions are each parameterized by a traits class that defines the primitiv...">PartitionTraits_2</a></code> on these points.</p>
<p><br />
<b>File</b> <a class="el" href="Partition_2_2y_monotone_partition_indices_2_8cpp-example.html">Partition_2/y_monotone_partition_indices_2.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/partition_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Partition_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-5.3-I-162/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> K;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Partition__traits__2.html">CGAL::Partition_traits_2&lt;K, CGAL::Pointer_property_map&lt;K::Point_2&gt;::type</a> &gt; Partition_traits_2;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Partition__traits__2.html#a62c198d9da3e45f8bcbbcd0176289d82">Partition_traits_2::Point_2</a>                         Point_2;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Partition__traits__2.html#afbc2a23b317bc6565eaaf70d741ade1c">Partition_traits_2::Polygon_2</a>                       Polygon_2;  <span class="comment">// a polygon of indices</span></div><div class="line"><span class="keyword">typedef</span> std::list&lt;Polygon_2&gt;                                Polygon_list;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">      v4     v2</span></div><div class="line"><span class="comment">      | \   /|</span></div><div class="line"><span class="comment">      |  \ / |</span></div><div class="line"><span class="comment">      |  v3  |</span></div><div class="line"><span class="comment">      |      |</span></div><div class="line"><span class="comment">      v0-----v1</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main( )</div><div class="line">{</div><div class="line">  std::vector&lt;K::Point_2&gt; points = { K::Point_2(0,0), K::Point_2(2,0), K::Point_2(2,2), K::Point_2(1,1), K::Point_2(0,2) };</div><div class="line">  Partition_traits_2 traits(CGAL::make_property_map(points));</div><div class="line"></div><div class="line"></div><div class="line">  Polygon_2 polygon;</div><div class="line">  polygon.push_back(0);</div><div class="line">  polygon.push_back(1);</div><div class="line">  polygon.push_back(2);</div><div class="line">  polygon.push_back(3);</div><div class="line">  polygon.push_back(4);</div><div class="line"></div><div class="line">  Polygon_list partition_polys;</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgPartition2Ref.html#ga35cdd9f604522c2ce4ca97d928a41f38">CGAL::y_monotone_partition_2</a>(polygon.vertices_begin(),</div><div class="line">                               polygon.vertices_end(),</div><div class="line">                               std::back_inserter(partition_polys),</div><div class="line">                               traits);</div><div class="line"></div><div class="line">   <span class="keywordflow">for</span> (<span class="keyword">const</span> Polygon_2&amp; poly : partition_polys){</div><div class="line">     <span class="keywordflow">for</span>(Point_2 p : poly.container()){</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">"points["</span> &lt;&lt; p &lt;&lt; <span class="stringliteral">"] =  "</span> &lt;&lt; points[p] &lt;&lt; <span class="stringliteral">", "</span>;</div><div class="line">      }</div><div class="line">     std::cout &lt;&lt; std::endl;</div><div class="line">   }</div><div class="line"></div><div class="line">   assert(<a class="code" href="group__PkgPartition2Ref.html#gaa4c7b5c06a64608fca50ddb2af49d498">CGAL::partition_is_valid_2</a>(polygon.vertices_begin(),</div><div class="line">                                     polygon.vertices_end(),</div><div class="line">                                     partition_polys.begin(),</div><div class="line">                                     partition_polys.end(),</div><div class="line">                                     traits));</div><div class="line"></div><div class="line">   <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>In a similar way, the use of an appropriate property map enables to partition faces of a polygonal mesh, or to access points which are a component of a <code>std::tuple</code>.</p>
<h1><a class="anchor" id="secpartition_2_history"></a>
Implementation History</h1>
<p>This package has originally been written by Susan Hert while working at the Max-Planck Institute for Infomatics in Germany. The algorithms have been made free of constructions, and the property map has been added by GeometryFactory for CGAL 5.0. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sun Jul 4 2021 21:32:47 for CGAL 5.3 - 2D Polygon Partitioning by
    <a href="https://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>


</html>
