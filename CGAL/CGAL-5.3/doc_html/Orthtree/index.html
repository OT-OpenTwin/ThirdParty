<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Orthtree/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=9" />
<meta name="generator" content="Doxygen 1.8.13" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CGAL 5.3 - Quadtrees, Octrees, and Orthtrees: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
//&amp;lt;![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
          Ac: [ "{\\cal A}", 0],
          Sc: [ "{\\cal S}", 0],
      }
  }
}
);
//]]&amp;gt;
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 5.3 - Quadtrees, Octrees, and Orthtrees
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_Orthtree"></a>  </p><div id="autotoc" class="toc"></div>  <dl class="section author"><dt>Authors</dt><dd>Jackson Campolattaro, Simon Giraudot, CÃ©dric Portaneri, Tong Zhao, Pierre Alliez</dd></dl>
<h1><a class="anchor" id="Section_Orthtree_Introduction"></a>
Introduction</h1>
<p>Quadtrees are tree data structures in which each node encloses a square section of space, and each internal node has exactly 4 children. Octrees are a similar data structure in 3D in which each node encloses a cubic section of space, and each internal node has exactly 8 children.</p>
<p>We call the generalization of such data structure "orthtrees", as orthants are generalizations of quadrants and octants. The term "hyperoctree" can also be found in literature to name such data structures in dimensions 4 and higher.</p>
<p>This package provides a general data structure <code><a class="el" href="classCGAL_1_1Orthtree.html" title="A data structure using an axis-aligned hybercubic decomposition of dD space for efficient point acces...">Orthtree</a></code> along with aliases for <code><a class="el" href="classCGAL_1_1Quadtree.html" title="Alias that specializes the Orthtree class to a 2D quadtree. ">Quadtree</a></code> and <code><a class="el" href="classCGAL_1_1Octree.html" title="Alias that specializes the Orthtree class to a 3D octree. ">Octree</a></code>. These trees can be constructed with custom point ranges and split predicates, and iterated on with various traversal methods.</p>
<p><a class="anchor" id="fig__Orthtree_fig"></a></p><div class="image">
<img src="orthtree.png" alt="orthtree.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Orthtree_fig">Figure 90.1</a> Building an orthtree in 3D (octree) from a point cloud.  </div> <br /> 
<h1><a class="anchor" id="Section_Orthtree_Building"></a>
Building</h1>
<p>An orthtree is created using a set of points. The points are not copied: the provided point range is used directly and is rearranged by the orthtree. Altering the point range after creating the orthtree might leave it in an invalid state. The constructor returns a tree with a single (root) node that contains all the points.</p>
<p>The method <a class="el" href="classCGAL_1_1Orthtree.html#ab0391277fafa47af6ec44ef75d020d23">refine()</a> must be called to subdivide space further. This method uses a split predicate which takes a node as input and returns <code>true</code> if this node should be split, <code>false</code> otherwise: this enables users to choose on what criterion should the orthtree be refined. Predefined predicates are provided such as <a class="el" href="classCGAL_1_1Orthtrees_1_1Maximum__depth.html">Maximum_depth</a> or <a class="el" href="classCGAL_1_1Orthtrees_1_1Maximum__number__of__inliers.html">Maximum_number_of_inliers</a>.</p>
<p>The simplest way to create an orthtree is using a vector of points. The constructor generally expects a separate point range and map, but the point map defaults to <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-5.3-I-162/doc/scripts/doc_1_8_13/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Identity__property__map.html">Identity_property_map</a></code> if none is provided.</p>
<p>The split predicate is a user-defined functor that determines whether a node needs to be split. Custom predicates can easily be defined if the existing ones do not match users' needs.</p>
<h2><a class="anchor" id="Section_Orthtree_Quadtree"></a>
Building a Quadtree</h2>
<p>The <code><a class="el" href="classCGAL_1_1Orthtree.html" title="A data structure using an axis-aligned hybercubic decomposition of dD space for efficient point acces...">Orthtree</a></code> class may be templated with <code><a class="el" href="structCGAL_1_1Orthtree__traits__2.html" title="The class Orthtree_traits_2 can be used as a template parameter of the Orthtree class. ">Orthtree_traits_2</a></code> and thus behave as a quadtree. For convenience, the alias <code><a class="el" href="classCGAL_1_1Quadtree.html" title="Alias that specializes the Orthtree class to a 2D quadtree. ">Quadtree</a></code> is provided.</p>
<p>The following example shows how to create a quadtree object from a vector of <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-5.3-I-162/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__2.html">Point_2</a></code> objects and refine it, which means constructing the tree's space subdivision itself, using a maximum depth of 10 and a maximum number of inliers per node (bucket size) of 5. The refinement is stopped as soon as one of the conditions is violated: if a node has more inliers than <code>bucket_size</code> but is already at <code>max_depth</code>, it is not split. Similarly, a node that is at a depth smaller than <code>max_depth</code> but already has fewer inliers than <code>bucket_size</code> is not split.</p>
<p><br />
<b>File</b> <a class="el" href="Orthtree_2quadtree_build_from_point_vector_8cpp-example.html">Orthtree/quadtree_build_from_point_vector.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Quadtree.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Random.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Type Declarations</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-5.3-I-162/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-5.3-I-162/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-5.3-I-162/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a> Point_2;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point_2&gt; Point_vector;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Quadtree.html">CGAL::Quadtree&lt;Kernel, Point_vector&gt;</a> Quadtree;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  CGAL::Random r;</div><div class="line">  Point_vector points_2d;</div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; 5; ++ i)</div><div class="line">    points_2d.emplace_back(r.get_double(-1., 1.),</div><div class="line">                           r.get_double(-1., 1.));</div><div class="line"></div><div class="line">  Quadtree quadtree(points_2d);</div><div class="line">  quadtree.refine(10, 5);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Section_Orthtree_Point_Vector"></a>
Building an Octree</h2>
<p>The <code><a class="el" href="classCGAL_1_1Orthtree.html" title="A data structure using an axis-aligned hybercubic decomposition of dD space for efficient point acces...">Orthtree</a></code> class may be templated with <code><a class="el" href="structCGAL_1_1Orthtree__traits__3.html" title="The class Orthtree_traits_3 can be used as a template parameter of the Orthtree class. ">Orthtree_traits_3</a></code> and thus behave as an octree. For convenience, the alias <code><a class="el" href="classCGAL_1_1Octree.html" title="Alias that specializes the Orthtree class to a 3D octree. ">Octree</a></code> is provided.</p>
<p>The following example shows how to create an octree from a vector of <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-5.3-I-162/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__3.html">Point_3</a></code> objects:</p>
<p><br />
<b>File</b> <a class="el" href="Orthtree_2octree_build_from_point_vector_8cpp-example.html">Orthtree/octree_build_from_point_vector.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Octree.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Type Declarations</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-5.3-I-162/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-5.3-I-162/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-5.3-I-162/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> std::list&lt;Point&gt; Point_vector;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Octree.html">CGAL::Octree&lt;Kernel, Point_vector&gt;</a> Octree;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line"></div><div class="line">  <span class="comment">// Here, our point set is a vector</span></div><div class="line">  Point_vector points;</div><div class="line"></div><div class="line">  <span class="comment">// Add a few points to the vector</span></div><div class="line">  points.emplace_back(1, 1, 1);</div><div class="line">  points.emplace_back(2, 1, -11);</div><div class="line">  points.emplace_back(2, 1, 1);</div><div class="line">  points.emplace_back(1, -2, 1);</div><div class="line">  points.emplace_back(1, 1, 1);</div><div class="line">  points.emplace_back(-1, 1, 1);</div><div class="line"></div><div class="line">  <span class="comment">// Create an octree from the points</span></div><div class="line">  Octree octree(points);</div><div class="line"></div><div class="line">  <span class="comment">// Build the octree</span></div><div class="line">  octree.refine(10, 20);</div><div class="line"></div><div class="line">  <span class="comment">// Print out the tree</span></div><div class="line">  std::cout &lt;&lt; octree;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Section_Orthtree_Point_Set"></a>
Building an Octree from a Point_set_3</h2>
<p>Some data structures such as <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-5.3-I-162/doc/scripts/doc_1_8_13/doc_tags/Point_set_3.tag:../Point_set_3/" href="../Point_set_3/classCGAL_1_1Point__set__3.html">Point_set_3</a></code> require a non-default point map type and object. This example illustrates how to create an octree from a <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-5.3-I-162/doc/scripts/doc_1_8_13/doc_tags/Point_set_3.tag:../Point_set_3/" href="../Point_set_3/classCGAL_1_1Point__set__3.html">Point_set_3</a></code> loaded from a file. It also shows a more explicit way of setting the split predicate when refining the tree.</p>
<p>An octree is constructed from the point set and its map. The tree is refined with a maximum depth (deepest node allowed) of 10, and a bucket size (maximum number of points contained by a single node) of 20. The tree is then written to the standard output.</p>
<p>The split predicate is manually constructed and passed to the refine method.</p>
<p><br />
<b>File</b> <a class="el" href="Orthtree_2octree_build_from_point_set_8cpp-example.html">Orthtree/octree_build_from_point_set.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Octree.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3/IO.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Type Declarations</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-5.3-I-162/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-5.3-I-162/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-5.3-I-162/doc/scripts/doc_1_8_13/doc_tags/Point_set_3.tag:../Point_set_3/" href="../Point_set_3/classCGAL_1_1Point__set__3.html">CGAL::Point_set_3&lt;Point&gt;</a> Point_set;</div><div class="line"><span class="keyword">typedef</span> Point_set::Point_map Point_map;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Octree.html">CGAL::Octree&lt;Kernel, Point_set, Point_map&gt;</a> Octree;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv) {</div><div class="line"></div><div class="line">  <span class="comment">// Point set will be used to hold our points</span></div><div class="line">  Point_set points;</div><div class="line"></div><div class="line">  <span class="comment">// Load points from a file.</span></div><div class="line">  std::ifstream stream((argc &gt; 1) ? argv[1] : <span class="stringliteral">"data/cube.pwn"</span>);</div><div class="line">  stream &gt;&gt; points;</div><div class="line">  <span class="keywordflow">if</span> (0 == points.number_of_points()) {</div><div class="line"></div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"loaded "</span> &lt;&lt; points.number_of_points() &lt;&lt; <span class="stringliteral">" points\n"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Create an octree from the points</span></div><div class="line">  Octree octree(points, points.point_map());</div><div class="line"></div><div class="line">  <span class="comment">// Build the octree with a small bucket size, using a more verbose method</span></div><div class="line">  octree.refine(<a class="code" href="classCGAL_1_1Orthtrees_1_1Maximum__depth__and__maximum__number__of__inliers.html">CGAL::Orthtrees::Maximum_depth_and_maximum_number_of_inliers</a>(5, 10));</div><div class="line"></div><div class="line">  <span class="comment">// Print out the tree</span></div><div class="line">  std::cout &lt;&lt; octree;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Section_Orthtree_Custom_Split_Precicate"></a>
Building an Octree with a Custom Split Predicate</h2>
<p>The following example illustrates how to refine an octree using a split predicate that isn't provided by default. This particular predicate sets a node's bucket size as a ratio of its depth. For example, for a ratio of 2, a node at depth 2 can hold 4 points, a node at depth 7 can hold 14.</p>
<p><br />
<b>File</b> <a class="el" href="Orthtree_2octree_build_with_custom_split_8cpp-example.html">Orthtree/octree_build_with_custom_split.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Octree.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3/IO.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Type Declarations</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-5.3-I-162/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-5.3-I-162/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-5.3-I-162/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a> FT;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-5.3-I-162/doc/scripts/doc_1_8_13/doc_tags/Point_set_3.tag:../Point_set_3/" href="../Point_set_3/classCGAL_1_1Point__set__3.html">CGAL::Point_set_3&lt;Point&gt;</a> Point_set;</div><div class="line"><span class="keyword">typedef</span> Point_set::Point_map Point_map;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Octree.html">CGAL::Octree&lt;Kernel, Point_set, Point_map&gt;</a> Octree;</div><div class="line"></div><div class="line"><span class="comment">// Split Predicate</span></div><div class="line"><span class="comment">// The predicate is a functor which returns a boolean value, whether a node needs to be split or not</span></div><div class="line"><span class="keyword">struct </span>Split_by_ratio {</div><div class="line"></div><div class="line">  std::size_t ratio;</div><div class="line"></div><div class="line">  Split_by_ratio(std::size_t ratio) : ratio(ratio) {}</div><div class="line"></div><div class="line">  <span class="keyword">template</span>&lt;<span class="keyword">class</span> Node&gt;</div><div class="line">  <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> Node &amp;n)<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> n.size() &gt; (ratio * n.depth());</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv) {</div><div class="line"></div><div class="line">  <span class="comment">// Point set will be used to hold our points</span></div><div class="line">  Point_set points;</div><div class="line"></div><div class="line">  <span class="comment">// Load points from a file.</span></div><div class="line">  std::ifstream stream((argc &gt; 1) ? argv[1] : <span class="stringliteral">"data/cube.pwn"</span>);</div><div class="line">  stream &gt;&gt; points;</div><div class="line">  <span class="keywordflow">if</span> (0 == points.number_of_points()) {</div><div class="line"></div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"loaded "</span> &lt;&lt; points.number_of_points() &lt;&lt; <span class="stringliteral">" points"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Create an octree from the points</span></div><div class="line">  Octree octree(points, points.point_map());</div><div class="line"></div><div class="line">  <span class="comment">// Build the octree using our custom split predicate</span></div><div class="line">  octree.refine(Split_by_ratio(2));</div><div class="line"></div><div class="line">  <span class="comment">// Print out the tree</span></div><div class="line">  std::cout &lt;&lt; octree;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Section_Orthtree_Orthtree_Point_Vector"></a>
Building an Orthtree</h2>
<p>The following example shows how to build an generalized orthtree in dimension 4. A <code>std::vector&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-5.3-I-162/doc/scripts/doc_1_8_13/doc_tags/Kernel_d.tag:../Kernel_d/" href="../Kernel_d/classCGAL_1_1Point__d.html">Point_d</a>&gt;</code> is manually filled with points. The vector is used as the point set, an <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-5.3-I-162/doc/scripts/doc_1_8_13/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Identity__property__map.html">Identity_property_map</a></code> is automatically set as the orthtree's map type, so a map does not need to be provided.</p>
<p><br />
<b>File</b> <a class="el" href="Orthtree_2orthtree_build_8cpp-example.html">Orthtree/orthtree_build.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Epick_d.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Orthtree.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Orthtree_traits_d.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Random.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Type Declarations</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-5.3-I-162/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Dimension__tag.html">CGAL::Dimension_tag&lt;4&gt;</a> Dimension;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-5.3-I-162/doc/scripts/doc_1_8_13/doc_tags/Kernel_d.tag:../Kernel_d/" href="../Kernel_d/structCGAL_1_1Epick__d.html">CGAL::Epick_d&lt;Dimension&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> Kernel::Point_d Point_d;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point_d&gt; Point_vector;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="structCGAL_1_1Orthtree__traits__d.html">CGAL::Orthtree_traits_d&lt;Kernel, Dimension&gt;</a> Traits;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Orthtree.html">CGAL::Orthtree&lt;Traits, Point_vector&gt;</a> Orthtree;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  CGAL::Random r;</div><div class="line"></div><div class="line">  Point_vector points_dd;</div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; 5; ++ i)</div><div class="line">  {</div><div class="line">    std::array&lt;double, Dimension::value&gt; init;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">double</span>&amp; v : init)</div><div class="line">      v = r.get_double(-1., 1.);</div><div class="line">    points_dd.emplace_back (init.begin(), init.end());</div><div class="line">  }</div><div class="line"></div><div class="line">  Orthtree orthtree(points_dd);</div><div class="line">  orthtree.refine(10, 5);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="Section_Orthtree_Traversal"></a>
Traversal</h1>
<dl class="section note"><dt>Note</dt><dd>For simplicity, the rest of the user manual will only use octrees, but all the presented features also apply to quadtrees and higher dimension orthtrees.</dd></dl>
<p>Traversal is the act of navigating among the nodes of the tree. The <code><a class="el" href="classCGAL_1_1Orthtree.html" title="A data structure using an axis-aligned hybercubic decomposition of dD space for efficient point acces...">Orthtree</a></code> and <a class="el" href="classCGAL_1_1Orthtree_1_1Node.html">Node</a> classes provide a number of different solutions for traversing the tree.</p>
<h2><a class="anchor" id="Section_Orthtree_Manual_Traveral"></a>
Manual Traversal</h2>
<p>Because our orthtree is a form of connected acyclic undirected graph, it is possible to navigate between any two nodes. What that means in practice, is that given a node on the tree, it is possible to access any other node using the right set of operations. The <code>Node</code> class provides functions that enable the user to access each of its children, as well as its parent (if it exists).</p>
<p>The following example demonstrates ways of accessing different nodes of a tree, given a reference to one.</p>
<p>From the root node, children can be accessed using the subscript operator <code><a class="el" href="classCGAL_1_1Orthtree_1_1Node.html#a706069ea795fdf65b289f597ce1eb8fd" title="returns the nth child fo this node. ">CGAL::Orthtree::Node::operator[]()</a></code>. For an octree, values from 0-7 provide access to the different children.</p>
<p>For non-root nodes, it is possible to access parent nodes using the <a class="el" href="classCGAL_1_1Orthtree_1_1Node.html#abb83d03abd150a1ff45ab706d6828e39">parent()</a> accessor.</p>
<p>These accessors and operators can be chained to access any node in the tree in a single line of code, as shown in the following example:</p>
<p><br />
<b>File</b> <a class="el" href="Orthtree_2octree_traversal_manual_8cpp-example.html">Orthtree/octree_traversal_manual.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Octree.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3/IO.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Type Declarations</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-5.3-I-162/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-5.3-I-162/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-5.3-I-162/doc/scripts/doc_1_8_13/doc_tags/Point_set_3.tag:../Point_set_3/" href="../Point_set_3/classCGAL_1_1Point__set__3.html">CGAL::Point_set_3&lt;Point&gt;</a> Point_set;</div><div class="line"><span class="keyword">typedef</span> Point_set::Point_map Point_map;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Octree.html">CGAL::Octree&lt;Kernel, Point_set, Point_map&gt;</a> Octree;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv) {</div><div class="line"></div><div class="line">  <span class="comment">// Point set will be used to hold our points</span></div><div class="line">  Point_set points;</div><div class="line"></div><div class="line">  <span class="comment">// Load points from a file.</span></div><div class="line">  std::ifstream stream((argc &gt; 1) ? argv[1] : <span class="stringliteral">"data/cube.pwn"</span>);</div><div class="line">  stream &gt;&gt; points;</div><div class="line">  <span class="keywordflow">if</span> (0 == points.number_of_points()) {</div><div class="line"></div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"loaded "</span> &lt;&lt; points.number_of_points() &lt;&lt; <span class="stringliteral">" points\n"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Create an octree from the points</span></div><div class="line">  Octree octree(points, points.point_map());</div><div class="line"></div><div class="line">  <span class="comment">// Build the octree using the default arguments</span></div><div class="line">  octree.refine();</div><div class="line"></div><div class="line">  <span class="comment">// Print out a few nodes</span></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Navigation relative to the root node"</span> &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"</span> &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"the root node: "</span> &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; octree.root() &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"the first child of the root node: "</span> &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; octree.root()[0] &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"the fifth child: "</span> &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; octree.root()[4] &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"the fifth child, accessed without the root keyword: "</span> &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; octree[4] &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"the second child of the fourth child: "</span> &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; octree.root()[4][1] &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"the second child of the fourth child, accessed without the root keyword: "</span> &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; octree[4][1] &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Retrieve one of the deeper children</span></div><div class="line">  Octree::Node cur = octree[3][2];</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Navigation relative to a child node"</span> &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"</span> &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"the third child of the fourth child: "</span> &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; cur &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"the third child: "</span> &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; cur.parent() &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"the next sibling of the third child of the fourth child: "</span> &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; cur.parent()[cur.local_coordinates().to_ulong() + 1] &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Section_Orthtree_Preorder_Traversal"></a>
Preorder Traversal</h2>
<p>It is often useful to be able to iterate over the nodes of the tree in a particular order. For example, the stream operator <code>&lt;&lt;</code> uses a traversal to print out each node. A few traversals are provided, among them <a class="el" href="structCGAL_1_1Orthtrees_1_1Preorder__traversal.html">Preorder_traversal</a> and <a class="el" href="structCGAL_1_1Orthtrees_1_1Postorder__traversal.html">Postorder_traversal</a>. To traverse a tree in preorder is to visit each parent immediately followed by its children, whereas in postorder, traversal the children are visited first.</p>
<p>The following example illustrates how to use the provided traversals.</p>
<p>A tree is constructed, and a traversal is used to create a range that can be iterated over using a for-each loop. The default output operator for the orthtree uses the preorder traversal to do a pretty-print of the tree structure. In this case, we print out the nodes of the tree without indentation instead.</p>
<p><br />
<b>File</b> <a class="el" href="Orthtree_2octree_traversal_preorder_8cpp-example.html">Orthtree/octree_traversal_preorder.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Octree.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3/IO.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Type Declarations</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-5.3-I-162/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-5.3-I-162/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-5.3-I-162/doc/scripts/doc_1_8_13/doc_tags/Point_set_3.tag:../Point_set_3/" href="../Point_set_3/classCGAL_1_1Point__set__3.html">CGAL::Point_set_3&lt;Point&gt;</a> Point_set;</div><div class="line"><span class="keyword">typedef</span> Point_set::Point_map Point_map;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Octree.html">CGAL::Octree&lt;Kernel, Point_set, Point_map&gt;</a> Octree;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="structCGAL_1_1Orthtrees_1_1Preorder__traversal.html">CGAL::Orthtrees::Preorder_traversal</a> Preorder_traversal;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv) {</div><div class="line"></div><div class="line">  <span class="comment">// Point set will be used to hold our points</span></div><div class="line">  Point_set points;</div><div class="line"></div><div class="line">  <span class="comment">// Load points from a file.</span></div><div class="line">  std::ifstream stream((argc &gt; 1) ? argv[1] : <span class="stringliteral">"data/cube.pwn"</span>);</div><div class="line">  stream &gt;&gt; points;</div><div class="line">  <span class="keywordflow">if</span> (0 == points.number_of_points()) {</div><div class="line"></div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"loaded "</span> &lt;&lt; points.number_of_points() &lt;&lt; <span class="stringliteral">" points\n"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Create an octree from the points</span></div><div class="line">  Octree octree(points, points.point_map());</div><div class="line"></div><div class="line">  <span class="comment">// Build the octree</span></div><div class="line">  octree.refine();</div><div class="line"></div><div class="line">  <span class="comment">// Print out the octree using preorder traversal</span></div><div class="line">  <span class="keywordflow">for</span> (Octree::Node node : octree.traverse&lt;Preorder_traversal&gt;()) {</div><div class="line"></div><div class="line">    std::cout &lt;&lt; node &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Section_Orthtree_Custom_Traversal"></a>
Custom Traversal</h2>
<p>Users can define their own traversal methods by creating models of the <code><a class="el" href="classOrthtreeTraversal.html" title="a traversal provides the functions needed to traverse the nodes of an orthtree. ">OrthtreeTraversal</a></code> concept. The following example shows how to define a custom traversal that only traverses the first branch of the octree:</p>
<p><br />
<b>File</b> <a class="el" href="Orthtree_2octree_traversal_custom_8cpp-example.html">Orthtree/octree_traversal_custom.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Octree.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3/IO.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Type Declarations</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-5.3-I-162/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-5.3-I-162/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-5.3-I-162/doc/scripts/doc_1_8_13/doc_tags/Point_set_3.tag:../Point_set_3/" href="../Point_set_3/classCGAL_1_1Point__set__3.html">CGAL::Point_set_3&lt;Point&gt;</a> Point_set;</div><div class="line"><span class="keyword">typedef</span> Point_set::Point_map Point_map;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Octree.html">CGAL::Octree&lt;Kernel, Point_set, Point_map&gt;</a> Octree;</div><div class="line"><span class="keyword">typedef</span> Octree::Node Node;</div><div class="line"></div><div class="line"><span class="keyword">struct </span>First_branch_traversal</div><div class="line">{</div><div class="line">  Node first (Node root)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> root;</div><div class="line">  }</div><div class="line"></div><div class="line">  Node next (Node n)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">if</span> (n.is_leaf())</div><div class="line">      <span class="keywordflow">return</span> Node();</div><div class="line">    <span class="keywordflow">return</span> n[0];</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv) {</div><div class="line"></div><div class="line">  <span class="comment">// Point set will be used to hold our points</span></div><div class="line">  Point_set points;</div><div class="line"></div><div class="line">  <span class="comment">// Load points from a file.</span></div><div class="line">  std::ifstream stream((argc &gt; 1) ? argv[1] : <span class="stringliteral">"data/cube.pwn"</span>);</div><div class="line">  stream &gt;&gt; points;</div><div class="line">  <span class="keywordflow">if</span> (0 == points.number_of_points()) {</div><div class="line"></div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"loaded "</span> &lt;&lt; points.number_of_points() &lt;&lt; <span class="stringliteral">" points\n"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Create an octree from the points</span></div><div class="line">  Octree octree(points, points.point_map());</div><div class="line"></div><div class="line">  <span class="comment">// Build the octree</span></div><div class="line">  octree.refine();</div><div class="line"></div><div class="line">  <span class="comment">// Print out the first branch using custom traversal</span></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;node : octree.traverse&lt;First_branch_traversal&gt;())</div><div class="line">    std::cout &lt;&lt; node &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Comparison"></a>
of Traversals</h2>
<p>Figure <a class="el" href="index.html#fig__Orthtree_traversal_fig">Figure 90.2</a> shows in which order nodes are visited depending on the traversal method used.</p>
<p><a class="anchor" id="fig__Orthtree_traversal_fig"></a></p><div class="image">
<img src="quadtree_traversal.png" alt="quadtree_traversal.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Orthtree_traversal_fig">Figure 90.2</a> Quadtree visualized as a graph. Each node is labelled according to the order in which it is visited by the traversal. When using leaves and level traversals, the quadtree is only partially traversed.  </div> <br /> 
<h1><a class="anchor" id="Section_Orthtree_Acceleration"></a>
Acceleration of Common Tasks</h1>
<p>Once an orthtree is built, its structure can be used to accelerate different tasks.</p>
<h2><a class="anchor" id="Section_Orthtree_Nearest_Neighbor"></a>
Finding the Nearest Neighbor of a Point</h2>
<p>The naive way of finding the nearest neighbor of a point requires finding the distance to every other point. An orthtree can be used to perform the same task in significantly less time. For large numbers of points, this can be a large enough difference to outweigh the time spent building the tree.</p>
<p>Note that a kd-tree is expected to outperform the orthtree for this task, it should be preferred unless features specific to the orthtree are needed.</p>
<p>The following example illustrates how to use an octree to accelerate the search for points close to a location.</p>
<p>Points are loaded from a file and an octree is built. The nearest neighbor method is invoked for several input points. A <code>k</code> value of 1 is used to find the single closest point. Results are put in a vector, and then printed.</p>
<p><br />
<b>File</b> <a class="el" href="Orthtree_2octree_find_nearest_neighbor_8cpp-example.html">Orthtree/octree_find_nearest_neighbor.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Octree.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3/IO.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;boost/iterator/function_output_iterator.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Type Declarations</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-5.3-I-162/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-5.3-I-162/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-5.3-I-162/doc/scripts/doc_1_8_13/doc_tags/Point_set_3.tag:../Point_set_3/" href="../Point_set_3/classCGAL_1_1Point__set__3.html">CGAL::Point_set_3&lt;Point&gt;</a> Point_set;</div><div class="line"><span class="keyword">typedef</span> Point_set::Point_map Point_map;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Octree.html">CGAL::Octree&lt;Kernel, Point_set, Point_map&gt;</a> Octree;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv) {</div><div class="line"></div><div class="line">  <span class="comment">// Point set will be used to hold our points</span></div><div class="line">  Point_set points;</div><div class="line"></div><div class="line">  <span class="comment">// Load points from a file.</span></div><div class="line">  std::ifstream stream((argc &gt; 1) ? argv[1] : <span class="stringliteral">"data/cube.pwn"</span>);</div><div class="line">  stream &gt;&gt; points;</div><div class="line">  <span class="keywordflow">if</span> (0 == points.number_of_points()) {</div><div class="line"></div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"loaded "</span> &lt;&lt; points.number_of_points() &lt;&lt; <span class="stringliteral">" points"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Create an octree from the points</span></div><div class="line">  Octree octree(points, points.point_map());</div><div class="line"></div><div class="line">  <span class="comment">// Build the octree</span></div><div class="line">  octree.refine(10, 20);</div><div class="line"></div><div class="line">  <span class="comment">// Find the nearest points to a few locations</span></div><div class="line">  std::vector&lt;Point&gt; points_to_find = {</div><div class="line">          {0, 0, 0},</div><div class="line">          {1, 1, 1},</div><div class="line">          {-1, -1, -1},</div><div class="line">          {-0.46026, -0.25353, 0.32051},</div><div class="line">          {-0.460261, -0.253533, 0.320513}</div><div class="line">  };</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> Point&amp; p : points_to_find)</div><div class="line">    octree.nearest_neighbors</div><div class="line">      (p, 1, <span class="comment">// k=1 to find the single closest point</span></div><div class="line">       boost::make_function_output_iterator</div><div class="line">       ([&amp;](<span class="keyword">const</span> Point&amp; nearest)</div><div class="line">        {</div><div class="line">          std::cout &lt;&lt; <span class="stringliteral">"the nearest point to ("</span> &lt;&lt; p &lt;&lt;</div><div class="line">            <span class="stringliteral">") is ("</span> &lt;&lt; nearest &lt;&lt; <span class="stringliteral">")"</span> &lt;&lt; std::endl;</div><div class="line">        }));</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Section_Orthtree_Grade"></a>
Grading</h2>
<p>An orthtree is graded if the difference of depth between two adjacent leaves is at most 1 for every pair of leaves.</p>
<p><a class="anchor" id="fig__Orthtree_quadree_graded_fig"></a></p><div class="image">
<img src="quadtree_graded.png" alt="quadtree_graded.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Orthtree_quadree_graded_fig">Figure 90.3</a> Quadtree before and after being graded.  </div> <br /> 
<p>The following example demonstrates how to use the grade method to eliminate large jumps in depth within the orthtree.</p>
<p>A tree is created such that one node is split many more times than those it borders. <a class="el" href="classCGAL_1_1Orthtree.html#a25ea4ef10f52a231c3ab54ab87565498">grade()</a> splits the octree's nodes so that adjacent nodes never have a difference in depth greater than one. The tree is printed before and after grading, so that the differences are visible.</p>
<p><br />
<b>File</b> <a class="el" href="Orthtree_2octree_grade_8cpp-example.html">Orthtree/octree_grade.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Octree.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Type Declarations</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-5.3-I-162/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-5.3-I-162/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point&gt; Point_vector;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Octree.html">CGAL::Octree&lt;Kernel, Point_vector&gt;</a> Octree;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line"></div><div class="line">  <span class="comment">// Here, our point set is a vector</span></div><div class="line">  Point_vector points;</div><div class="line"></div><div class="line">  <span class="comment">// Add a few points to the vector, most of which are in one region</span></div><div class="line">  points.emplace_back(1, 1, 1);</div><div class="line">  points.emplace_back(2, 1, -11);</div><div class="line">  points.emplace_back(2, 1, 1);</div><div class="line">  points.emplace_back(1, -2, 1);</div><div class="line">  points.emplace_back(1, 1, 1);</div><div class="line">  points.emplace_back(-1, 1, 1);</div><div class="line">  points.emplace_back(-1.1, 1, 1);</div><div class="line">  points.emplace_back(-1.01, 1, 1);</div><div class="line">  points.emplace_back(-1.001, 1, 1);</div><div class="line">  points.emplace_back(-1.0001, 1, 1);</div><div class="line">  points.emplace_back(-1.0001, 1, 1);</div><div class="line"></div><div class="line">  <span class="comment">// Create an octree from the points</span></div><div class="line">  Octree octree(points);</div><div class="line"></div><div class="line">  <span class="comment">// Build the octree with a small bucket size, so we get a deep node</span></div><div class="line">  octree.refine(10, 2);</div><div class="line"></div><div class="line">  <span class="comment">// Print out the tree</span></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"\nUn-graded tree"</span> &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"</span> &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; octree &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Grade the tree to eliminate large jumps in depth</span></div><div class="line">  octree.grade();</div><div class="line"></div><div class="line">  <span class="comment">// Print out the tree again</span></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"\nGraded tree"</span> &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"</span> &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; octree &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="Section_Orthtree_Performance"></a>
Performance</h1>
<h2><a class="anchor" id="Section_Orthtree_Performance_Construction"></a>
Tree Construction</h2>
<p>Tree construction benchmarks were conducted by randomly generating a collection of points, and then timing the process of creating a fully refined tree which contains them.</p>
<p>Because of its simplicity, an octree can be constructed faster than a kd-tree.</p>
<p><a class="anchor" id="fig__Orthtree_construction_benchmark_fig"></a></p><div class="image">
<img src="construction_benchmark.png" alt="construction_benchmark.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Orthtree_construction_benchmark_fig">Figure 90.4</a> Plot of the time to construct a tree.  </div> <br /> 
<h2><a class="anchor" id="Section_Orthtree_Performance_Nearest_Neighbors"></a>
Nearest Neighbors</h2>
<p>Orthtree nodes are uniform, so orthtrees will tend to have deeper hierarchies than equivalent kd-trees. As a result, orthtrees will generally perform worse for nearest neighbor searches. Both nearest neighbor algorithms have a theoretical complexity of O(log(n)), but the orthtree can generally be expected to have a higher coefficient.</p>
<p><a class="anchor" id="fig__Orthtree_nearest_neighbor_benchmark_fig"></a></p><div class="image">
<img src="nearest_neighbor_benchmark.png" alt="nearest_neighbor_benchmark.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Orthtree_nearest_neighbor_benchmark_fig">Figure 90.5</a> Plot of the time to find the 10 nearest neighbors of a random point using a pre-constructed tree.  </div> <br /> 
<p>The performance difference between the two trees is large, but both algorithms compare very favorably to the linear complexity of the naive approach, which involves comparing every point to the search point.</p>
<p>Using the orthtree for nearest neighbor computations instead of the kd-tree can be justified either when few queries are needed (as the construction is faster) or when the orthtree is also needed for other purposes.</p>
<p><a class="anchor" id="fig__Orthtree_nearest_neighbor_benchmark_with_naive_fig"></a></p><div class="image">
<img src="nearest_neighbor_benchmark_with_naive.png" alt="nearest_neighbor_benchmark_with_naive.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Orthtree_nearest_neighbor_benchmark_with_naive_fig">Figure 90.6</a> Plot of the time to find nearest neighbors using tree methods and a naive approach.  </div> <br /> 
<p>For nontrivial point counts, the naive approach's calculation time dwarfs that of either the orthtree or kd-tree.</p>
<h1><a class="anchor" id="Section_Orthtree_History"></a>
History</h1>
<p>A prototype code was implemented by Pierre Alliez and improved by Tong Zhao and CÃ©dric Portaneri. From this prototype code, the package was developed by Jackson Campolatarro as part of the Google Summer of Code</p><ol type="1">
<li>Simon Giraudot, supervisor of the GSoC internship, completed and finalized the package for integration in CGAL 5.3. Pierre Alliez provided kind help and advice all the way through. </li>
</ol>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sun Jul 4 2021 21:32:35 for CGAL 5.3 - Quadtrees, Octrees, and Orthtrees by
    <a href="https://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>


</html>
